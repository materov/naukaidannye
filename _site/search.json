[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Проекты",
    "section": "",
    "text": "О сайте\n\n\nДобро пожаловать на страницу, которая объединяет блог и Data Science проекты, созданные с помощью Quarto и языка программирования R! Сайт будет интересен для тех, кто интересуется различными аспектами:\n\n\n\n\nвоспроизводимого анализа данных\n\n\nвизуализации данных\n\n\nмоделирования и машинного обучения\n\n\n\n\n\n\n\n\n\n\nПроекты\n\n\n\n\n\n\n\n\n\n\nRесурсы\n\n\nполезные ссылки на источники по языку программирования R\n\n\n\n\n\n\n\n\n\n\n\n\n\nГрафики на досуге\n\n\nмини-блог по визуализации данных\n\n\n\n\n\n\n\n\n\n\n\n\n\nВведение в Quarto\n\n\nсерия митапов по основным навыкам работы в Quarto\n\n\n\n\n\n\n\nНет подходящих элементов"
  },
  {
    "objectID": "blog/index.html",
    "href": "blog/index.html",
    "title": "Наука и данные",
    "section": "",
    "text": "Сортировать\n       по умолчанию\n         \n          Заголовок\n        \n         \n          Дата - сначала старые\n        \n         \n          Дата - сначала новые\n        \n     \n  \n\n\n\n\n\n\n\n\n\n\nВизуализация трехмерных моделей земной поверхности\n\n\nПримеры 3D-визуализаций цифровой модели рельефа местности средствами библиотеки rayvista\n\n\n\nrayvista\n\n\nspatial\n\n\nRstats\n\n\n\n\n\n\n4 марта 2024 г.\n\n\nЕ.Н. Матеров\n\n\n\n\n\n\n\n\n\n\n\n\nПриемы работы и секреты ggplot2\n\n\nНекоторые практики и советы по работе с ggplot2\n\n\n\nggplot2\n\n\nRstats\n\n\n\n\n\n\n4 марта 2024 г.\n\n\nЕ.Н. Матеров\n\n\n\n\n\n\n\n\n\n\n\n\nНаучно-издательская система Quarto\n\n\nОбзор научно-издательской системы Quarto\n\n\n\nQuarto\n\n\n\n\n\n\n13 ноября 2022 г.\n\n\nЕ.Н. Матеров\n\n\n\n\n\n\n\n\n\n\n\n\nВведение в библиотеку highcharter\n\n\nОбзор библиотеки highcharter для визуализации интерактивной графики\n\n\n\nhighcharter\n\n\nRstats\n\n\n\n\n\n\n16 марта 2022 г.\n\n\nЕ.Н. Матеров\n\n\n\n\n\n\n\n\n\n\n\n\nАнализ графа дорожной сети\n\n\nПримеры анализа дорожной сети городской инфраструктуры на основе графов, встроенных в географическое пространство\n\n\n\nsfnetworks\n\n\nspatial\n\n\nRstats\n\n\n\n\n\n\n21 февраля 2022 г.\n\n\nЕ.Н. Матеров\n\n\n\n\n\n\n\n\n\n\n\n\nАнализ географически распределенных объектов городской инфраструктуры\n\n\nОбзор возможностей языка программирования R в применении к анализу расстояний между объектами городской инфраструктуры\n\n\n\nspatial\n\n\nRstats\n\n\n\n\n\n\n22 ноября 2021 г.\n\n\nЕ.Н. Матеров\n\n\n\n\n\n\n\n\n\n\n\n\nИнтерактивные таблицы средствами языка R\n\n\nПримеры создания интерактивных таблиц на основе библиотеки reactable\n\n\n\nreactable\n\n\nRstats\n\n\n\n\n\n\n20 июля 2021 г.\n\n\nЕ.Н. Матеров\n\n\n\n\n\n\n\n\n\n\n\n\nИспользование машинного обучения для анализа временных рядов\n\n\nОбзор работы с библиотекой modeltime, использующей машинное обучение для моделирования и прогнозирования временных рядов\n\n\n\nmodeltime\n\n\ntimeseries\n\n\nRstats\n\n\n\n\n\n\n9 января 2021 г.\n\n\nЕ.Н. Матеров\n\n\n\n\n\n\nНет подходящих элементов"
  },
  {
    "objectID": "blog/posts/2022-03-16-highcharter/index.html#географические-карты-в-highcharter",
    "href": "blog/posts/2022-03-16-highcharter/index.html#географические-карты-в-highcharter",
    "title": "Введение в библиотеку highcharter",
    "section": "Географические карты в highcharter",
    "text": "Географические карты в highcharter\nПокажем, как можно визуализировать простейшие географические данные в highcharter. В качестве примера визуализируем на карте Российской Федерации города, население которых превышает 300 000 чел. Актуальные данные по городам РФ можно получить с сайта ИНИД1. После простейшей предобработки таблица с данными выглядит следующим образом.\n\ncities_300 \n\n# A tibble: 65 × 4\n   name             population   lon   lat\n   &lt;chr&gt;                 &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 Калининград          467289  20.4  54.7\n 2 Пенза                522317  45    53.2\n 3 Владимир             356168  40.4  56.1\n 4 Иркутск              623479 104.   52.3\n 5 Оренбург             561686  55.1  51.8\n 6 Архангельск          348343  40.5  64.5\n 7 Саранск              318578  45.2  54.2\n 8 Набережные Челны     524444  52.4  55.7\n 9 Ярославль            603961  39.9  57.6\n10 Чебоксары            492331  47.2  56.1\n# ℹ 55 more rows\n\n\nДобавим цвет для визуального отображения количества населения в каждой точке.\n\ncities_300 &lt;- cities_300 |&gt;\n  mutate(colors = colorize(population))\n\nНепосредственно подложка карты скачивается со страницы Highcharts2, затем добавляется слой с городами, параметр tooltip отвечает за всплывающие подсказки в коде для визуализации карты.\n\n\nКод\n\nhcmap(\"countries/ru/custom/ru-all-disputed\", \n       showInLegend = FALSE) |&gt;\n  hc_add_series(\n    data = cities_300, \n    type = \"mappoint\",\n    hcaes(color = colors),\n    name = \"Город\",\n    tooltip = list(pointFormat = \n              \"{point.name}: {point.population:,.0f} чел.\")\n  ) |&gt;\n  hc_title(text = \"Города с населением свыше 300 000 чел.\") |&gt;\n  hc_subtitle(text = \"на 12.03.2021\")\n\n\n\n\n\nДругой пример построения карт показывает как можно визуализировать глобальную карту. В качестве примера используем данные Global Climate Change Data (источник: Berkeley Earth).\n\nAverageTemperature \n\n# A tibble: 169 × 3\n   country              aveT iso3 \n   &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;\n 1 Afghanistan            15 AFG  \n 2 Albania                14 ALB  \n 3 Algeria                24 DZA  \n 4 Andorra                12 ADO  \n 5 Antigua and Barbuda    27 ATG  \n 6 Argentina              15 ARG  \n 7 Armenia                10 ARM  \n 8 Australia              22 AUS  \n 9 Austria                 7 AUT  \n10 Azerbaijan             13 AZE  \n# ℹ 159 more rows\n\n\n\n\nКод\n\nhcmap(\n  \"custom/world-robinson-lowres\", \n  data = AverageTemperature,\n  name = \"температура\", \n  value = \"aveT\",\n  # необходимо сделать join стандартных индексов карты \"iso-a3\"\n  # и индексов стран из данных -- переменной \"iso3\"\n  joinBy        = c(\"iso-a3\", \"iso3\"), \n  borderWidth   = 0,\n  nullColor     = \"#d3d3d3\",\n  tooltip       = list(valueSuffix = \"°C\")\n  ) |&gt;\n  hc_colorAxis(\n    stops = color_stops(colors = \n                        viridisLite::inferno(10, begin = 0.1))\n  ) |&gt;\n  hc_title(text    = \"Средняя температура земной поверхности\") |&gt; \n  hc_subtitle(text = \"за период 2000-2013 гг.\")"
  },
  {
    "objectID": "blog/posts/2022-03-16-highcharter/index.html#локализация-highcharter",
    "href": "blog/posts/2022-03-16-highcharter/index.html#локализация-highcharter",
    "title": "Введение в библиотеку highcharter",
    "section": "Локализация highcharter",
    "text": "Локализация highcharter\nИдея переопределения языковых опций в highcharter основана на ответах Stack Overflow 1, Stack Overflow 2, а также Highcharts Configuration options. Сначала необходимо получить текущие настройки локализации в переменную lang.\n\nlang &lt;- getOption(\"highcharter.lang\")\n\nНапример, для сокращений дней недели переопределение значений выглядит так:\n\nlang$shortWeekdays &lt;- c(\"Сб\", \"Вс\", \"Пн\", \"Вт\", \"Ср\", \"Чт\", \"Пт\")\n\n\n\nПолный код локализации\nlang$contextButtonTitle &lt;- \"Контекстное меню диаграммы\"\n\nlang$decimalPoint &lt;- \",\"\n\nlang$downloadCSV  &lt;- \"Загрузить CSV\"\nlang$downloadJPEG &lt;- \"Загрузить JPEG\"\nlang$downloadPDF  &lt;- \"Загрузить PDF\"\nlang$downloadPNG  &lt;- \"Загрузить PNG\"\nlang$downloadSVG  &lt;- \"Загрузить SVG\"\nlang$downloadXLS  &lt;- \"Загрузить XLS\"\n\nlang$drillUpText &lt;- \"◁ Назад к {series.name}\"\n\nlang$exitFullscreen &lt;- \"Выход из полноэкранного режима\"\n\nlang$exportData$annotationHeader &lt;- \"Аннотации\"\n\nlang$exportData$categoryHeader &lt;- \"Категория\"\n\nlang$hideData &lt;- \"Скрыть таблицу данных\"\n\nlang$loading &lt;- \"Загрузка...\"\n\nlang$months &lt;- c(\"Январь\", \"Февраль\", \"Март\", \"Апрель\", \"Май\", \"Июнь\", \"Июль\", \"Август\", \"Сентябрь\", \"Октябрь\", \"Ноябрь\", \"Декабрь\")\n\nlang$noData &lt;- \"Нет данных для отображения\"\n\nlang$printChart &lt;- \"Печать диаграммы\"\n\nlang$resetZoom &lt;- \"Сброс масштабирования\"\n\nlang$resetZoomTitle &lt;- \"Сброс масштабирования к 1:1\"\n\nlang$shortMonths &lt;- c(\"Янв\", \"Фев\", \"Мар\", \"Апр\", \"Май\", \"Июн\", \"Июл\", \"Авг\", \"Сен\", \"Окт\", \"Ноя\", \"Дек\")\n\nlang$shortWeekdays &lt;- c(\"Сб\", \"Вс\", \"Пн\", \"Вт\", \"Ср\", \"Чт\", \"Пт\")\n\nlang$thousandsSep &lt;- \" \"\n\nlang$viewData &lt;- \"Просмотр таблицы данных\"\n\nlang$viewFullscreen &lt;- \"Просмотр в полноэкранном режиме\"\n\nlang$weekdays &lt;- c(\"Воскресенье\", \"Понедельник\", \"Вторник\", \"Среда\", \"Четверг\", \"Пятница\", \"Суббота\")\n\n\nПосле переопределения настроек их необходимо сохранить.\n\noptions(highcharter.lang = lang)"
  },
  {
    "objectID": "blog/posts/2022-03-16-highcharter/index.html#отображение-биржевых-котировок",
    "href": "blog/posts/2022-03-16-highcharter/index.html#отображение-биржевых-котировок",
    "title": "Введение в библиотеку highcharter",
    "section": "Отображение биржевых котировок",
    "text": "Отображение биржевых котировок\nБиблиотека highcharter может служить для отображения актуальных биржевых котировок на основе API библиотеки quantmod. Ниже приведен пример для отображения графика стоимости акций Apple.\n\n\n\nКод\nlibrary(\"quantmod\")\n\n# https://itecnote.com/tecnote/r-convert-between-zoo-object-and-data-frame-results-inconsistent-for-different-numbers-of-columns/\nzooToDf &lt;- function(z) {\n  df &lt;- as.data.frame(z) \n  df$Date &lt;- time(z)   #create a Date column\n  rownames(df) &lt;- NULL #so row names not filled with dates\n  df &lt;- df[,c(ncol(df), 1:(ncol(df)-1))] #reorder columns so Date first\n  return(df)\n}\n\nAAPL &lt;- getSymbols(\"AAPL\", \n                  from = Sys.Date() - lubridate::years(1), \n                  auto.assign = FALSE)\n\nAAPL &lt;- AAPL |&gt; na.omit()\n\nAAPL.ave &lt;- SMA(Cl(AAPL), n = 5)\n\nAAPL_df &lt;- zooToDf(AAPL) |&gt; as_tibble()\n\ndata_flags &lt;- tibble(\n  date = as.Date(c(\"2023-06-05\", \"2023-09-12\", \"2023-10-30\")),\n  title = c(\"WWDC 2023\", \"Apple event '23\", \"Scary fast event\"),\n  text = c(\"Apple Vision Pro\", \"iPhone 15\", \"M3 chips\")\n)\n\nhighchart(type = \"stock\") |&gt;\n  hc_add_theme(hc_theme_hcrt()) |&gt;\n  hc_add_series(AAPL, \n                id = 1,\n                yAxis = 0, \n                name  = \"AAPL\") |&gt;\n  hc_add_series(AAPL.ave, \n                yAxis = 0, \n                name  = \"скользящее среднее AAPL\",\n                color = hex_to_rgba(\"blue\", 0.6)) |&gt;\n  hc_tooltip(valueDecimals = 2) |&gt;\n  hc_yAxis(labels = list(format = \"${value}\")) |&gt;\n  #hc_title(text = \"Котировки Apple за последний год\") %&gt;% \n    hc_exporting(\n    enabled = TRUE\n  ) |&gt; \n  hc_add_series(\n    data_flags, \n    hcaes(x = date),\n    type = \"flags\", \n    onSeries = 1\n    )"
  },
  {
    "objectID": "blog/posts/2022-03-16-highcharter/index.html#примеры-применения-различных-тем-в-highcharter",
    "href": "blog/posts/2022-03-16-highcharter/index.html#примеры-применения-различных-тем-в-highcharter",
    "title": "Введение в библиотеку highcharter",
    "section": "Примеры применения различных тем в highcharter",
    "text": "Примеры применения различных тем в highcharter\nЗагрузим данные GISS Surface Temperature Analysis по средним температурам для оценки глобального изменения температуры земной поверхности за последние несколько лет в г. Красноярске. Графики и таблицы обновлялись примерно в середине каждого месяца с использованием текущих файлов данных NOAA GHCN v4 для метеорологических станций.\nНас будут интересовать средние температуры в каждом месяце начиная с 2013 года.\n\nweather_long\n\n# A tibble: 72 × 3\n    year month temp_ave\n   &lt;dbl&gt; &lt;fct&gt;    &lt;dbl&gt;\n 1  2013 ЯНВ     -16.3 \n 2  2013 ФЕВ     -14.3 \n 3  2013 МАР      -6.45\n 4  2013 АПР       4.71\n 5  2013 МАЙ       8.81\n 6  2013 ИЮН      15.7 \n 7  2013 ИЮЛ      18.1 \n 8  2013 АВГ      16.5 \n 9  2013 СЕН       7.9 \n10  2013 ОКТ       2.4 \n# ℹ 62 more rows\n\n\nСформируем из этих данных временной ряд и спрогнозируем значения временного ряда на 2 года (24 месяца) вперед (см. Forecasting with ETS models).\n\n\nКод\nlibrary(forecast)\n\nweather_month_ts &lt;- ts(weather_long[\"temp_ave\"], \n                       start = c(2013, 1), frequency = 12)\n\nweather_forecast &lt;- forecast(ets(weather_month_ts), \n                             h = 24, level = 95)\n\nweather_forecast |&gt; head(3)\n\n\n$model\nETS(A,N,A) \n\nCall:\n ets(y = weather_month_ts) \n\n  Smoothing parameters:\n    alpha = 1e-04 \n    gamma = 1e-04 \n\n  Initial states:\n    l = 2.7551 \n    s = -12.3157 -10.3952 -0.9107 6.561 14.5926 16.6841\n           15.0192 6.8878 2.8664 -5.9789 -14.7177 -18.2929\n\n  sigma:  2.958\n\n     AIC     AICc      BIC \n478.5228 487.0943 512.6728 \n\n$mean\n            Jan        Feb        Mar        Apr        May        Jun\n2019 -15.537883 -11.962662  -3.223877   5.621412   9.642804  17.774297\n2020 -15.537883 -11.962662  -3.223877   5.621412   9.642804  17.774297\n            Jul        Aug        Sep        Oct        Nov        Dec\n2019  19.439087  17.347607   9.316062   1.844221  -7.640216  -9.560651\n2020  19.439087  17.347607   9.316062   1.844221  -7.640216  -9.560651\n\n$level\n[1] 95\n\n\nТеперь создадим базовый highcharter-график.\n\n\nКод\nhc_weather &lt;- hchart(weather_forecast) |&gt;\n  hc_title(\n    text = \"Прогноз средних температур в г. Красноярске (в °C)\"\n  ) |&gt;\n  hc_yAxis(labels = list(format = \"{value} °C\")) |&gt;\n  hc_tooltip(shared = TRUE, \n             valueDecimals = 1)\n\n\nОтобразим полученный результат используя стилизованную тему.\n\nhc_weather |&gt;\n  hc_add_theme(hc_theme_smpl())\n\n\n\n\n\nВизуализируем тот же график используя другие темы.\n\nhc_weather |&gt;\n  hc_add_theme(hc_theme_google())\n\n\n\n\n\n\nhc_weather |&gt;\n  hc_add_theme(hc_theme_538())"
  },
  {
    "objectID": "blog/posts/2022-03-16-highcharter/index.html#d-диаграммы",
    "href": "blog/posts/2022-03-16-highcharter/index.html#d-диаграммы",
    "title": "Введение в библиотеку highcharter",
    "section": "3D-диаграммы",
    "text": "3D-диаграммы\nДовольно эффектно выглядят 3D-диаграммы в highcharter. Покажем, как выглядит диаграмма средних температур на основе набора данных weather_long выше в г. Красноярске за 3 выбранных года.\n\n# данные\nweather_hc &lt;-\nweather_long |&gt;\n  filter(year %in% c(\"2016\",\"2017\", \"2018\")) |&gt;\n  group_by(year, month) |&gt;\n  summarise(ave = round(mean(temp_ave, na.rm = TRUE), 1)) |&gt;\n  ungroup()\n\nweather_hc\n\n# A tibble: 36 × 3\n    year month   ave\n   &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt;\n 1  2016 ЯНВ   -21.8\n 2  2016 ФЕВ    -8.6\n 3  2016 МАР    -2.4\n 4  2016 АПР     5.1\n 5  2016 МАЙ     9  \n 6  2016 ИЮН    18.5\n 7  2016 ИЮЛ    20.7\n 8  2016 АВГ    17.2\n 9  2016 СЕН    12.2\n10  2016 ОКТ    -3.8\n# ℹ 26 more rows\n\n\n\n\nКод исходной диаграммы\n# базовая диаграмма\nhc &lt;- highchart() |&gt;\n  hc_xAxis(categories = weather_hc$month) |&gt;\n  hc_add_series(\n    name = \"2016\", \n    tooltip = list(\n      valueSuffix = \"°C\"\n    ), \n    data = (weather_hc |&gt; dplyr::filter(year == \"2016\"))$ave\n  ) |&gt;\n  hc_xAxis(categories = weather_hc$month) |&gt;\n  hc_add_series(\n    name = \"2017\", \n    tooltip = list(\n      valueSuffix = \"°C\"\n    ),\n    data = (weather_hc |&gt; dplyr::filter(year == \"2017\"))$ave\n  ) |&gt;\n  hc_xAxis(categories = weather_hc$month) |&gt;\n  hc_add_series(\n    name = \"2018\", \n    tooltip = list(\n      valueSuffix = \"°C\"\n    ),\n    data = (weather_hc |&gt; dplyr::filter(year == \"2018\"))$ave\n  ) |&gt;\n  hc_yAxis(labels = list(format = \"{value} °C\")) |&gt;\n  hc_add_theme(hc_theme_bloom()) %&gt;% \n  hc_credits(\n    text = \"Диаграмма создана при использовании R и highcharter\",\n    href = \"https://jkunst.com/highcharter/\",\n    enabled = TRUE\n  )  |&gt;\n  hc_title(\n    text = \"Средние температуры в г. Красноярске в 2016-2018 гг.\"\n  )\n\n\n3D-версия диаграммы.\n\nhc |&gt;\n  hc_chart(\n    type = \"column\",\n    options3d = list(\n      enabled = TRUE, \n      beta = 15,\n      alpha = 15\n    )\n  )"
  },
  {
    "objectID": "blog/posts/2022-03-16-highcharter/index.html#footnotes",
    "href": "blog/posts/2022-03-16-highcharter/index.html#footnotes",
    "title": "Введение в библиотеку highcharter",
    "section": "Сноски",
    "text": "Сноски\n\n\nДата обновления: 12.03.2021↩︎\nЕсли карты не скачиваются, см. Bugs in highcharter maps↩︎"
  },
  {
    "objectID": "blog/posts/2024-01-26 ggplot2/index.html",
    "href": "blog/posts/2024-01-26 ggplot2/index.html",
    "title": "Приемы работы и секреты ggplot2",
    "section": "",
    "text": "В настоящий момент трудно представить себе, что кто-то начинает изучать язык программирования R и не слышал о библиотеке ggplot2. Это очень мощный инструмент, который позволяет делать графики с помощью наложения слоев, работать со статистическими моделями, точно настраивать последовательность появления элементов на графиках и многое другое. Краткие основы ggplot2 можно посмотреть на странице справочного руководства.\nПо основам работы с библиотекой выпущено немало книг, из которых можно отметить\n\nggplot2: Elegant Graphics for Data Analysis\nData Visualization. A practical introduction\nModern Data Visualization with R\nВизуализация данных с помощью ggplot2\nГлава Грамматика графики ggplot2 книги Анализ данных и статистика в R\n\nЛучший способ научиться основам визуального представления данных в ggplot2 – это практика, но когда хочется посмотреть, как делают что-то эксперты, увидеть структурированный материал, нужно коротко и по существу, то мы прибегаем к курсам. Курсов и обучающих материалов по ggplot2 очень много, выделим лишь несколько интересных:\n\nClaus O. Wilke: курс Data Visualization in R на основе его книги Fundamentals of Data Visualization\nDr. Cédric Scherer: курс Engaging and Beautiful Data Visualizations with ggplot2.\nDr. Andrew Heiss: курс Data Visualization with R.\n\nДополнительные исчерпывающие ресурсы по ggplot2 включают в себя: ggplot2 extensions, Awesome ggplot2, awesome-r-dataviz и ggplot tricks.\nХорошо отражены элементы графиков в ggplot2 на рисунке:\n\n\n\n\n\n\nРисунок 1: Элементы графика в ggplot2 (источник)\n\n\n\nНе следует забывать, что вид графика напрямую зависит от типов данных (численные, категорные и т.д.), которые следует отразить на графике и то, что исходные данные должны быть в длинном формате. Для выбора вида графика существуют памятки, которые собраны на сайте Data Visualization Reference Guides. Пример постера по выбору графика показан ниже.\n\n\n\n\n\n\nРисунок 2: Виды графиков в зависимости от типов данных (источник)\n\n\n\nНесомненно, одним из самых впечатляющих вкладов в популяризацию ggplot2 являются визуализации социальных проектов, например, #TidyTuesday.\n\n\n\n\n\n\nДалее будут показаны некоторые (возможно) не совсем очевидные приемы и советы по работе с ggplot2 и расширениями, которые подсмотрены у опытных пользователей и которые можно использовать в повседневной работе. Данная страница не является полноценным руководством по ggplot2 и не заменяет книги и справочные материалы.\n\n\n\n\n\nДля визуализации данных в ggplot2 существует большое количество различных тем. Чтобы не искать среди множества, выделим некоторые, хорошо подходящие для научных публикаций. Сначала создадим базовый график, отметив некоторые особенности в коде.\n\n# коллекция библиотек tidyverse 📦\nlibrary(tidyverse)\n\n# библиотека с данными\nlibrary(palmerpenguins)\n\nПусть наш график отражает размеры клюва пингвинов по данным из библиотекиpalmerpenguins, а внутренняя переменная отвечает за массу тела.\n\ngg_base &lt;- \n  penguins |&gt; \n  na.omit() |&gt; \n  ggplot(aes(x = bill_length_mm,\n             y = bill_depth_mm,\n             fill = species,\n             size = body_mass_g)) + \n1  geom_point(pch = 21,\n             color = \"white\", \n             alpha = 0.7) +\n  scale_x_continuous(name = \"Длина клюва\",\n2                     labels = function(x) str_c(x, \" мм\")) +\n  scale_y_continuous(name = \"Высота клюва\",\n                     labels = function(x) str_c(x, \" мм\"))\n\ngg_base\n\n\n1\n\nздесь pch = 21 соответствует графическому параметру символа, который будет использоваться при построении точек;\n\n2\n\nкоманда scale_*_continuous(labels = function(x) str_c(x, \" мм\")) добавляет определенный текст (в нашем случае это единицы измерения: мм) к каждому числу на осях.\n\n\n\n\n\n\n\n\n\n\nРисунок 3: Исходный ggplot2-график\n\n\n\n\n\nНастроим график.\n\ngg_base +\n1  theme_grey(base_size = 13) +\n  scale_fill_manual(\n    values = c(Adelie = \"#0072B2\", \n               Chinstrap = \"#D55E00\", \n               Gentoo = \"#018571\"),\n    breaks = c(\"Adelie\", \"Chinstrap\", \"Gentoo\"),\n    labels = c(\"Adelie\", \"Chinstrap\", \"Gentoo\"),\n    name = NULL,\n    guide = guide_legend(\n      direction = \"horizontal\",\n2      override.aes = list(size = 4,\n                          alpha = 1)\n    ) \n  ) +\n3  guides(size = \"none\") +\n  theme(\n    legend.position = \"top\",\n    legend.justification = \"right\",\n4    legend.box.spacing = unit(0.1, \"cm\"),\n5    plot.margin = ggplot2::margin(t = 0.01,\n                                  r = 0.01, \n                                  b = 0.01, \n                                  l = 0.01, \"cm\")\n  )\n\n\n1\n\nбазовый шрифт можно увеличить командой theme_*(base_size = 13);\n\n2\n\nразмер и прозрачность точек на графике по умолчанию соответствует аналогичным элементам в легенде, что не всегда хорошо для легенды, поскольку в этом случае она может быть плохо видна, исправить положение можно, например, командой: guides(color = guide_legend(override.aes = list(size = 4, alpha = 1))), переписав значения для элементов легенды;\n\n3\n\nубирает из легенды элемент, соответствующий размеру точек;\n\n4\n\nрасстояние между легендой и графиком;\n\n5\n\nиногда важно уменьшить поля, сделав полезную площадь графика больше, указав отступы с каждой стороны графика1.\n\n\n\n\n\n\n\n\n\n\nРисунок 4: Преобразованный ggplot2-график\n\n\n\n\n\nНепосредственно в самой библиотеке ggplot2 существует ряд тем, которые хорошо подходят для графиков научных публикаций, например, theme_bw(), theme_classic(), theme_light() или theme_minimal(), достаточно в ggplot2 коде сделать изменение, написав вместо theme_grey() соответствующее название темы.\n\n\nРассмотрим сторонние темы ggplot2. Библиотека hrbrthemes, которую создал Bob Rudis позволяет создавать в R визуально привлекательные графики публикационного качества, его продуманные темы и расширенные настройки типографики упрощают создание визуализаций. Актуальную версию библиотеки можно установить командой\nremotes::install_github(\"hrbrmstr/hrbrthemes\")\nДля применения темы нужно указать тему theme_ipsum() в коде.\n\n\n\n\n\n\n\n\nРисунок 5: Применение темы из библиотеки hrbrthemes\n\n\n\n\n\nБиблиотека содержит множество различных настроек, включая темную тему, вариации шрифтов и отрисовку осей.\n\n\n\nБиблиотека ggpubr(автор Alboukadel Kassambara) помогает исследователям легко создавать графики, готовые к публикации, упрощает изменение графических параметров, позволяет добавлять p-значения и уровни значимости к гистограммам, линейным графикам и т. д. Установить библиотеку можно командами:\ninstall.packages(\"ggpubr\")\ndevtools::install_github(\"kassambara/ggpubr\")\nСледующий график соответствует theme_pubr().\n\n\n\n\n\n\n\n\nРисунок 6: Применение темы из библиотеки ggpubr\n\n\n\n\n\n\n\n\nJulia Silge создала несколько тем, которые (после установки соответствующих шрифтов) можно использовать в графиках. Загрузить библиотеку с темами можно с GitHub:\ndevtools::install_github(\"juliasilge/silgelib\")\nНиже показан пример темы: silgelib::theme_roboto().\n\n\n\n\n\n\n\n\nРисунок 7: Применение темы из библиотеки silgelib\n\n\n\n\n\n\nЕсли рассмотренных тем недостаточно, то множество дополнительных тем можно найти на странице библиотеки ggthemes, например, theme_tufte() на основе стиля, автор которого Edward Tufty или theme_fivethirtyeight().\nБиблиотека ggridges предназначена в первую очередь для построения хребтовых диаграмм (риджлайнов), однако у нее также доступна тема для ggplot2 по команде ggridges::theme_ridges().\nТакже стоит упомянуть темы bbplot из BBC Visual and Data Journalism cookbook for R graphics и ftplottools::ft_theme().\n\n\n\n\nИногда удобно воспользоваться библиотекой ggdirectlabel, которая служит для упрощения нанесения условных обозначений в ggplot2, перенося их внутрь диаграммы вместо отдельной легенды. На рисунке показан пример замены легенды на упрощенный вариант. В нашем случае использовалась команда, которую необходимо добавить в код для ggplot2-графика:\n+ geom_richlegend(aes(label = species, color = species))\n\n\n\n\n\n\n\n\nРисунок 8: Пример упрощения легенды с помощью библиотеки ggdirectlabel\n\n\n\n\n\n\n\n\nЕсть достаточно простой и быстрый способ посмотреть всевозможные темы для исходного графика (например, мы ничего не сказали выше про темные темы), сделав в некотором роде примерку. Для этого можно использовать библиотеку ggautothemes, которая покажет как выглядят свыше 30 различных тем в применении к исходному графику.\nlibrary(ggautothemes)\nПусть gg_base – исходный график, тогда можно сформировать набор графиков с различными темами по исходному следующим образом:\n# формирование графиков с темами по исходному\nautoallthemes(gg_base)\n\n\n\nИспользование theme_set() позволяет избежать репликации написания кода для установки темы, полностью переписывая текущую тему. Можно одним приемом задать тему для всех графиков в документе, например:\ntheme_set(\n  # стартовая тема\n  ggplot2::theme_classic() +\n  # элементы устанавливаемой темы\n  theme(\n    legend.text = element_text(size = 12),\n    axis.title.x = element_text(size = 11),\n    axis.title.y = element_text(size = 11),\n    legend.position = \"top\",\n    legend.justification = \"right\",\n    legend.box.spacing = unit(0.1, \"cm\"),\n    plot.margin = ggplot2::margin(t = 0.01, \n                                  r = 0.01, \n                                  b = 0.01, \n                                  l = 0.01, \"cm\")\n  )\nДля любой темы можно получить элемент темы, используя [[. Затем можно использовать оператор %+replace% для замены определенных элементов темы на необходимые. Например, пусть мы хотим применить к исходному графику gg_base тему theme_ipsum() из библиотеки hrbrthemes везде, кроме текста значений по осям:\n\ngg_base +\n  hrbrthemes::theme_ipsum(grid = \"XY\", \n                          base_size = 14) %+replace% \n  theme(axis.title = ggthemes::theme_gdocs()[[\"axis.title\"]],\n        axis.title.x = ggthemes::theme_gdocs()[[\"axis.title.x\"]],\n        axis.title.y = ggthemes::theme_gdocs()[[\"axis.title.y\"]],\n        legend.position = \"none\") +\n  NULL\n\n\n\n\n\n\n\nРисунок 9: Пример замены элементов темы\n\n\n\n\n\nОтметим, что код выше заканчивается + NULL, это удобно в случае отладки графика, когда будут еще добавляться строки в код.\n\n\n\n\nДля того, чтобы комбинировать графики в ggplot2 можно воспользоваться библиотекой patchwork. Здесь алгебра комбинирования довольно простая: например, если даны графики p1, p2, то p1 | p2 разместит графики рядом друг с другом, p1 / p2 разместит их друг над другом и т.д.\nОдин из интересных приемов, чтобы собрать графики предложил June Choe.\n\n\n\n\n\n\nПредложенный подход основан на использовании I() (AsIs variables) и работает только с ggplot2 версии 3.5.0 и выше.\n\n\n\n\nlibrary(patchwork)\n\nx &lt;- 1:100\ny &lt;- x^2  \ndf_combine &lt;- data.frame(x, y)\n\np &lt;- ggplot(df_combine, aes(x, y)) +\n  geom_line() +\n  theme_grey(base_size = 14)\n\n\n\nКод: функция комбинирования графиков\nannotate_broken_axis &lt;- function(pos, size = 0.03){\n  mid &lt;- switch(\n    pos,\n    \"bl\" = list(x = 0, y = 0),\n    \"br\" = list(x = 1, y = 0),\n    \"tl\" = list(x = 0, y = 1),\n    \"tr\" = list(x = 1, y = 1)\n  )\n  slash &lt;- annotate(\n    \"segment\",\n    x = I(mid$x - size), xend = I(mid$x + size),\n    y = I(-size), yend = I(size)\n  )\n  list(slash, coord_cartesian(clip = \"off\"))\n}\n\n\n\nscale_mark &lt;- \nscale_y_continuous(labels = function(x) format(x, big.mark = \" \",\n                                                 scientific = FALSE)) \n\np1 &lt;- p +\n  scale_x_continuous(limits = c(1, 70)) +\n  annotate_broken_axis(pos = \"br\") +\n  scale_mark\n\np2 &lt;- p +\n  scale_x_continuous(limits = c(80, 100)) +\n  annotate_broken_axis(pos = \"bl\") +\n  scale_mark\n\np1 + p2 +\n  plot_layout(axis = \"collect\") &\n  theme(axis.line.x = element_line())\n\n\n\n\n\n\n\nРисунок 10: Пример комбинирования графиков\n\n\n\n\n\nВ коде выше функция внутри scale_y_continuous(...) позволяет сделать пробелы-разделители для разрядов тысяч.\n\n\n\nОдна из возможностей добавления дополнительной графической информации к графику – построение надграфиков аналогично панелированию, что можно сделать, например, в библиотеке ggside.\n\n\nКод: базовый график для надстройки\ngg_side_plot &lt;- \n  penguins |&gt; \n  na.omit() |&gt; \n  ggplot(aes(x = bill_length_mm,\n             y = bill_depth_mm,\n             fill = species)) + \n  geom_point(pch = 21,\n             size = 4,\n             color = \"white\", \n             alpha = 0.8) +\n  theme_grey(base_size = 13) +\n  scale_fill_manual(\n    values = c(\"#0072B2\", \n               \"#D55E00\", \n               \"#018571\")\n  ) +\n  scale_x_continuous(name = \"Длина клюва\",\n                     labels = function(x) str_c(x, \" мм\")) +\n  scale_y_continuous(name = \"Высота клюва\",\n                     labels = function(x) str_c(x, \" мм\")) +\n  theme(\n    legend.position = \"none\",\n    plot.margin = ggplot2::margin(t = 0.01,\n                                  r = 0.01, \n                                  b = 0.01, \n                                  l = 0.01, \"cm\")\n  )\n\n\nВсе геометрии, поддерживаемые ggside имеют шаблон geom_xside* или geom_yside* и добавляются в качестве дополнительного слоя в ggplot2-график как обычно.\n\nlibrary(ggside)\n\ngg_side_plot +\n  geom_xsideboxplot(aes(y = species), \n                    orientation = \"y\",\n                    alpha = 0.8) +\n  geom_ysidedensity(aes(x = after_stat(density)), \n                    position = \"identity\",\n                    alpha = 0.8) +\n  scale_ysidex_continuous(guide = guide_axis(angle = 90), \n                          minor_breaks = NULL) +\n  theme(ggside.panel.scale = 0.3)\n\n\n\n\n\n\n\nРисунок 11: Пример добавления дополнительного информационного слоя"
  },
  {
    "objectID": "blog/posts/2024-01-26 ggplot2/index.html#темы-ggplot2-для-научных-публикаций",
    "href": "blog/posts/2024-01-26 ggplot2/index.html#темы-ggplot2-для-научных-публикаций",
    "title": "Приемы работы и секреты ggplot2",
    "section": "",
    "text": "Для визуализации данных в ggplot2 существует большое количество различных тем. Чтобы не искать среди множества, выделим некоторые, хорошо подходящие для научных публикаций. Сначала создадим базовый график, отметив некоторые особенности в коде.\n\n# коллекция библиотек tidyverse 📦\nlibrary(tidyverse)\n\n# библиотека с данными\nlibrary(palmerpenguins)\n\nПусть наш график отражает размеры клюва пингвинов по данным из библиотекиpalmerpenguins, а внутренняя переменная отвечает за массу тела.\n\ngg_base &lt;- \n  penguins |&gt; \n  na.omit() |&gt; \n  ggplot(aes(x = bill_length_mm,\n             y = bill_depth_mm,\n             fill = species,\n             size = body_mass_g)) + \n1  geom_point(pch = 21,\n             color = \"white\", \n             alpha = 0.7) +\n  scale_x_continuous(name = \"Длина клюва\",\n2                     labels = function(x) str_c(x, \" мм\")) +\n  scale_y_continuous(name = \"Высота клюва\",\n                     labels = function(x) str_c(x, \" мм\"))\n\ngg_base\n\n\n1\n\nздесь pch = 21 соответствует графическому параметру символа, который будет использоваться при построении точек;\n\n2\n\nкоманда scale_*_continuous(labels = function(x) str_c(x, \" мм\")) добавляет определенный текст (в нашем случае это единицы измерения: мм) к каждому числу на осях.\n\n\n\n\n\n\n\n\n\n\nРисунок 3: Исходный ggplot2-график\n\n\n\n\n\nНастроим график.\n\ngg_base +\n1  theme_grey(base_size = 13) +\n  scale_fill_manual(\n    values = c(Adelie = \"#0072B2\", \n               Chinstrap = \"#D55E00\", \n               Gentoo = \"#018571\"),\n    breaks = c(\"Adelie\", \"Chinstrap\", \"Gentoo\"),\n    labels = c(\"Adelie\", \"Chinstrap\", \"Gentoo\"),\n    name = NULL,\n    guide = guide_legend(\n      direction = \"horizontal\",\n2      override.aes = list(size = 4,\n                          alpha = 1)\n    ) \n  ) +\n3  guides(size = \"none\") +\n  theme(\n    legend.position = \"top\",\n    legend.justification = \"right\",\n4    legend.box.spacing = unit(0.1, \"cm\"),\n5    plot.margin = ggplot2::margin(t = 0.01,\n                                  r = 0.01, \n                                  b = 0.01, \n                                  l = 0.01, \"cm\")\n  )\n\n\n1\n\nбазовый шрифт можно увеличить командой theme_*(base_size = 13);\n\n2\n\nразмер и прозрачность точек на графике по умолчанию соответствует аналогичным элементам в легенде, что не всегда хорошо для легенды, поскольку в этом случае она может быть плохо видна, исправить положение можно, например, командой: guides(color = guide_legend(override.aes = list(size = 4, alpha = 1))), переписав значения для элементов легенды;\n\n3\n\nубирает из легенды элемент, соответствующий размеру точек;\n\n4\n\nрасстояние между легендой и графиком;\n\n5\n\nиногда важно уменьшить поля, сделав полезную площадь графика больше, указав отступы с каждой стороны графика1.\n\n\n\n\n\n\n\n\n\n\nРисунок 4: Преобразованный ggplot2-график\n\n\n\n\n\nНепосредственно в самой библиотеке ggplot2 существует ряд тем, которые хорошо подходят для графиков научных публикаций, например, theme_bw(), theme_classic(), theme_light() или theme_minimal(), достаточно в ggplot2 коде сделать изменение, написав вместо theme_grey() соответствующее название темы.\n\n\nРассмотрим сторонние темы ggplot2. Библиотека hrbrthemes, которую создал Bob Rudis позволяет создавать в R визуально привлекательные графики публикационного качества, его продуманные темы и расширенные настройки типографики упрощают создание визуализаций. Актуальную версию библиотеки можно установить командой\nremotes::install_github(\"hrbrmstr/hrbrthemes\")\nДля применения темы нужно указать тему theme_ipsum() в коде.\n\n\n\n\n\n\n\n\nРисунок 5: Применение темы из библиотеки hrbrthemes\n\n\n\n\n\nБиблиотека содержит множество различных настроек, включая темную тему, вариации шрифтов и отрисовку осей.\n\n\n\nБиблиотека ggpubr(автор Alboukadel Kassambara) помогает исследователям легко создавать графики, готовые к публикации, упрощает изменение графических параметров, позволяет добавлять p-значения и уровни значимости к гистограммам, линейным графикам и т. д. Установить библиотеку можно командами:\ninstall.packages(\"ggpubr\")\ndevtools::install_github(\"kassambara/ggpubr\")\nСледующий график соответствует theme_pubr().\n\n\n\n\n\n\n\n\nРисунок 6: Применение темы из библиотеки ggpubr\n\n\n\n\n\n\n\n\nJulia Silge создала несколько тем, которые (после установки соответствующих шрифтов) можно использовать в графиках. Загрузить библиотеку с темами можно с GitHub:\ndevtools::install_github(\"juliasilge/silgelib\")\nНиже показан пример темы: silgelib::theme_roboto().\n\n\n\n\n\n\n\n\nРисунок 7: Применение темы из библиотеки silgelib\n\n\n\n\n\n\nЕсли рассмотренных тем недостаточно, то множество дополнительных тем можно найти на странице библиотеки ggthemes, например, theme_tufte() на основе стиля, автор которого Edward Tufty или theme_fivethirtyeight().\nБиблиотека ggridges предназначена в первую очередь для построения хребтовых диаграмм (риджлайнов), однако у нее также доступна тема для ggplot2 по команде ggridges::theme_ridges().\nТакже стоит упомянуть темы bbplot из BBC Visual and Data Journalism cookbook for R graphics и ftplottools::ft_theme().\n\n\n\n\nИногда удобно воспользоваться библиотекой ggdirectlabel, которая служит для упрощения нанесения условных обозначений в ggplot2, перенося их внутрь диаграммы вместо отдельной легенды. На рисунке показан пример замены легенды на упрощенный вариант. В нашем случае использовалась команда, которую необходимо добавить в код для ggplot2-графика:\n+ geom_richlegend(aes(label = species, color = species))\n\n\n\n\n\n\n\n\nРисунок 8: Пример упрощения легенды с помощью библиотеки ggdirectlabel\n\n\n\n\n\n\n\n\nЕсть достаточно простой и быстрый способ посмотреть всевозможные темы для исходного графика (например, мы ничего не сказали выше про темные темы), сделав в некотором роде примерку. Для этого можно использовать библиотеку ggautothemes, которая покажет как выглядят свыше 30 различных тем в применении к исходному графику.\nlibrary(ggautothemes)\nПусть gg_base – исходный график, тогда можно сформировать набор графиков с различными темами по исходному следующим образом:\n# формирование графиков с темами по исходному\nautoallthemes(gg_base)\n\n\n\nИспользование theme_set() позволяет избежать репликации написания кода для установки темы, полностью переписывая текущую тему. Можно одним приемом задать тему для всех графиков в документе, например:\ntheme_set(\n  # стартовая тема\n  ggplot2::theme_classic() +\n  # элементы устанавливаемой темы\n  theme(\n    legend.text = element_text(size = 12),\n    axis.title.x = element_text(size = 11),\n    axis.title.y = element_text(size = 11),\n    legend.position = \"top\",\n    legend.justification = \"right\",\n    legend.box.spacing = unit(0.1, \"cm\"),\n    plot.margin = ggplot2::margin(t = 0.01, \n                                  r = 0.01, \n                                  b = 0.01, \n                                  l = 0.01, \"cm\")\n  )\nДля любой темы можно получить элемент темы, используя [[. Затем можно использовать оператор %+replace% для замены определенных элементов темы на необходимые. Например, пусть мы хотим применить к исходному графику gg_base тему theme_ipsum() из библиотеки hrbrthemes везде, кроме текста значений по осям:\n\ngg_base +\n  hrbrthemes::theme_ipsum(grid = \"XY\", \n                          base_size = 14) %+replace% \n  theme(axis.title = ggthemes::theme_gdocs()[[\"axis.title\"]],\n        axis.title.x = ggthemes::theme_gdocs()[[\"axis.title.x\"]],\n        axis.title.y = ggthemes::theme_gdocs()[[\"axis.title.y\"]],\n        legend.position = \"none\") +\n  NULL\n\n\n\n\n\n\n\nРисунок 9: Пример замены элементов темы\n\n\n\n\n\nОтметим, что код выше заканчивается + NULL, это удобно в случае отладки графика, когда будут еще добавляться строки в код."
  },
  {
    "objectID": "blog/posts/2024-01-26 ggplot2/index.html#комбинирование-графиков",
    "href": "blog/posts/2024-01-26 ggplot2/index.html#комбинирование-графиков",
    "title": "Приемы работы и секреты ggplot2",
    "section": "",
    "text": "Для того, чтобы комбинировать графики в ggplot2 можно воспользоваться библиотекой patchwork. Здесь алгебра комбинирования довольно простая: например, если даны графики p1, p2, то p1 | p2 разместит графики рядом друг с другом, p1 / p2 разместит их друг над другом и т.д.\nОдин из интересных приемов, чтобы собрать графики предложил June Choe.\n\n\n\n\n\n\nПредложенный подход основан на использовании I() (AsIs variables) и работает только с ggplot2 версии 3.5.0 и выше.\n\n\n\n\nlibrary(patchwork)\n\nx &lt;- 1:100\ny &lt;- x^2  \ndf_combine &lt;- data.frame(x, y)\n\np &lt;- ggplot(df_combine, aes(x, y)) +\n  geom_line() +\n  theme_grey(base_size = 14)\n\n\n\nКод: функция комбинирования графиков\nannotate_broken_axis &lt;- function(pos, size = 0.03){\n  mid &lt;- switch(\n    pos,\n    \"bl\" = list(x = 0, y = 0),\n    \"br\" = list(x = 1, y = 0),\n    \"tl\" = list(x = 0, y = 1),\n    \"tr\" = list(x = 1, y = 1)\n  )\n  slash &lt;- annotate(\n    \"segment\",\n    x = I(mid$x - size), xend = I(mid$x + size),\n    y = I(-size), yend = I(size)\n  )\n  list(slash, coord_cartesian(clip = \"off\"))\n}\n\n\n\nscale_mark &lt;- \nscale_y_continuous(labels = function(x) format(x, big.mark = \" \",\n                                                 scientific = FALSE)) \n\np1 &lt;- p +\n  scale_x_continuous(limits = c(1, 70)) +\n  annotate_broken_axis(pos = \"br\") +\n  scale_mark\n\np2 &lt;- p +\n  scale_x_continuous(limits = c(80, 100)) +\n  annotate_broken_axis(pos = \"bl\") +\n  scale_mark\n\np1 + p2 +\n  plot_layout(axis = \"collect\") &\n  theme(axis.line.x = element_line())\n\n\n\n\n\n\n\nРисунок 10: Пример комбинирования графиков\n\n\n\n\n\nВ коде выше функция внутри scale_y_continuous(...) позволяет сделать пробелы-разделители для разрядов тысяч."
  },
  {
    "objectID": "blog/posts/2024-01-26 ggplot2/index.html#надграфики",
    "href": "blog/posts/2024-01-26 ggplot2/index.html#надграфики",
    "title": "Приемы работы и секреты ggplot2",
    "section": "",
    "text": "Одна из возможностей добавления дополнительной графической информации к графику – построение надграфиков аналогично панелированию, что можно сделать, например, в библиотеке ggside.\n\n\nКод: базовый график для надстройки\ngg_side_plot &lt;- \n  penguins |&gt; \n  na.omit() |&gt; \n  ggplot(aes(x = bill_length_mm,\n             y = bill_depth_mm,\n             fill = species)) + \n  geom_point(pch = 21,\n             size = 4,\n             color = \"white\", \n             alpha = 0.8) +\n  theme_grey(base_size = 13) +\n  scale_fill_manual(\n    values = c(\"#0072B2\", \n               \"#D55E00\", \n               \"#018571\")\n  ) +\n  scale_x_continuous(name = \"Длина клюва\",\n                     labels = function(x) str_c(x, \" мм\")) +\n  scale_y_continuous(name = \"Высота клюва\",\n                     labels = function(x) str_c(x, \" мм\")) +\n  theme(\n    legend.position = \"none\",\n    plot.margin = ggplot2::margin(t = 0.01,\n                                  r = 0.01, \n                                  b = 0.01, \n                                  l = 0.01, \"cm\")\n  )\n\n\nВсе геометрии, поддерживаемые ggside имеют шаблон geom_xside* или geom_yside* и добавляются в качестве дополнительного слоя в ggplot2-график как обычно.\n\nlibrary(ggside)\n\ngg_side_plot +\n  geom_xsideboxplot(aes(y = species), \n                    orientation = \"y\",\n                    alpha = 0.8) +\n  geom_ysidedensity(aes(x = after_stat(density)), \n                    position = \"identity\",\n                    alpha = 0.8) +\n  scale_ysidex_continuous(guide = guide_axis(angle = 90), \n                          minor_breaks = NULL) +\n  theme(ggside.panel.scale = 0.3)\n\n\n\n\n\n\n\nРисунок 11: Пример добавления дополнительного информационного слоя"
  },
  {
    "objectID": "blog/posts/2024-01-26 ggplot2/index.html#функциональное-использование-эстетики",
    "href": "blog/posts/2024-01-26 ggplot2/index.html#функциональное-использование-эстетики",
    "title": "Приемы работы и секреты ggplot2",
    "section": "Функциональное использование эстетики",
    "text": "Функциональное использование эстетики\nПусть нам требуется сделать цвет/заполнение (color/fill) светлее/темнее относительно друг друга. Для сопоставления данных, преобразованных в статистику, необходимо использовать функцию after_stat(), а для косвенного использования aes() – оператор «бэнг-бэнг-бэнг» !!! как в статье ggplot tricks, которую написал Teun van den Brand.\nПусть прозрачность заполнения точек должна быть меньше и составляет 0.3 от основной яркости границы.\n\nmy_fill_light &lt;- aes(fill = after_scale(alpha(colour, 0.3)))\n\n\n\nКод: базовый график\ngg_base_aes &lt;- penguins |&gt; \n  na.omit() |&gt;\n  ggplot(aes(x = bill_length_mm,\n             y = bill_depth_mm,\n             size = body_mass_g)) +\n  scale_x_continuous(name = \"Длина клюва\",\n                     labels = function(x) str_c(x, \" мм\")) +\n  scale_y_continuous(name = \"Высота клюва\",\n                     labels = function(x) str_c(x, \" мм\")) +\n  theme_classic(base_size = 14) +\n  scale_color_manual(\n    values = c(male = \"#0072B2\", \n               female = \"#D55E00\"),\n    breaks = c(\"male\", \"female\"),\n    labels = c(\"муж\", \"жен\"),\n    name = NULL,\n    guide = guide_legend(\n      direction = \"horizontal\",\n      override.aes = list(size = 4,\n                                 alpha = 1)\n    ) \n  ) +\n  guides(size = \"none\") +\n  theme(\n    axis.line = element_line(),\n    panel.background = element_rect(fill = \"white\"),\n    panel.grid.major = element_line(\"grey90\", \n                                    linewidth = 0.3),\n    legend.key = element_rect(fill = NA),\n    legend.position = \"top\",\n    legend.justification = \"right\",\n    legend.box.spacing = unit(0.1, \"cm\"),\n    plot.margin = ggplot2::margin(t = 0.5,\n                                  r = 0.5, \n                                  b = 0.5, \n                                  l = 0.5, \"cm\")\n  )\n\n\n\nlibrary(rlang)\n\ngg_base_aes +\n  geom_point(aes(colour = factor(sex), \n                 !!!my_fill_light), shape = 21)\n\n\n\n\n\n\n\nРисунок 12: Пример относительного сопоставления цвета"
  },
  {
    "objectID": "blog/posts/2024-01-26 ggplot2/index.html#автоматизация",
    "href": "blog/posts/2024-01-26 ggplot2/index.html#автоматизация",
    "title": "Приемы работы и секреты ggplot2",
    "section": "Автоматизация",
    "text": "Автоматизация\nЕсли требуется сделать несколько однотипных графиков, то один из способов автоматизции рутинных действий – использование функциональных возможностей ggplot2. Например, функция может использовать {{ }} и выглядеть как ниже, если известно, что col – имя столбца:\nfunction(df, col) {\n  ggplot(df) + \n    geom_*(aes(x = {{ col }}))\n}\nПриведем пример функции, которая формирует столбиковую диаграмму для отображения связи между числовой и категориальной переменной. Заполнение будет происходить с помощью градиента, данная возможность появилась в ggplot2 версии 3.5.0 и выше.\n\n# формирование градиента\nlibrary(grid)\nturbo_colors &lt;- scales::viridis_pal(option = \"inferno\")(10)\ngrad_colors &lt;- linearGradient(turbo_colors, \n                              group = TRUE)\n\n\n\nКод: пример функции для однотипных графиков\nbarplot_fun &lt;- function(data, x) {\n  ggplot(data, \n         aes(x = {{ x }})) +\n    geom_bar(fill = grad_colors, color = \"white\") +\n    scale_y_continuous(name = \"Количество\", \n                       labels = function(x) format(x, big.mark = \" \",\n                                                   scientific = FALSE)) +\n  hrbrthemes::theme_ipsum(grid = \"Y\") +\n    theme(\n      axis.line = element_line(),\n      axis.title.x = element_text(size = 12),\n      axis.title.y = element_text(size = 12),\n      panel.grid.major = element_line(\"grey90\", \n                                      linewidth = 0.3),\n      plot.margin = ggplot2::margin(t = 0.1,\n                                    r = 0.1, \n                                    b = 0.1, \n                                    l = 0.1, \"cm\")\n    )\n  \n}\n\n\n\nlibrary(patchwork)\n\nbarplot1 &lt;- barplot_fun(diamonds, cut)\nbarplot2 &lt;- barplot_fun(mpg, class)\n\nbarplot1 / barplot2\n\n\n\n\n\n\n\nРисунок 13: Пример группы сходных графиков\n\n\n\n\n\nАналогичный результат можно получить, если использовать оператор %+% заполнения или замены набора данных.\n\n\nКод: пример базовой части графика\nbar_chart &lt;- ggplot() +\n  geom_bar(fill = grad_colors, color = \"white\") +\n  scale_y_continuous(name = \"Количество\", \n                     labels = function(x) format(x, big.mark = \" \",\n                                                 scientific = FALSE)) +\n  hrbrthemes::theme_ipsum(grid = \"Y\") +\n  theme(\n    axis.line = element_line(),\n    axis.title.x = element_text(size = 12),\n    axis.title.y = element_text(size = 12),\n    panel.grid.major = element_line(\"grey90\", \n                                    linewidth = 0.3),\n    plot.margin = ggplot2::margin(t = 0.1,\n                                  r = 0.1, \n                                  b = 0.1, \n                                  l = 0.1, \"cm\")\n  )\n\n\n\nlibrary(patchwork)\n\nbarchart1 &lt;- bar_chart %+% diamonds + \n  aes(cut)\n\nbarchart2 &lt;- bar_chart %+% mpg + \n  aes(class)\n\nbarchart1 / barchart2\n\n\n\n\n\n\n\nРисунок 14: Пример группы сходных графиков"
  },
  {
    "objectID": "blog/posts/2024-01-26 ggplot2/index.html#итеративные-графики",
    "href": "blog/posts/2024-01-26 ggplot2/index.html#итеративные-графики",
    "title": "Приемы работы и секреты ggplot2",
    "section": "Итеративные графики",
    "text": "Итеративные графики\nЕсли необходимо сделать несколько графиков на основе одних и тех же данных, но с различными переменными, можно написать функцию.\n\n\nКод: функция для итерации графиков\nplot_density &lt;- function(data, var, grp = \"\") {\n  ggplot(data, aes(x = !!sym(var))) +\n    geom_density(aes(fill = !!sym(grp)), \n             position = \"identity\",\n             alpha = 0.7) +\n    scale_x_continuous(labels = function(x) str_c(x, \" мм\")) +\n    silgelib::theme_roboto(base_size = 13) +\n    viridis::scale_fill_viridis(name = NULL,\n                                option = \"plasma\",\n                                direction = -1,\n                                discrete = TRUE) +\n    theme(legend.position = \"top\",\n          plot.margin = ggplot2::margin(t = 0.1,\n                                        r = 0.1, \n                                        b = 0.1, \n                                        l = 0.1, \"cm\"))\n}\n\n\nОтметим, что в функции plot_density мы воспользовались дискретизацией непрерывной палитры через scale_fill_viridis, поскольку заранее неизвестно количество переменных, которые будут участвовать в графике. В частности, построим два графика для переменных bill_length_mm и bill_depth_mm.\n\nplots &lt;- purrr::map(\n  c(\"bill_length_mm\", \"bill_depth_mm\"), \n  ~ plot_density(data = penguins |&gt; na.omit(), \n                 var = .x, grp = \"sex\")\n)\n\n\npatchwork::wrap_plots(plots, nrow = 1)\n\n\n\n\n\n\n\nРисунок 15: Пример создания итеративных графиков с помощью функции"
  },
  {
    "objectID": "blog/posts/2024-01-26 ggplot2/index.html#палитры",
    "href": "blog/posts/2024-01-26 ggplot2/index.html#палитры",
    "title": "Приемы работы и секреты ggplot2",
    "section": "Палитры",
    "text": "Палитры\nЦветовые палитры в визуализации данных должны выявлять различия между количественными данными и обеспечивать максимально удобное восприятие информации.\n\n\n\n\n\n\n\n\nРисунок 16: Типы цветовых палитр\n\n\n\n\n\nОдной из наиболее распространенных палитр для графиков в ggplot2 является viridis (см. Introduction to the viridis color maps). Цвета viridis охватывают максимально широкую палитру, чтобы различия были легко заметны, color blind устойчивы, при этом значения, близкие друг к другу, имеют схожие цвета, а значения, находящиеся далеко друг от друга, имеют больше различий.\n\n\n\n\n\n\n\n\nРисунок 17: Пример дискретной цветовой палитры viridis\n\n\n\n\n\nОсновная палитра называется viridis и дополнена еще несколькими цветовыми гаммами: magma, plasma, inferno, cividis, mako, rocket и turbo. Удобно то, что внутри команды scale_color_viridis() или scale_fill_viridis() можно указать параметр direction = 1 или direction = -1 для того, чтобы указать направление последовательности цветов и discrete = TRUE, если необходима дискретная палитра.\nУниверсальные палитры, которые могут быть полезны при работе в ggplot2, это:\n\nggsci (Scientific Journal and Sci-Fi Themed Color Palettes for ggplot2)\nggokabeito (discrete, colorblind-friendly Okabe-Ito palette)\nscico (Palettes for R based on the Scientific Colour-Maps)\ntidyterra (Gradient palettes in tidyterra)\n\nДополнительные ресурсы для выбора и демонстрации возможностей цветовых палитр:\n\ncolorbrewer2.org\nR Color Palettes 1 + R Color Palettes 2 – палитры на основе библиотеки paletteer\n\nБольше о цветовых возможностях R версии выше 4.0.0 можно почитать в статье Coloring in R’s Blind Spot."
  },
  {
    "objectID": "blog/posts/2024-01-26 ggplot2/index.html#выделение-цветом",
    "href": "blog/posts/2024-01-26 ggplot2/index.html#выделение-цветом",
    "title": "Приемы работы и секреты ggplot2",
    "section": "Выделение цветом",
    "text": "Выделение цветом\nПредположим, что необходимо показать все множество значений и на фоне общего множества выделить вклад каждого подмножества. Удобно сделать это с помощью цвета может помочь библиотека gghighlight.\n\n\nКод: базовый график\ngg_highlight &lt;- \npenguins |&gt; \n  na.omit() |&gt;\n  ggplot(aes(x = flipper_length_mm, \n             fill = species)) + \n  geom_bar() +\n  silgelib::theme_roboto(base_size = 14) +\n  ggsci::scale_fill_nejm(alpha = 0.9) +\n  scale_x_continuous(name = \"Размах плавника\",\n                     labels = function(x) str_c(x, \" мм\")) +\n  labs(y = \"количество\") +\n  theme(\n    axis.line = element_line(),\n    panel.grid.major = element_line(\"grey95\", \n                                    linewidth = 0.3),\n    plot.margin = ggplot2::margin(t = 0.5,\n                                  r = 0.5, \n                                  b = 0.5, \n                                  l = 0.5, \"cm\")\n  )\n\n\n\ngg_highlight\n\n\n\n\n\n\n\nРисунок 18: Базовый график\n\n\n\n\n\n\nlibrary(gghighlight)\n\ngg_highlight +\n  gghighlight() +\n  facet_wrap(~species)\n\n\n\n\n\n\n\nРисунок 19: Выделение цветом подмножеств с помощью библиотеки gghighlight"
  },
  {
    "objectID": "blog/posts/2024-01-26 ggplot2/index.html#изменение-шкалы",
    "href": "blog/posts/2024-01-26 ggplot2/index.html#изменение-шкалы",
    "title": "Приемы работы и секреты ggplot2",
    "section": "Изменение шкалы",
    "text": "Изменение шкалы\nВ качестве исходных данных выберем North Carolina SIDS data. Пусть цвет соостветствует площади полигонов графств в градусных единицах, а выделенная область – округ Франклин, Северная Каролина, США.\n\nnc &lt;- sf::st_read(system.file(\"shape/nc.shp\", package = \"sf\"), \n                  quiet = TRUE)\n\n\n\nКод: исходная карта\ngg_map &lt;- ggplot(nc) +\n  geom_sf(aes(fill = AREA),\n          color = \"black\",\n          linewidth = 0.2) +\n  labs(fill = \"площадь\") +\n  hrbrthemes::theme_ipsum() +\n  guides(fill = guide_colorbar(title.position = \"top\", \n                                title.hjust = 0.5,\n                                barwidth = unit(20, \"lines\"), \n                                barheight = unit(0.7, \"lines\"))) +\n  theme(legend.position = \"top\",\n        legend.text = element_text(size = 12),\n        legend.title = element_text(size = 14),\n        plot.margin = ggplot2::margin(t = 0.01,\n                                      r = 0.01, \n                                      b = 0.01, \n                                      l = 0.01, \"cm\"))\n                                      \ngg_map\n\n\n\n\n\n\n\n\n\nДля карты можно выбрать палитру с помощью библиотеки paletteer из набора. Это можно сделать, добавив в код графка\n+ paletteer::scale_fill_paletteer_*(\"ggthemes::palette_name\", \n                                    direction = -1)\nПри этом обязательно нужно указать направление цвета direction = 1 или direction = -1. Например, для интервальной шкалы можно выбрать среднюю точку с помощью команды rescaler = ~ rescale_mid(.x, mid = mid_point_value). Пусть цвета соответствуют шкале ggthemes::Classic Orange-Blue, а центр цветовой палитры соответствует значению 0.2.\n\nlibrary(paletteer)\n\ngg_map +\n  scale_fill_paletteer_c(\"ggthemes::Classic Orange-Blue\", \n                         direction = -1,\n                         rescaler = ~ rescale_mid(.x, mid = 0.20)\n  )\n\n\n\n\n\n\n\nРисунок 20: Пример центрирования цветовой шкалы\n\n\n\n\n\nСредние значения для центрирования цвета можно программировать, например, выбирать медиану или центрировать, используя долю, как показано ниже. Для этого выделим среднее значение по показателю, которое равно 0.12.\n\ngg_map +\n  paletteer::scale_fill_paletteer_c(\"ggthemes::Classic Orange-Blue\", \n                                    direction = -1,\n                                    limits = ~ c(0, 1) * max(abs(.x))\n  )\n\n\n\n\n\n\n\nРисунок 21: Пример выделения среднего значения цвета в цветовой шкале"
  },
  {
    "objectID": "blog/posts/2024-01-26 ggplot2/index.html#аннотирование",
    "href": "blog/posts/2024-01-26 ggplot2/index.html#аннотирование",
    "title": "Приемы работы и секреты ggplot2",
    "section": "Аннотирование",
    "text": "Аннотирование\nБиблиотека ggforce предоставляет множество замечательных инструментов для работы с графикой ggplot2. В частности, можно делать аннотации к группам на графике, выделив области и снабдив их сносками.\n\n\nКод: график для аннотирования\n\n\npenguins_without_na &lt;- penguins |&gt; na.omit()\n\n# исходный график\ngg_penguins &lt;- \n  penguins_without_na |&gt; \n  ggplot(aes(x = bill_length_mm,\n             y = bill_depth_mm,\n             fill = species,\n             size = body_mass_g)) + \n  geom_point(pch = 21,\n             color = \"white\", \n             alpha = 0.7)\n\n# модифицированный график\ngg_plot &lt;- gg_penguins +\n  silgelib::theme_roboto(base_size = 14) +\n  scale_fill_manual(\n    values = c(Adelie = \"#0072B2\", \n               Chinstrap = \"#D55E00\", \n               Gentoo = \"#018571\"),\n    name = NULL,\n    guide = guide_legend(\n      direction = \"horizontal\",\n      override.aes = list(size = 4,\n                          alpha = 1)\n    ) \n  ) +\n  guides(size = \"none\") +\n  theme(\n    legend.position = \"top\",\n    legend.justification = \"right\",\n    legend.box.spacing = unit(0.1, \"cm\"),\n    legend.text = element_text(size = 13),\n    plot.margin = ggplot2::margin(t = 0.5,\n                                  r = 0.5, \n                                  b = 0.5, \n                                  l = 0.5, \"cm\")\n  ) +\n  labs(x = \"Длина клюва (мм)\",\n       y = \"Высота клюва (мм)\") +\n  xlim(min(penguins_without_na$bill_length_mm) - 5, \n       max(penguins_without_na$bill_length_mm) + 5) +\n  ylim(min(penguins_without_na$bill_depth_mm) - 2, \n       max(penguins_without_na$bill_depth_mm) + 2)\n\n\n\nlibrary(ggforce)\n\ngg_plot + \n  geom_mark_ellipse(aes(label = species),\n                    linewidth = 0.5,\n                    show.legend = FALSE)\n\n\n\n\n\n\n\nРисунок 22: Пример выделения областей в библиотеке ggforce"
  },
  {
    "objectID": "blog/posts/2024-01-26 ggplot2/index.html#текст-внутри-графика",
    "href": "blog/posts/2024-01-26 ggplot2/index.html#текст-внутри-графика",
    "title": "Приемы работы и секреты ggplot2",
    "section": "Текст внутри графика",
    "text": "Текст внутри графика\nВ график ggplot2 можно добавить практически любой markdown-текст для HTML-аннотирования, например, курсив или полужирный текст, а также использовать выделение цветом с применением библиотеки ggtext.\n\n\nКод: пример дополнительного текста в элементах темы\nlibrary(ggtext)\nlibrary(glue)\n\ngg_plot + \n  geom_mark_ellipse(aes(label = species),\n                    linewidth = 0.5,\n                    show.legend = FALSE) +\n  labs(\n    title = \"&lt;b&gt;Пингвины Палмера&lt;/b&gt;&lt;br&gt;\n    &lt;span style = 'font-size:10pt; color:grey'&gt;Набор данных &lt;span style = 'color:black;'&gt;palmerpenguins&lt;/span&gt; для исследования \n    и визуализации данных был собран участником **Long Term Ecological Research Network** -- &lt;span style = 'color:black;'&gt;Dr. Kristen Gorman&lt;/span&gt; со станции \n    **Palmer Station, Antarctica LTER** и далее обобщен авторами: \n    &lt;span style = 'color:black;'&gt;Allison Horst&lt;/span&gt;, \n    &lt;span style = 'color:black;'&gt;Alison Hill&lt;/span&gt;, \n    &lt;span style = 'color:black;'&gt;Kristen Gorman&lt;/span&gt;.\n    Данные включают в себя три вида пингвинов: \n    &lt;span style = 'color:#0072B2;'&gt;Adelie&lt;/span&gt;, \n    &lt;span style = 'color:#D55E00;'&gt;Chinstrap&lt;/span&gt; и \n    &lt;span style = 'color:#018571;'&gt;Gentoo&lt;/span&gt;.&lt;/span&gt;\"\n  ) +\n  theme(\n    plot.title.position = \"plot\",\n    plot.title = element_textbox_simple(\n      size = 14,\n      lineheight = 1,\n      padding = margin(5.5, 5.5, 5.5, 5.5),\n      margin = margin(0, 0, 5.5, 0)\n    )\n  )\n\n\n\n\n\n\n\n\nРисунок 23: Пример дополнительного текста в элементах темы"
  },
  {
    "objectID": "blog/posts/2024-01-26 ggplot2/index.html#увеличение-части-графика",
    "href": "blog/posts/2024-01-26 ggplot2/index.html#увеличение-части-графика",
    "title": "Приемы работы и секреты ggplot2",
    "section": "Увеличение части графика",
    "text": "Увеличение части графика\nВ ggplot2 можно увеличить часть графика, причем осуществить “зуммирование” можно несколькими способами.\n\nЗуммирование в библиотеке ggforce\nПриведем пример увеличения части графика с помощью уже упомянутой библиотеки ggforce. Данное преобразование полезно, если требуется детально показать часть графика.\n\n\nКод: исходный график\n# исходный график\ngg_for_scale &lt;- penguins |&gt; \n  na.omit() |&gt; \n  ggplot(aes(x = bill_length_mm,\n             y = bill_depth_mm,\n             fill = species,\n             size = body_mass_g)) + \n  geom_point(pch = 21,\n             color = \"white\", \n             alpha = 0.7) +\n  theme_bw(base_size = 13) +\n  scale_fill_manual(\n    values = c(Adelie = \"#0072B2\", \n               Chinstrap = \"#D55E00\", \n               Gentoo = \"#018571\"),\n    name = NULL,\n    guide = guide_legend(\n      direction = \"horizontal\",\n      override.aes = list(size = 4,\n                          alpha = 1)\n    ) \n  ) +\n  guides(size = \"none\") +\n  theme(\n    legend.position = \"top\",\n    legend.justification = \"right\",\n    legend.box.spacing = unit(0.1, \"cm\"),\n    legend.text = element_text(size = 13),\n    plot.margin = ggplot2::margin(t = 0.5,\n                                  r = 0.5, \n                                  b = 0.5, \n                                  l = 0.5, \"cm\")\n  ) +\n  labs(x = \"Длина клюва\",\n       y = \"Высота клюва\") +\n  scale_x_continuous(name = \"Длина клюва\",\n                     labels = function(x) str_c(x, \" мм\")) +\n  scale_y_continuous(name = \"Высота клюва\",\n                     labels = function(x) str_c(x, \" мм\"))\n\n\nЗуммирование части графика.\n\ngg_for_scale + facet_zoom(xlim = c(40, 45), \n                          show.area = TRUE)\n\n\n\n\n\n\n\nРисунок 24: Пример увеличения части графика в библиотеке ggforce\n\n\n\n\n\nПриведем еще один пример зуммирования, здесь выделение происходит по определенной переменной.\n\ngg_for_scale + facet_zoom(xy = species == \"Chinstrap\", \n                          split = TRUE)\n\n\n\n\n\n\n\nРисунок 25: Пример увеличения части графика в библиотеке ggforce\n\n\n\n\n\n\n\nЗуммирование в библиотеке ggmagnify\nСледующая возможность для зуммирования – использование библиотеки ggmagnify, которую можно загрузить как\nremotes::install_github(\"hughjonesd/ggmagnify\")\nПокажем увеличение объектов на основе географической карты.\n\n\nКод: исходная карта\nnc_Franklin &lt;- nc |&gt; filter(NAME == \"Franklin\")\n\ngg_map_Franklin &lt;- gg_map +\n  geom_sf(data = nc_Franklin,\n          fill = \"#BF0A30\") +\n  geom_sf_label(data = nc_Franklin,\n                aes(label = NAME), \n                nudge_x = 0.06, \n                nudge_y = 0.35,\n                alpha = 0.9) +\n  labs(x = \"\", y = \"\") + \n  tidyterra::scale_fill_whitebox_c(na.value = \"gray80\", \n                        palette = \"deep\")\n\n\n\ngg_map_Franklin\n\n\n\n\n\n\n\nРисунок 26: Исходная карта\n\n\n\n\n\nУвеличим необходимый объект.\n\n\nКод: зуммирование в библиотеке ggmagnify\nlibrary(ggmagnify)\n\ngg_map_Franklin + \n  geom_magnify(aes(from = NAME == \"Franklin\"),\n               to = c(-83, -81, 34, 35.8), \n               shadow = TRUE, \n               linewidth = 0.6, \n               colour = \"grey20\",\n               shape = \"rect\", \n               aspect = \"fixed\",\n               alpha = 0.8,\n               expand = 0) + \n  tidyterra::scale_fill_whitebox_c(na.value = \"gray80\", \n                        palette = \"deep\")\n\n\n\n\n\n\n\n\nРисунок 27: Увеличение объекта в библиотеке ggmagnify\n\n\n\n\n\n\n\nЗуммирование в библиотеке ggmapinset\nЕще одна возможность для зуммирования – библиотека ggmapinset. Заполнение выносимой области происходит с помощью глаголов-команд, которые заканчиваются на *_inset. Здесь можно указать единицы измерения (например, км) для радиуса области, которую необходимо увеличить.\n\n\nКод: зуммирование в библиотеке ggmapinset\nlibrary(ggmapinset)\n\ngg_map +\n  geom_sf_inset(aes(fill = AREA),\n                color = \"black\",\n                linewidth = 0.2) +\n  geom_sf_inset(data = nc_Franklin,\n                fill = \"#BF0A30\") +\n  geom_inset_frame() +\n  geom_sf_label(data = nc_Franklin,\n                aes(label = NAME), \n                nudge_x = 0.06, \n                nudge_y = 0.35,\n                alpha = 0.9) +\n  coord_sf_inset(inset = \n                   configure_inset(\n                     centre = sf::st_centroid(sf::st_geometry(nc_Franklin)), \n                     scale = 2.2,\n                     translation = c(-300, -200), \n                     radius = 40, \n                     units = \"km\"\n                   )) +\n  labs(x = \"\", y = \"\") + \n  tidyterra::scale_fill_whitebox_c(na.value = \"gray80\", \n                        palette = \"deep\")\n\n\n\n\n\n\n\n\nРисунок 28: Увеличение объекта в библиотеке ggmapinset"
  },
  {
    "objectID": "blog/posts/2024-01-26 ggplot2/index.html#добавление-эффектов",
    "href": "blog/posts/2024-01-26 ggplot2/index.html#добавление-эффектов",
    "title": "Приемы работы и секреты ggplot2",
    "section": "Добавление эффектов",
    "text": "Добавление эффектов\nОдин из способов усиления восприятия и добавления различных эффектов в визуализации – работа с фильтрами и шейдерами на слоях ggplot2 в библиотеке ggfx. Например, можно добавить тени к исходному графику.\n\n\nКод: добавление эффектов к графику\nlibrary(ggfx)\n\ngg_map +\n  with_shadow(\n    sigma = 3, x_offset = 4, y_offset = 4,\n    geom_sf(data = nc, \n            aes(fill = AREA), \n            color = \"black\")\n  ) + \n  tidyterra::scale_fill_whitebox_c(na.value = \"gray80\", \n                        palette = \"deep\")\n\n\n\n\n\n\n\n\nРисунок 29: Пример создания тени в библиотеке ggfx"
  },
  {
    "objectID": "blog/posts/2024-01-26 ggplot2/index.html#статистические-графики",
    "href": "blog/posts/2024-01-26 ggplot2/index.html#статистические-графики",
    "title": "Приемы работы и секреты ggplot2",
    "section": "Статистические графики",
    "text": "Статистические графики\nЕсли в научном исследовании необходимо создать графики с деталями статистических тестов, то можно воспользоваться расширением ggstatsplot. Основная идея ggstatsplot состоит в том, чтобы объединить графическую составляющую со статистическими свойствами. Здесь количество исследуемых показателей довольно внушительное и позволяет качественно построить рабочий процесс. Приведем пример такого графика.\n\nset.seed(2024)\nlibrary(ggstatsplot)\n\nggbetweenstats(\n  data  = penguins |&gt; na.omit(),\n  x     = species,\n  y     = bill_length_mm\n)\n\n\n\n\n\n\n\nРисунок 30: Пример создания графика на основе статистических данных"
  },
  {
    "objectID": "blog/posts/2024-01-26 ggplot2/index.html#включение-результатов-моделирования",
    "href": "blog/posts/2024-01-26 ggplot2/index.html#включение-результатов-моделирования",
    "title": "Приемы работы и секреты ggplot2",
    "section": "Включение результатов моделирования",
    "text": "Включение результатов моделирования\nС помощью ggplot2 можно публиковать результаты моделирования временных рядов, результаты моделирования машинного обучения, регрессионных моделей в библиотеке broom и т.д. Как правило, для отрисовки определенного графика, для объекта некоторого класса используют команду autoplot(). Пусть требуется классифицировать пингвинов в зависимости от размаха плавника и длины клюва.\n\n# библиотека для реализации метода деревьев решений\nlibrary(partykit)\n\n# библиотека для отображения деревьев решений\nlibrary(ggparty)\n\n\n# дерево решений\npenguin_ctree &lt;- ctree(\n  # формула, показывающая зависимости\n  species ~ flipper_length_mm + bill_length_mm,\n  data = penguins |&gt; na.omit()\n)\n\n\nautoplot(penguin_ctree) + \n  theme_void()\n\n\n\n\n\n\n\nРисунок 31: Пример визуализации классификации с помощью деревьев решений\n\n\n\n\n\nПокажем, как можно на графике визуализировать результаты моделирования простейших деревьев решений в библиотеке parttree. Библиотека работает с деревьями решений, созданными в rpart, partykit, tidymodels и mlr3.\nПусть gg_for_tree – исходный график.\n\n\nКод: график для визуализации деревьев решений\n\ngg_for_tree &lt;- penguins |&gt; \n  na.omit() |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = bill_length_mm,\n             fill = species)) + \n  geom_point(pch = 21,\n             size = 3,\n             color = \"white\", \n             alpha = 0.7) +\n  scale_x_continuous(name = \"\\nРазмах плавника\",\n                     labels = function(x) str_c(x, \" мм\")) +\n  scale_y_continuous(name = \"Длина клюва\\n\",\n                     labels = function(x) str_c(x, \" мм\")) +\n  scale_fill_manual(\n    values = c(Adelie = \"#0072B2\", \n               Chinstrap = \"#D55E00\", \n               Gentoo = \"#018571\"),\n    breaks = c(\"Adelie\", \"Chinstrap\", \"Gentoo\"),\n    labels = c(\"Adelie\", \"Chinstrap\", \"Gentoo\"),\n    name = NULL,\n    guide = guide_legend(\n      direction = \"horizontal\",\n      override.aes = list(size = 4, \n                          alpha = 1)\n    ) \n  ) +\n   hrbrthemes::theme_ipsum(grid = \"\",\n                          base_size = 14) +\n  theme(\n    legend.text = element_text(size = 13),\n    axis.title.x = element_text(size = 12),\n    axis.title.y = element_text(size = 12),\n    legend.position = \"top\",\n    legend.justification = \"right\",\n    legend.box.spacing = unit(0.1, \"cm\"),\n    plot.margin = ggplot2::margin(t=0.5, \n                                  r=0.5, \n                                  b=0.5, \n                                  l=0.5, \"cm\") \n  )\n\nОтобразим результат классификации в модели penguin_ctree, полученной выше, с помощью разделения областей графика.\n\n# визуализирует подгонку деревьев решений\nlibrary(parttree)\n\n\ngg_for_tree +\n  geom_parttree(data = penguin_ctree, \n                aes(fill = species), \n                alpha = 0.2)\n\n\n\n\n\n\n\nРисунок 32: Пример визуализация классификации результата моделирования с помощью библиотеки parttree"
  },
  {
    "objectID": "blog/posts/2024-01-26 ggplot2/index.html#footnotes",
    "href": "blog/posts/2024-01-26 ggplot2/index.html#footnotes",
    "title": "Приемы работы и секреты ggplot2",
    "section": "Сноски",
    "text": "Сноски\n\n\nЗдесь поля указываются в следующем порядке: t = top, r = right, b = bottom, l = left.↩︎"
  },
  {
    "objectID": "blog/posts/2021-07-20-reactable/index.html#некоторые-особенности-и-возможности-интерактивных-таблиц",
    "href": "blog/posts/2021-07-20-reactable/index.html#некоторые-особенности-и-возможности-интерактивных-таблиц",
    "title": "Интерактивные таблицы средствами языка R",
    "section": "Некоторые особенности и возможности интерактивных таблиц",
    "text": "Некоторые особенности и возможности интерактивных таблиц\nОтметим преимущества интерактивных таблиц.\n\nВозможность интерактивной сортировки значений по столбцам (при необходимости можно указать исходное направление сортировки).\nЖивой поиск, позволяющий выделять только строки с нужными значениями и делать автоматический пересчет итоговых суммарных значений.\nРегулировка количества строк на странице и диапазона значений.\nГруппировка и агрегирование строк с автоматическим выделением границ группы.\nВозможность условного форматирования: выделение шрифтом и цветом значений на основе условных критериев, построения тепловых карт и т.д.\nИспользование JavaScript для улучшения стилизации и внедрение HTML-виджетов в таблицы.\nИспользование CSS-стилей.\nБогатые возможности для локализации.\nИнтегрирование с Shiny (интерактивной средой для создания веб-приложений и дэшбордов) и Leaflet (библиотекой предназначенной для отображения интерактивных карт на веб-сайтах).\n\nВ перспективе планируется интеграция с WebR."
  },
  {
    "objectID": "blog/posts/2021-07-20-reactable/index.html#базовая-таблица",
    "href": "blog/posts/2021-07-20-reactable/index.html#базовая-таблица",
    "title": "Интерактивные таблицы средствами языка R",
    "section": "Базовая таблица",
    "text": "Базовая таблица\nПусть модельные данные представляют собой упрощенную таблицу, содержащую название региона, федерального округа, данные за определенный период и столбец с некоторыми суммарными значениями.\n\n\nfires_reactable\n\n# A tibble: 85 × 7\n   regions                      FO    `2017` `2018` `2019` `2020` total\n   &lt;chr&gt;                        &lt;chr&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n 1 Еврейская автономная область ДФО       95    109    137     91   431\n 2 Приморский край              ДФО       74     79     98     51   301\n 3 Хабаровский край             ДФО       76     76     89     59   299\n 4 Забайкальский край           ДФО       68     62     95     65   289\n 5 Псковская область            СЗФО      68     63     92     66   289\n 6 Магаданская область          ДФО       75     67     65     58   266\n 7 Амурская область             ДФО       64     77     68     51   261\n 8 Республика Калмыкия          ЮФО       58     66     67     65   255\n 9 Орловская область            ЦФО       50     50     58     67   225\n10 Алтайский край               СФО       52     54     62     56   224\n# ℹ 75 more rows\n\n\n\nДля отображения интерактивной таблицы служит команда reactable(). Столбцы такой таблицы можно сортировать нажатием (или кликом) на них.\nreactable(fires_reactable)"
  },
  {
    "objectID": "blog/posts/2021-07-20-reactable/index.html#локализация-таблиц",
    "href": "blog/posts/2021-07-20-reactable/index.html#локализация-таблиц",
    "title": "Интерактивные таблицы средствами языка R",
    "section": "Локализация таблиц",
    "text": "Локализация таблиц\nОдна из ключевых возможностей отличающих reacable это, несомненно, возможность настройки языковых опций таблицы.3\n\n# русификация reactable таблиц\noptions(reactable.language = reactableLang(\n  pageSizeOptions   = \"показано {rows} значений\",\n  pageInfo          = \"Диапазон: с {rowStart} по {rowEnd} из {rows} регионов\",\n  pagePrevious      = \"назад\",\n  pageNext          = \"вперед\",\n  searchPlaceholder = \"Поиск...\",\n  noData            = \"Значения не найдены\"\n))\n\n\n\nПример локализации\n\nreactableLang(\n  sortLabel = \"Сортировать {name}\",\n  filterPlaceholder = \"\",\n  filterLabel = \"Фильтровать {name}\",\n  searchPlaceholder = \"Найти\",\n  searchLabel = \"Найти\",\n  noData = \"Строки не найдены\",\n  pageNext = \"Далее\",\n  pagePrevious = \"Назад\",\n  pageNumbers = \"{page} из {pages}\",\n  pageInfo = \"{rowStart}\\u2013{rowEnd} из {rows} строк\",\n  pageSizeOptions = \"Показать {rows}\",\n  pageNextLabel = \"Следующая страница\",\n  pagePreviousLabel = \"Предыдущая страница\",\n  pageNumberLabel = \"Страница {page}\",\n  pageJumpLabel = \"Перейти на страницу\",\n  pageSizeOptionsLabel = \"Строк на странице\",\n  groupExpandLabel = \"Группировка\",\n  detailsExpandLabel = \"Детальный вид\",\n  selectAllRowsLabel = \"Выбрать все строки\",\n  selectAllSubRowsLabel = \"Выбрать все строки в группе\",\n  selectRowLabel = \"Выбрать строку\",\n  defaultGroupHeader = NULL,\n  detailsCollapseLabel = NULL,\n  deselectAllRowsLabel = NULL,\n  deselectAllSubRowsLabel = NULL,\n  deselectRowLabel = NULL\n)"
  },
  {
    "objectID": "blog/posts/2021-07-20-reactable/index.html#глобальные-настройки-таблицы",
    "href": "blog/posts/2021-07-20-reactable/index.html#глобальные-настройки-таблицы",
    "title": "Интерактивные таблицы средствами языка R",
    "section": "Глобальные настройки таблицы",
    "text": "Глобальные настройки таблицы\nТаблицы в reactable имеют огромное количество разнообразных настроек, причем для более глубокой настройки используется JavaScript. Приведем ниже некоторые возможности на примере.\n\n\n\nКод\nyear_cols &lt;- c(\"2017\", \"2018\", \"2019\", \"2020\")\n\nreactable(fires_reactable,\n          compact = TRUE,\n          columns = list(\n            regions = colDef(minWidth = 280, name = \"Субъект РФ\"),\n            FO = colDef(minWidth = 70, name = \"ФО\"),\n            total = colDef(name = \"Сумма\")\n          ),\n          # группировка и название объединенных столбцов\n          columnGroups = list(\n            colGroup(name = \"Количество пожаров приведенное на 10 000 человек населения\", \n                     columns = year_cols)\n          ),\n          # строка поиска\n          searchable = TRUE,\n          # исходная глобальная сортировка по умолчанию\n          defaultSortOrder = \"desc\",\n          # возможность изменять количество строк на странице\n          showPageSizeOptions = TRUE,\n          # подсветка при наведении на строку\n          highlight = TRUE,\n          # отстутствие границы между строками\n          borderless = TRUE,\n          # на всю ширину / фиксированная ширина\n          fullWidth = TRUE,\n          # столбцы исходной сортировки и направление сортировки столбцов\n          defaultSorted = list(FO = \"asc\"),\n          # исходное количество строк на странице\n          defaultPageSize = 12,\n          # стилизация заголовков столбцов\n          theme = reactableTheme(\n            headerStyle = list(\n              \"&:hover[aria-sort]\" = list(background = \"hsl(0, 0%, 96%)\"),\n              \"&[aria-sort='ascending'], \n               &[aria-sort='descending']\" = list(background = \"hsl(0, 0%, 96%)\"),\n              borderColor = \"#555\"\n            )\n          ),\n          # стилизация: разграничивание между группами при сортировке по ФО\n          rowStyle = JS(\"\n                function(rowInfo, state) {\n                        // игнорирование строк заполнения\n                        if (!rowInfo) return\n                        \n                        // горизонтальные разделители между группами\n                        var firstSorted = state.sorted[0]\n                        if (firstSorted && firstSorted.id === 'FO') {\n                        var nextRow = state.pageRows[rowInfo.viewIndex + 1]\n                        if (nextRow && rowInfo.row['FO'] !== nextRow['FO']) {\n                        // добавление прямоугольной тени, \n                        // чтобы добавить границу 2 пикселя \n                        return { boxShadow: 'inset 0 -2px 0 rgba(0, 0, 0, 0.1)' }\n                        }\n                        }\n                        }\n                        \"),\n          # глобальный стиль: шрифт для подстрочной суммы\n          defaultColDef = colDef(\n            footerStyle = list(fontWeight = \"bold\"), \n          # разделитель для тысяч пробелом\n            format      = colFormat(locales = \"ru-RU\", separators = TRUE))\n         )"
  },
  {
    "objectID": "blog/posts/2021-07-20-reactable/index.html#настройка-столбцов-в-таблицах",
    "href": "blog/posts/2021-07-20-reactable/index.html#настройка-столбцов-в-таблицах",
    "title": "Интерактивные таблицы средствами языка R",
    "section": "Настройка столбцов в таблицах",
    "text": "Настройка столбцов в таблицах\nДля настройки столбцов в reactable-таблицах (например, изменения имени, настройки поиска по столбцу) используется функция colDef(), подробно описанная на соответствующей странице. Приведем простой пример настройки столбцов на базе известного набора данных palmerpenguins.\n\n\n\nКод\nlibrary(palmerpenguins)\n\nreactable(\n  sample_n(penguins |&gt; \n             na.omit() |&gt; \n             dplyr::select(-sex, -year, -island, -body_mass_g), 10),\n  compact = TRUE,\n  columns = list(\n    species = colDef(name = \"Вид\", filterable = TRUE),\n    bill_length_mm = colDef(name = \"Длина клюва (мм)\"),\n    bill_depth_mm  = colDef(name = \"Высота клюва (мм)\"),\n    flipper_length_mm = colDef(name = \"Длина плавника (мм)\")\n  )\n)\n\n\n\n\n\n\n\nВозможности colDef() очень богатые: можно менять выравнивание конкретного столбца, его ширину, указав значение maxWidth, изменить форматирование столбца, добавив CSS-стиль и т.д."
  },
  {
    "objectID": "blog/posts/2021-07-20-reactable/index.html#тепловые-карты",
    "href": "blog/posts/2021-07-20-reactable/index.html#тепловые-карты",
    "title": "Интерактивные таблицы средствами языка R",
    "section": "Тепловые карты",
    "text": "Тепловые карты\nИзвестно, что цвет воспринимается гораздо эффективнее, чем численные значения, поэтому иногда имеет смысл представлять данные в виде так называемых тепловых карт. Для создания тепловой карты необходима сначала определить стиль столбцов.\n\n\nКод: определение стиля столбцов\n# функция цвета\nmake_color_pal &lt;- function(colors, bias = 1) {\n  get_color &lt;- colorRamp(colors, bias = bias)\n  function(x) rgb(get_color(x), maxColorValue = 255)\n}\n\n# наша палитра\ngood_color &lt;- make_color_pal(rev(c(\"#E76254FF\", \"#EF8A47FF\", \"#F7AA58FF\", \"#FFD06FFF\", \"#FFE6B7FF\", \"#AADCE0FF\", \"#72BCD5FF\", \"#528FADFF\", \"#376795FF\", \"#1E466EFF\")), bias = 2)\n\n# максимум и минимум значений в таблице\nmax_val &lt;-\nfires_reactable %&gt;%\n  summarise(across(where(is.numeric), ~ max(.x, na.rm = TRUE)))\nmax_val &lt;- max(max_val |&gt; dplyr::select(-total))\n\nmin_val &lt;-\n  fires_reactable %&gt;%\n  summarise(across(where(is.numeric), ~ min(.x, na.rm = TRUE)))\nmin_val &lt;- min(min_val |&gt; dplyr::select(-total))\n\n# стиль столбца с учетом цвета\nmy_style_fires &lt;- function(value) {\n              if (!is.numeric(value)) return()\n              normalized &lt;- (value - min_val) / (max_val - min_val)\n              color &lt;- good_color(normalized)\n              list(background = color)\n            }\n\n\n\n\n\nКод: таблица\nreactable(\n  fires_reactable |&gt; dplyr::select(-`2017`, -total)  %&gt;% \n  mutate(total = rowSums(.[3:5])),\n  compact = TRUE,\n  columns = list(\n    regions = colDef(name = \"Субъект РФ\",       # заголовок для субъекта РФ\n                              minWidth = 280,\n                              defaultSortOrder = \"asc\"),\n    FO      = colDef(name = \"ФО\",               # заголовок для ФО\n                              align = \"center\", # выравнивание по центру\n                              minWidth = 70,\n                              defaultSortOrder = \"asc\"),\n    total   = colDef(name = \"Сумма\",\n                     defaultSortOrder = \"desc\"),\n    `2018`  = colDef(style = my_style_fires),\n    `2019`  = colDef(style = my_style_fires),\n    `2020`  = colDef(style = my_style_fires)\n  )\n)"
  },
  {
    "objectID": "blog/posts/2021-07-20-reactable/index.html#группировка-ячеек",
    "href": "blog/posts/2021-07-20-reactable/index.html#группировка-ячеек",
    "title": "Интерактивные таблицы средствами языка R",
    "section": "Группировка ячеек",
    "text": "Группировка ячеек\nДля компактного представления больших таблиц имеет смысл делать группировку показателей по выбранной переменной с раскрывающимся списком. В примере ниже группировка сделана по федеральным округам. Кроме того, в такого рода таблице можно показать агрегированные значения, такие как максимум по столбцу, минимум, среднее значение, медиану, количество элементов, уникальные значения и т.д.\n\n\n\nКод\nset.seed(123)\nreactable(fires_reactable |&gt; slice_sample(n = 30), \n          compact = TRUE,\n          groupBy = \"FO\",\n          columns = list(\n          `2017`  = colDef(aggregate = \"count\",\n                           name = \"2017 (кол-во)\"),\n          `2018`  = colDef(aggregate = \"unique\",\n                           name = \"2018 (уник)\"),\n          `2019`  = colDef(aggregate = \"median\",\n                           name = \"2019 (медиан)\"),\n          `2020`  = colDef(show = FALSE),\n          total   = colDef(name = \"Сумма (макс)\", \n                           aggregate = \"max\"),\n          FO      = colDef(name = \"Фед. округ\"),\n          regions = colDef(name = \"Субъект РФ\")\n          )\n)"
  },
  {
    "objectID": "blog/posts/2021-07-20-reactable/index.html#динамический-пересчет-суммы",
    "href": "blog/posts/2021-07-20-reactable/index.html#динамический-пересчет-суммы",
    "title": "Интерактивные таблицы средствами языка R",
    "section": "Динамический пересчет суммы",
    "text": "Динамический пересчет суммы\nБиблиотека reactable путем удачного сочетания с JavaScript позволяет делать таблицы с динамической визуализацией в виде итоговой сноски, например, при наборе фильтрующего значения может происходить автоматический пересчет суммы. Скажем, если в поле поиска таблицы ниже ввести область, то останутся субъекты РФ, соответствующие областям.\n\n\n\nКод\nset.seed(123)\nreactable(\n  compact = TRUE,\n  fires_reactable |&gt; \n  dplyr::select(-FO) |&gt;\n  slice_sample(n = 20),\n  searchable      = TRUE,\n  highlight       = TRUE,\n  borderless      = TRUE,\n  defaultPageSize = 5,\n  theme = reactableTheme(searchInputStyle = list(width = \"100%\")),\n  columns = list(\n    regions = colDef(name     = \"Субъект РФ\",\n                     minWidth = 200,\n                     footer   = \"Всего:\"),\n    total = colDef(name = \"Сумма\",\n      # разделитель для тысяч пробелом\n      format = colFormat(locales = \"ru-RU\", separators = TRUE),\n      # динамический пересчет суммы при поиске\n      footer = JS(\"function(colInfo) {var total = 0\n                                          colInfo.data.forEach(function(row) {\n                                          total += row[colInfo.column.id]\n                                          })\n                                          return total.toLocaleString('ru-RU')\n                                          }\")\n    )\n  ),\n  # глобальный стиль: шрифт для подстрочной суммы\n  defaultColDef = colDef(\n    footerStyle = list(fontWeight = \"bold\"),\n    # разделитель для тысяч пробелом\n    format      = colFormat(locales = \"ru-RU\", separators = TRUE)\n  )\n)"
  },
  {
    "objectID": "blog/posts/2021-07-20-reactable/index.html#условное-форматирование",
    "href": "blog/posts/2021-07-20-reactable/index.html#условное-форматирование",
    "title": "Интерактивные таблицы средствами языка R",
    "section": "Условное форматирование",
    "text": "Условное форматирование\nЗачастую в таблице необходимо отобразить динамику изменения показателя. Для этого удобно применять условное форматирование, например, выделив цветом разности между конечным и исходным значениями и т.д.\n\n\n\nКод\nset.seed(123)\nfires_change &lt;- \nfires_reactable |&gt;\n  mutate(change = `2020` - `2017`) |&gt;\n  select(-c(`2018`:`2019`), \n         -total)\n\nreactable(fires_change |&gt; slice_sample(n = 30), \n          highlight     = TRUE,\n          compact       = TRUE,\n          defaultSorted = list(regions = \"asc\"),\n          columns       = list(\n  regions = colDef(name       = \"Субъект РФ\",\n                     minWidth = 170),\n    FO    = colDef(name       = \"Фед. округ\",      \n                     align    = \"center\", \n                     minWidth = 80),\n  change = colDef(\n    name = \"Динамика\",\n    defaultSortOrder = \"desc\",\n    cell = function(value) {\n      if (value &gt; 0) paste0(\"+\", value) else value\n    },\n    style = function(value) {\n      color &lt;- if (value &gt; 0) {\n        \"#e00000\"\n      } else if (value &lt; 0) {\n        \"#008000\"\n      }\n      list(fontWeight = 600, color = color)\n    }\n  )\n))"
  },
  {
    "objectID": "blog/posts/2021-07-20-reactable/index.html#стилизация-и-форматирование",
    "href": "blog/posts/2021-07-20-reactable/index.html#стилизация-и-форматирование",
    "title": "Интерактивные таблицы средствами языка R",
    "section": "Стилизация и форматирование",
    "text": "Стилизация и форматирование\nДля дополнительных возможностей оптимизации и улучшения стиля и форматирования таблиц, созданных с помощью reactable, можно воспользоваться библиотекой reactablefmtr. В дополнении к огромным возможностям reactable, мы получаем множество средств условного форматирования, интерактивные спарклайны, пользовательские темы таблиц, встраивание изображений в таблицы, использование crosstalk и shiny, темы, и многое другое. Больше примеров можно посмотреть на сайте библиотеки reactablefmtr.\n\n\n\nКод\nlibrary(reactablefmtr)\n\nmy_pal &lt;- viridis::viridis_pal(option = \"plasma\")(10)\n\nfires_reactablefmtr &lt;- fires_reactable |&gt;\n  dplyr::select(-FO, -`2017`, -total) |&gt;\n  arrange(regions) |&gt;\n  head(10)\n\nfires_reactablefmtr &lt;- fires_reactablefmtr %&gt;% \n  mutate(total = rowSums(.[2:4]))\n\nfires_reactablefmtr %&gt;% \n  reactable(\n    theme = fivethirtyeight(),\n    highlight = TRUE,\n    defaultSorted = list(total = \"desc\"),\n    columns = list(\n      regions = colDef(name = \"Субъект РФ\",\n                       minWidth = 170),\n      `2018` = colDef(cell = \n                        color_tiles(., box_shadow = TRUE, \n                                    colors = my_pal)),\n      `2019` = colDef(cell = \n                        color_tiles(., box_shadow = TRUE, \n                                    colors = my_pal)),\n      `2020` = colDef(cell = \n                        color_tiles(., box_shadow = TRUE, \n                                    colors = my_pal)),\n      total = colDef(name = \"Сумма\", \n                     cell = data_bars(., text_position = \"above\"))\n    )\n  ) %&gt;% \n  add_legend(fires_reactablefmtr |&gt;\n               arrange(regions) |&gt;\n               head(10), \n             col_name = \"2018\", \n             title = \"Значения\", \n             align = \"right\", \n             colors = my_pal,\n             footer = \"Данные на 2020 г.\", \n             bins = 5)\n\n\n\n\nЗначения\n\n\n\n\n77\n\n\n\n\n\n50\n\n\n\n\n\n40\n\n\n\n\n\n27\n\n\n\n\n\n12\n\n\n\nДанные на 2020 г.\n\n\n\n\n\nПриведем простой пример использования спарклайнов.\n\n# таблица для отображения\nfires_table_reactable &lt;- \nfires_reactable |&gt;\n  dplyr::select(-total) |&gt;\n  pivot_longer(!c(regions, FO), \n               names_to = \"year\", \n               values_to = \"value\") |&gt;\n  arrange(regions) |&gt;\n  # группировка по необходимым категориям\n  group_by(year) |&gt;\n  summarize(fire_num = list(value))\n\nfires_table_reactable\n\n# A tibble: 4 × 2\n  year  fire_num  \n  &lt;chr&gt; &lt;list&gt;    \n1 2017  &lt;dbl [85]&gt;\n2 2018  &lt;dbl [85]&gt;\n3 2019  &lt;dbl [85]&gt;\n4 2020  &lt;dbl [85]&gt;\n\n\n\n\nКод\n# цвет для sparkline-графиков\nfires_table_reactable &lt;- fires_table_reactable |&gt;\n  mutate(\n    cols = case_when(\n      year == \"2017\" ~ \"#1b9e77\",\n      year == \"2018\" ~ \"#d95f02\",\n      year == \"2019\" ~ \"#7570b3\",\n      year == \"2020\" ~ \"#e7298a\",\n      .default = \"grey\"\n    )\n  )\n\nreactable(\n  fires_table_reactable,\n  defaultPageSize = 4,\n  columns = list(\n    year = colDef(maxWidth = 100,\n                  name = \"Год\"),\n    cols = colDef(show = FALSE),\n    fire_num = colDef(name = \"Приведенное количество пожаров\",\n                      cell = react_sparkbar(\n                        fires_table_reactable,\n                        height = 90,\n                        fill_color_ref = \"cols\",\n                        tooltip_type = 2,\n                        bandline = \"innerquartiles\",\n                        statline = \"mean\"\n                      )\n                      )\n  )\n)"
  },
  {
    "objectID": "blog/posts/2021-07-20-reactable/index.html#footnotes",
    "href": "blog/posts/2021-07-20-reactable/index.html#footnotes",
    "title": "Интерактивные таблицы средствами языка R",
    "section": "Сноски",
    "text": "Сноски\n\n\nЗдесь рассмотрены пожары, учет которых ведется на основании Приказа МЧС России от 24.12.2018 №625 «О формировании электронных баз данных учета пожаров и их последствий» (утратил силу).↩︎\nНормирование по отношению к численности населения производилось на основе статистических данных statdata.ru на 1 января 2021 года. Оценку численности постоянного населения РФ можно также посмотреть на странице ИНИД: Демографическая ситуация по субъектам РФ.↩︎\nНапример, в библиотеке DT русификация делается несколько сложнее, что также описано на странице Stack Overflow.↩︎"
  },
  {
    "objectID": "blog/posts/2024-02-02 rayvista/index.html#базовая-работа-с-3d-моделями",
    "href": "blog/posts/2024-02-02 rayvista/index.html#базовая-работа-с-3d-моделями",
    "title": "Визуализация трехмерных моделей земной поверхности",
    "section": "Базовая работа с 3D-моделями",
    "text": "Базовая работа с 3D-моделями\nСоздадим простейшую 3D-модель. В качестве исходной визуализации выберем модель вершины Амадаблам – вершины в Гималаях, высота главного пика которой равна 6 814 м.\n\n\n\n\n\n\nРисунок 1: Пример 3D-модели в rayvista – вершина Амадаблам\n\n\n\n1Amadablam &lt;- plot_3d_vista(lat = 27.8599,\n                           long = 86.8614, \n2                           zscale = 6,\n3                           zoom = 0.6,\n                           soliddepth = 4000,\n4                           radius = 5000,\n5                           overlay_detail = 14,\n6                           theta = -65, phi = 25,\n7                           windowsize = 1200,\n                           background = \"grey10\")\n\n1\n\nширота и долгота, выраженная в WGS84;\n\n2\n\nпри условии, что x = y, zscale показывает соотношение между x и z (либо y и z), по умолчанию zscale = 2;\n\n3\n\nкоэффициент масштабирования, по умолчанию равен 1;\n\n4\n\nрадиус, определяющий ограничивающую область;\n\n5\n\nчисло между 0 и 20, отвечающее за масштаб в maptiles::get_tiles(), уровни масштабирования можно посмотреть в OpenStreetMap wiki, по умолчанию значение равно 13;\n\n6\n\nугол вращения и азимутальный угол соответственно;\n\n7\n\nположение, ширина и высота устройства RGL, отображающего модель.\n\n\nВ библиотеке rayvista возможно использовать карты-подложки различных провайдеров (например, OpenStreetMap, Esri, CARTO или Thunderforest, также, см. статью по поводу доступности карт Stamen). Все возможные слои показывает команда\n?maptiles::get_tiles \nВ примере ниже покажем различные варианты для визуализации острова Татышев, г. Красноярск.\nKrasnoyarsk &lt;- plot_3d_vista(lat = 56.01986, \n                             long = 92.932413, \n                             zscale = 3, \n                             zoom = 0.5,\n1                             img_provider = \"Thunderforest.Landscape\",\n2                             api_key = \"your_api_key_value\",\n                             overlay_detail = 14,\n                             theta = -40,  \n                             phi = 25,\n                             windowsize = 1300,\n                             soliddepth = 50,\n3                             # outlier_filter = 0.0001,\n4                             fill_holes = TRUE)\n\n1\n\nвид картографической подолжки;\n\n2\n\nзначение API-ключа для Thunderforest-карт, можно получить на сайте, для других карт API-ключ не требуется;\n\n3\n\nесли в модели появляются артефакты, это значит что возвращаемые данные о рельефе имеют ошибочно низкие значения, тогда нужно выставить значение от 0 до 1, ближе к 0;\n\n4\n\nзаполняет значения NA полученные в цифровой модели рельефа местности.\n\n\n\n\n\n\n\n\nРисунок 2: Пример 3D-модели с картой Thunderforest.Landscape, где показаны топографические особенности\n\n\n\nОтметим, что если в предыдущем коде, который формирует 3D-изображение, добавить show_vista = FALSE (в команде plot_3d_vista()), то мы не увидим RGL-окно, а сохраним объект, у которого будут атрибуты dem_matrix и texture. Теперь восстановить изображение на рисунке (см. рис. 2) можно так:\nKrasnoyarsk$dem_matrix |&gt;\n  height_shade() %&gt;% \n  add_overlay(., Krasnoyarsk$texture,\n              rescale_original = TRUE) %&gt;%\n  plot_3d(., Krasnoyarsk$dem_matrix, zscale = 3,\n          windowsize = 1300, \n          soliddepth = 50,\n          zoom = 0.5, phi = 25, theta = -40)\nСравним предыдущую карту с другими картами-подложками.\n\n\n\n\n\n\nРисунок 3: Пример 3D-модели с картой Thunderforest.Outdoors\n\n\n\n\n\n\n\n\n\nРисунок 4: Пример 3D-модели с картой OpenTopoMap\n\n\n\n\n\n\n\n\n\nРисунок 5: Пример 3D-модели с картой OpenStreetMap\n\n\n\nДля лучшего восприятия можно оставить только 3D-поверхность модели, указав solid = FALSE как в следующем примере.\n\n\nКод\n\nMalySemyachik &lt;- plot_3d_vista(lat  = 54.119, \n                               long = 159.656, \n                               zscale = 3, \n                               zoom = 0.6,\n                               radius = 5000,\n                               overlay_detail = 14,\n                               theta = -50,\n                               phi = 30,\n                               windowsize = 1100, \n                               solid = FALSE,\n                               fill_holes = TRUE)\n\n\n\n\n\n\n\nРисунок 6: Стратовулкан Малый Семячик с горным озером на Камчатке\n\n\n\nДля имитации эффекта размытия можно использовать функцию render_depth().\n\n\nКод\n\nHopkinsNZ &lt;- plot_3d_vista(lat = -44.042238, \n                           long = 169.860985, \n                           radius = 5000, \n                           overlay_detail = 14,\n                           elevation_detail = 13, \n                           zscale = 5, \n                           theta = 25, phi=25, zoom = 0.6,\n                           windowsize = 1200, \n                           solid = T, \n                           background = 'white')\n\nrender_depth(focus = 0.6, focallength = 15, clear=TRUE)\n\n\n\n\n\n\n\nРисунок 7: Mount Hopkins (Новая Зеландия)"
  },
  {
    "objectID": "blog/posts/2024-02-02 rayvista/index.html#нанесение-дополнительных-географических-данных-на-3d-визуализации",
    "href": "blog/posts/2024-02-02 rayvista/index.html#нанесение-дополнительных-географических-данных-на-3d-визуализации",
    "title": "Визуализация трехмерных моделей земной поверхности",
    "section": "Нанесение дополнительных географических данных на 3D-визуализации",
    "text": "Нанесение дополнительных географических данных на 3D-визуализации\n\nПоднятие плоскости воды\nОдна из интересных возможностей, для которой может быть полезна библиотека rayvista – это оценка природных рисков наводнений локальных территорий путем параллельного поднятия плоскости воды. В качестве примера рассмотрим г. Улан-Удэ. Выберем точку внутри города с определенными географическими координатами и найдем оценочную высоту над уровнем моря с помощью сервиса Elevation Finder, в нашем случае это 490 м (в rayshader также существует команда detect_water()). Получим модель местности и поднимем уровень на 20 м до 510 м, чтобы сделать оценку риска затопления.\n\n\n\n\n\n\nРисунок 8: Оценка риска затопления с помощью 3D-моделирования для г. Улан-Удэ увеличением уровня воды на +20 м, возможный уровень затопления показан красным цветом\n\n\n\nUlanUde &lt;- plot_3d_vista(lat  = 51.834, \n                         long = 107.5696, \n                         zscale = 2, \n                         zoom = 0.5,\n                         overlay_detail = 14,\n                         theta = -65, \n                         radius = 5500,\n                         img_provider = \"Thunderforest.Outdoors\",\n                         api_key = \"your_api_key\",\n                         windowsize = 1400, \n                         soliddepth = 300,\n                         phi = 25,\n1                         water = TRUE,\n2                         waterdepth = 510,\n3                         wateralpha = 0.3,\n4                         watercolor = \"red\",\n5                         waterlinecolor = \"white\",\n                         fill_holes = TRUE)\n\n1\n\nдобавление слоя воды;\n\n2\n\nуровень воды;\n\n3\n\nпрозрачность слоя воды;\n\n4\n\nцвет слоя воды;\n\n5\n\nцвет линий по краям слоя воды.\n\n\nКод ниже добавляет маркеры и метки к текущему 3D-образу.\n\n\nКод\n\nrender_label(heightmap = UlanUde,\n             lat  = 51.824, \n             long = 107.525,\n             altitude = 140, \n             text = \"Улан-Удэ (+20 метров)\",\n             extent = attr(UlanUde, 'extent'),\n             textsize = 1.6, linewidth = 4,\n             textcolor = \"grey20\", linecolor = \"grey20\")\n\n\n\nНанеcение данных OpenStreetMap\nНа 3D-образы можно наносить помимо маркеров, например, растровые данные или данные из OpenStreetMap.\n\n\n\n\n\n\nПредостережение\n\n\n\nПрактически все сервисы стандарта Web Map Tile Service, такие как OSM, Stamen, GoogleMaps и т.д., предоставляют тайлы в системе координат (CRS) EPSG:3857 (WebMercator). Это означает, что если объект нового слоя находится в другой проекции CRS, который не является EPSG:3857 (например, EPSG:4326), необходимо привести наносимый объект (sf или растр) и подложку к единой проекции путем перепроектирования, иначе модель будет будет выглядеть деформированной.\n\n\nВ качестве примера покажем, как сделать дополнительный слой на 3D-модели, который представляет собой данные по дорогам, загруженным из сервиса OpenStreetMap. Выберем Сан-Франциско (Калифорния, США), для которого характерен сложный рельеф местности; по некоторым сведениям в Сан-Франциско насчитывают около пятидесяти возвышенностей.\nЗагрузим 3D-модель.\n\n\n\n\n\n\nРисунок 9: Модель Сан-Франциско\n\n\n\nSanFrancisco &lt;- plot_3d_vista(lat = 37.75, \n                              long = -122.45,\n                              zscale = 3, \n                              zoom = 0.5,\n                              img_provider = \"Thunderforest.Outdoors\",\n                              api_key = \"your_api_key\",\n                              overlay_detail = 14,\n                              theta = -40, \n                              phi = 25,\n                              windowsize = 1300,\n                              show_vista = FALSE)\nОпределим прямоугольник, ограничивающий область.\n\nlibrary(sf)\n\nbbox &lt;- st_bbox(c(xmin = -122.5129, \n                  ymin = 37.70026, \n                  xmax = -122.3871, \n                  ymax = 37.79975),  \n                crs = st_crs(4326))\n\nТеперь загрузим дорожную сеть из OpenStreetMap.\nlibrary(osmdata)\n\nSanFrancisco_highway &lt;- opq(bbox) |&gt;\n  add_osm_feature(\"highway\") |&gt;\n  osmdata_sf()\nСледующий этап – определение новых проекций, без этого график будет искажен.\nSanFrancisco_lines = \n  st_transform(SanFrancisco_highway$osm_lines, 3857)\n\nbbox_transformed = st_bbox(\n  st_transform(\n    st_as_sfc(bbox), \n    3857\n  )\n)\n\nlibrarary(raster)\n\nextent_zoomed = extent(bbox_transformed)\nОкончательно:\nSanFrancisco$dem_matrix |&gt;\n  height_shade() %&gt;% \n  add_overlay(., SanFrancisco$texture,\n              rescale_original = TRUE) %&gt;%\n  # дороги\n  add_overlay(\n    generate_line_overlay(\n      SanFrancisco_lines, \n      extent = extent_zoomed,\n      linewidth = 1.2, color = \"black\",\n      heightmap = SanFrancisco$dem_matrix)) %&gt;%\n  plot_3d(., SanFrancisco$dem_matrix, \n          zscale = 3,\n          windowsize = 1300, \n          zoom = 0.5, phi = 25, theta = -40)\nТеперь можно сравнить модель после нанесения дорожной сети на образ.\n\n\n\n\n\n\nРисунок 10: Модель Сан-Франциско с нанесенными OSM-дорогами\n\n\n\n\n\nНанесение дополнительных слоев на 3D-модели\nНесомненно, на модели можно накладывать и другие слои с исходными данными или результатами моделирования, что делает технологию весьма привлекательной (см., например, статью Adding Open Street Map Data to Rayshader Maps). Приведем еще один пример, сделаем слой на 3D-модели, показывающий происшествия, на которые отреагировала пожарная служба Сан-Франциско. Отметим, соответствующий набор данных также содержит географические координаты.\n\ndata_sf |&gt;\n  dplyr::select(`Incident Date`, point)\n\n# A tibble: 616,630 × 2\n   `Incident Date`     point                            \n   &lt;dttm&gt;              &lt;chr&gt;                            \n 1 2008-04-01 00:00:00 POINT (-122.41837339 37.74208979)\n 2 2008-04-01 00:00:00 POINT (-122.39489 37.756291)     \n 3 2008-04-01 00:00:00 POINT (-122.407468 37.78008)     \n 4 2008-04-01 00:00:00 POINT (-122.42684908 37.77612642)\n 5 2008-04-01 00:00:00 POINT (-122.4863941 37.77428492) \n 6 2008-04-01 00:00:00 POINT (-122.4481912 37.7597267)  \n 7 2008-04-01 00:00:00 POINT (-122.405223 37.788694)    \n 8 2008-04-01 00:00:00 POINT (-122.416457 37.739056)    \n 9 2008-04-01 00:00:00 POINT (-122.392082 37.781846)    \n10 2008-04-01 00:00:00 POINT (-122.46678342 37.75300898)\n# ℹ 616,620 more rows\n\n\nСделаем небольшую предобработку данных.\n\nlibrary(magrittr)\n\ndata_sf$coordinates &lt;- \n  str_extract(data_sf$point, \n    \"(?&lt;=\\\\()([^()]*?)(?=\\\\)[^()]*$)\")\n\ndata_sf &lt;- data_sf |&gt; \n  separate_wider_delim(coordinates, \" \", \n    names = c(\"lon\", \"lat\"))\n\ndata_sf$lat %&lt;&gt;% as.numeric()\ndata_sf$lon %&lt;&gt;% as.numeric()\n\nВ качестве примера, выделим точки вызовов, отвечающие 2022 году.\n\npoints_sf &lt;- data_sf |&gt;\n  dplyr::select(`Incident Date`, lat, lon) |&gt;\n  mutate(year = lubridate::year(`Incident Date`)) |&gt; \n  dplyr::filter(year == 2022) |&gt;\n  na.omit() |&gt;\n  st_as_sf(coords = c(\"lon\", \"lat\"), crs = 4326) %&gt;% \n  st_transform(., 3857)\n\n\npoints_sf\n\nSimple feature collection with 33260 features and 2 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -13685560 ymin: 0 xmax: 13627530 ymax: 4555811\nProjected CRS: WGS 84 / Pseudo-Mercator\n# A tibble: 33,260 × 3\n   `Incident Date`      year            geometry\n * &lt;dttm&gt;              &lt;dbl&gt;         &lt;POINT [m]&gt;\n 1 2022-01-16 00:00:00  2022 (-13625484 4548073)\n 2 2022-01-16 00:00:00  2022 (-13626605 4547332)\n 3 2022-01-21 00:00:00  2022 (-13625214 4547874)\n 4 2022-01-21 00:00:00  2022 (-13629079 4549058)\n 5 2022-01-23 00:00:00  2022 (-13628711 4551584)\n 6 2022-01-30 00:00:00  2022 (-13627494 4538682)\n 7 2022-02-08 00:00:00  2022 (-13625338 4547751)\n 8 2022-02-08 00:00:00  2022 (-13627882 4549346)\n 9 2022-02-08 00:00:00  2022 (-13627827 4546331)\n10 2022-02-10 00:00:00  2022 (-13627366 4548730)\n# ℹ 33,250 more rows\n\n\nSanFrancisco$dem_matrix |&gt;\n  height_shade() %&gt;% \n  add_overlay(., SanFrancisco$texture,\n              rescale_original = TRUE) %&gt;%\n  # пожары\n  add_overlay(\n    generate_point_overlay(\n      points_sf, extent = extent_zoomed,\n      size = 0.8, color = \"#C11317\",\n      heightmap = SanFrancisco$dem_matrix)) %&gt;%\n  plot_3d(., SanFrancisco$dem_matrix, \n          zscale = 3,\n          windowsize = 1300, \n          zoom = 0.5, phi = 25, theta = -40)\n\n\n\n\n\n\nРисунок 11: 3D-модель с нанесенными происшествиями, на которые отреагировала пожарная служба Сан-Франциско в 2022 году\n\n\n\nКак видно на рисунке (см. рис. 11), наибольшее количество происшествий приходится на деловой центр северо-востока города."
  },
  {
    "objectID": "publications/books/IT.html",
    "href": "publications/books/IT.html",
    "title": "Информационные технологии поддержки принятия решений в чрезвычайных ситуациях",
    "section": "",
    "text": "Учебное пособие содержит методически систематизированный материал, охватывающий темы учебной программы дисциплины «Информационные технологии поддержки принятия решений в чрезвычайных ситуациях». В нем особое внимание уделено действующей нормативной базе, на основе которой происходит принятие решений в области чрезвычайных ситуаций (ЧС), тенденциям законодательных изменений, применению свободно распространяемых программных средств, имеющимся информационным системам поддержки принятия решений. Пособие предназначено для использования в образовательном процессе Сибирской пожарно-спасательной академии ГПС МЧС России при изучении учебной дисциплины «Информационные технологии поддержки принятия решений в ЧС» обучающимися по направлению подготовки 38.03.04 Государственное и муниципальное управление.\n\n\n\nСсылка для цитированияBibTeX@book{матеров2023,\n  author = {Матеров, Е.Н. and Бабёнышев, С.В.},\n  publisher = {Железногорск},\n  title = {Информационные технологии поддержки принятия решений в\n    чрезвычайных ситуациях},\n  date = {2023},\n  url = {https://sibpsa.ru},\n  langid = {ru}\n}\nНа публикацию можно сослаться как\nМатеров Е.Н., Бабёнышев С.В. Информационные технологии поддержки принятия\nрешений в чрезвычайных ситуациях. Железногорск, 2023."
  },
  {
    "objectID": "publications/books/MathMeth.html",
    "href": "publications/books/MathMeth.html",
    "title": "Математически методы и информационные технологии в научных исследованиях",
    "section": "",
    "text": "Учебное пособие предназначено для адъюнктов, обучающихся в ФГБОУ ВО Сибирская пожарно-спасательная академия ГПС МЧС России. Кроме того, материал пособия может быть полезен для магистров и слушателей старших курсов. В пособии рассмотрены как классические методы анализа, так и некоторые современные инструменты. В качестве основного технического инструмента выбран язык программирования R для статистической обработки и визуализации данных.\n\nДопущено Министерством Российской Федерации по делам гражданской обороны, чрезвычайным ситуациям и ликвидации последствий стихийных бедствий в качестве учебного пособия для адъюнктов образовательных организаций МЧС России\n\n\n\n\nСсылка для цитированияBibTeX@book{матеров2018,\n  author = {Матеров, Е.Н. and Бабёнышев, С.В.},\n  publisher = {Железногорск},\n  title = {Математически методы и информационные технологии в научных\n    исследованиях},\n  date = {2018},\n  url = {https://znanium.com/catalog/document?id=353760},\n  langid = {ru}\n}\nНа публикацию можно сослаться как\nМатеров Е.Н., Бабёнышев С.В. Математически\nметоды и информационные технологии в научных исследованиях.\nЖелезногорск, 2018."
  },
  {
    "objectID": "publications/papers/Tate.html",
    "href": "publications/papers/Tate.html",
    "title": "Tate resolutions for Segre embeddings",
    "section": "",
    "text": "We give an explicit description of the terms and differentials of the Tate resolution of sheaves arising from Segre embeddings of \\(\\mathbb{P}^a\\times\\mathbb{P}^b\\). We prove that the maps in this Tate resolution are either coming from Sylvester-type maps, or from Bezout-type maps arising from the so-called toric Jacobian.\n\n\n\nСсылка для цитированияBibTeX@article{materov2008,\n  author = {Materov, Evgeny and Cox, David},\n  publisher = {MSP},\n  title = {Tate Resolutions for {Segre} Embeddings},\n  journal = {Algebra \\& Number Theory},\n  volume = {2},\n  number = {5},\n  pages = {523-549},\n  date = {2008},\n  url = {https://projecteuclid.org/journals/algebra-and-number-theory/volume-2/issue-5/Tate-resolutions-for-Segre-embeddings/10.2140/ant.2008.2.523.full},\n  doi = {10.2140/ant.2008.2.523},\n  langid = {en}\n}\nНа публикацию можно сослаться как\nMaterov, Evgeny, and David Cox. 2008. “Tate Resolutions for Segre\nEmbeddings.” Algebra & Number Theory 2: 523–49. https://doi.org/10.2140/ant.2008.2.523."
  },
  {
    "objectID": "publications/papers/Vestnik_2021c.html",
    "href": "publications/papers/Vestnik_2021c.html",
    "title": "Анализ пожарной и техносферной безопасности городской среды г. Красноярска с применением геопространственных инструментов",
    "section": "",
    "text": "В статье рассмотрены возможности применения современных открытых геоинформационных инструментов к анализу географических данных в некоторых проблемах техносферной и пожарной безопасности. В частности, в вопросах связанных с оценкой зон достижимости социально-значимых объектов, оценкой влияния плотности застройки на распределение пожаров, а также анализом источников противопожарного водоснабжения в городской среде. Основные расчеты выполнены с использованием языка программирования R. Применяемые инструменты могут быть полезными для планирования надзорных мероприятий, а также при оценке сил и средств гарнизонов для организации тушения пожаров. Результаты, приведенные в работе, получены для города Красноярска, однако подобные подходы могут быть использованы для вычислений и визуализации аналогичного рода для любого населенного пункта Российской Федерации.\n\n\n\nСсылка для цитированияBibTeX@article{матеров2021,\n  author = {Матеров, Е.Н. and Бабёнышев, С.В. and Малютин, О.С. and\n    Елфимова, М.В.},\n  title = {Анализ пожарной и техносферной безопасности городской среды\n    г. Красноярска с применением геопространственных инструментов},\n  journal = {Сибирский пожарно-спасательный вестник},\n  volume = {23},\n  number = {4},\n  pages = {128-136},\n  date = {2021},\n  url = {http://vestnik.sibpsa.ru/},\n  langid = {ru}\n}\nНа публикацию можно сослаться как\n1. Матеров Е. Н. [и др.]. Анализ\nпожарной и техносферной безопасности городской среды г. Красноярска с\nприменением геопространственных инструментов // Сибирский\nпожарно-спасательный вестник. 2021. (23). C. 128–136."
  },
  {
    "objectID": "publications/papers/Vestnik_2021a.html",
    "href": "publications/papers/Vestnik_2021a.html",
    "title": "Прогнозирование временных рядов на основе методов машинного обучения в вопросах обеспечения природной и техносферной безопасности",
    "section": "",
    "text": "Основная цель статьи – сделать обзор современных возможностей анализа и моделирования временных рядов на примерах прогнозирования количества пожаров и уровня подъема воды в реках с помощью современных методов машинного обучения в среде программирования R. Особенность данного моделирования состоит в возможности использования нескольких моделей одновременно, что позволяет автоматизировано выбирать модели с наименьшими погрешностями.\n\n\n\nСсылка для цитированияBibTeX@article{матеров2021,\n  author = {Матеров, Е.Н. and Бабёнышев, С.В. and Малютин, О.С.},\n  title = {Прогнозирование временных рядов на основе методов машинного\n    обучения в вопросах обеспечения природной и техносферной\n    безопасности},\n  journal = {Сибирский пожарно-спасательный вестник},\n  volume = {20},\n  number = {1},\n  pages = {75-83},\n  date = {2021},\n  url = {http://vestnik.sibpsa.ru/},\n  langid = {ru}\n}\nНа публикацию можно сослаться как\n1. Матеров Е. Н., Бабёнышев С. В., Малютин О. С. Прогнозирование временных рядов на\nоснове методов машинного обучения в вопросах обеспечения природной и\nтехносферной безопасности // Сибирский пожарно-спасательный вестник.\n2021. (20). C. 75–83."
  },
  {
    "objectID": "publications/papers/TRMS.html",
    "href": "publications/papers/TRMS.html",
    "title": "Toric residues and mirror symmetry",
    "section": "",
    "text": "We develop some ideas of Morrison and Plesser and formulate a precise mathematical conjecture which has close relations to toric mirror symmetry. Our conjecture, we call it Toric Residue Mirror Conjecture, claims that the generating functions of intersection numbers of divisors on a special sequence of simplicial toric varieties are power series expansions of some rational functions obtained as toric residues. We expect that this conjecture holds true for all Gorenstein toric Fano varieties associated with reflexive polytopes and give some evidences for that. The proposed conjecture suggests a simple method for computing Yukawa couplings for toric mirror Calabi-Yau hypersurfaces without solving systems of differential equations. We make several explicit computations for Calabi-Yau hypersurfaces in weighted projective spaces and in products of projective spaces.\n\n\n\nСсылка для цитированияBibTeX@article{materov2002,\n  author = {Materov, Evgeny and Batyrev, Victor},\n  title = {Toric Residues and Mirror Symmetry},\n  journal = {Moscow Mathematical Journal},\n  volume = {2},\n  number = {3},\n  pages = {435-475},\n  date = {2002},\n  url = {http://www.mathjournals.org/mmj/vol2-3-2002/abst2-3-2002.html#batyrev-materov_abstract},\n  doi = {10.17323/1609-4514-2002-2-3-435-475},\n  langid = {en}\n}\nНа публикацию можно сослаться как\nMaterov, Evgeny, and Victor Batyrev. 2002. “Toric Residues and\nMirror Symmetry.” Moscow Mathematical Journal 2: 435–75.\nhttps://doi.org/10.17323/1609-4514-2002-2-3-435-475."
  },
  {
    "objectID": "publications/papers/Bott.html",
    "href": "publications/papers/Bott.html",
    "title": "The Bott Formula for Toric Varieties",
    "section": "",
    "text": "The purpose of this paper is to give an explicit formula which allows one to compute the dimension of the cohomology groups of the sheaf \\(\\Omega_{\\mathbb{P}}^p(D)= \\Omega_{\\mathbb{P}}^p\\otimes {\\mathcal{O}_\\mathbb{P}}(D)\\) of \\(p\\)-th differential forms Zariski twisted by an ample invertible sheaf on a complete simplicial toric variety. The formula involves some combinatorial sums of integer points over all faces of the support polytope for \\({\\mathcal{O}_\\mathbb{P}}(D)\\). Comparison of two versions of the Bott formula gives some elegant corollaries in the combinatorics of simple polytopes. Also, we obtain a generalization of the reciprocity law. Some applications of the Bott formula are discussed.\n\n\n\nСсылка для цитированияBibTeX@article{materov2002,\n  author = {Materov, Evgeny},\n  title = {The {Bott} {Formula} for {Toric} {Varieties}},\n  journal = {Moscow Mathematical Journal},\n  volume = {2},\n  number = {1},\n  pages = {161-182},\n  date = {2002},\n  url = {http://www.mathjournals.org/mmj/vol2-1-2002/abst2-1-2002.html#materov_abstract},\n  doi = {10.17323/1609-4514-2002-2-1-161-182},\n  langid = {en}\n}\nНа публикацию можно сослаться как\nMaterov, Evgeny. 2002. “The Bott Formula for Toric\nVarieties.” Moscow Mathematical Journal 2: 161–82. https://doi.org/10.17323/1609-4514-2002-2-1-161-182."
  },
  {
    "objectID": "publications/papers/Vestnik_2019a.html",
    "href": "publications/papers/Vestnik_2019a.html",
    "title": "Использование языка программирования R в вопросах пожарной безопасности. Анализ статистики количества пожаров на основе теории временных рядов",
    "section": "",
    "text": "В статье сделан обзор основных приемов работы с временными рядами в языке программирования R на примере данных по статистике пожаров в Красноярском крае – разведочный анализ данных, разложение временных рядов на компоненты, интегрированная модель авторегрессии-скользящего среднего и некоторые другие методы.\n\n\n\nСсылка для цитированияBibTeX@article{матеров2019,\n  author = {Матеров, Е.Н.},\n  title = {Использование языка программирования R в вопросах пожарной\n    безопасности. Анализ статистики количества пожаров на основе теории\n    временных рядов},\n  journal = {Сибирский пожарно-спасательный вестник},\n  volume = {12},\n  number = {1},\n  pages = {52-57},\n  date = {2019},\n  url = {http://vestnik.sibpsa.ru/},\n  langid = {ru}\n}\nНа публикацию можно сослаться как\n1. Матеров Е. Н. Использование языка\nпрограммирования R в вопросах пожарной безопасности. Анализ статистики\nколичества пожаров на основе теории временных рядов // Сибирский\nпожарно-спасательный вестник. 2019. (12). C. 52–57."
  },
  {
    "objectID": "publications/papers/Vestnik_2018.html",
    "href": "publications/papers/Vestnik_2018.html",
    "title": "Использование языка программирования R в вопросах пожарной безопасности. Обработка и визуализация данных",
    "section": "",
    "text": "В статье сделан обзор языка программирования R, его возможностей для обработки и визуализации табличных данных на примерах, связанных с вопросами пожарной безопасности. Кроме того, показаны основные принципы построения графики средствами R, приведены примеры анализа данных, даны общие рекомендации по перспективным методам компьютерной обработки информации в среде R, показаны преимущества по сравнению с другими средствами обработки данных.\n\n\n\nСсылка для цитированияBibTeX@article{матеров2018,\n  author = {Матеров, Е.Н.},\n  title = {Использование языка программирования R в вопросах пожарной\n    безопасности. Обработка и визуализация данных},\n  journal = {Сибирский пожарно-спасательный вестник},\n  volume = {11},\n  number = {4},\n  pages = {60-66},\n  date = {2018},\n  url = {http://vestnik.sibpsa.ru/},\n  langid = {ru}\n}\nНа публикацию можно сослаться как\n1. Матеров Е. Н. Использование языка\nпрограммирования R в вопросах пожарной безопасности. Обработка и\nвизуализация данных // Сибирский пожарно-спасательный вестник. 2018.\n(11). C. 60–66."
  },
  {
    "objectID": "publications/papers/Lattice.html",
    "href": "publications/papers/Lattice.html",
    "title": "Weighted Lattice Point Sums in Lattice Polytopes, Unifying Dehn–Sommerville and Ehrhart–Macdonald",
    "section": "",
    "text": "Let \\(V\\) be a real vector space of dimension \\(n\\) and let \\(M\\subset V\\) be a lattice. Let \\(P\\subset V\\) be an \\(n\\)-dimensional polytope with vertices in \\(M\\), and let \\(\\varphi\\colon V\\rightarrow \\mathbb{C}\\) be a homogeneous polynomial function of degree \\(d\\). For \\(q\\in \\mathbb{Z}_{&gt;0}\\) and any face \\(F\\) of \\(P\\), let \\(D_{\\varphi, F}(q)\\) be the sum of \\(\\varphi\\) over the lattice points in the dilate \\(qF\\). We define a generating function \\(G_{\\varphi}(q,y) \\in \\mathbb{Q}[q][y]\\) packaging together the various \\(D_{\\varphi ,F}(q)\\), and show that it satisfies a functional equation that simultaneously generalizes Ehrhart–Macdonald reciprocity and the Dehn–Sommerville relations. When \\(P\\) is a simple lattice polytope (i.e., each vertex meets \\(n\\) edges), we show how \\(G_{\\varphi}\\) can be computed using an analogue of Brion–Vergne’s Euler–Maclaurin summation formula.\n\n\n\nСсылка для цитированияBibTeX@article{materov2020,\n  author = {Materov, Evgeny and Gunnels, Paul and Beck, Matthias},\n  title = {Weighted {Lattice} {Point} {Sums} in {Lattice} {Polytopes,}\n    {Unifying} {Dehn–Sommerville} and {Ehrhart–Macdonald}},\n  journal = {Discrete \\& Computational Geometry},\n  volume = {65},\n  pages = {365–384},\n  date = {2020},\n  url = {https://link.springer.com/article/10.1007/s00454-020-00175-2},\n  doi = {10.1007/s00454-020-00175-2},\n  langid = {en}\n}\nНа публикацию можно сослаться как\nMaterov, Evgeny, Paul Gunnels, and Matthias Beck. 2020. “Weighted\nLattice Point Sums in Lattice Polytopes, Unifying Dehn–Sommerville and\nEhrhart–Macdonald.” Discrete & Computational\nGeometry 65: 365–84. https://doi.org/10.1007/s00454-020-00175-2."
  },
  {
    "objectID": "publications/papers/CEUR.html",
    "href": "publications/papers/CEUR.html",
    "title": "Using Tools of Intellectual Analysis in Area Safety Management",
    "section": "",
    "text": "In this study, we explore various methods of analytical data processing employed to support information tasks in managing territory safety. Specifically, we investigate the challenge of data availability when utilizing data lakes technology for operational analytics. By leveraging Data Mining and Machine Learning techniques for processing extensive datasets encompassing monitoring data, hazard event catalogs, and territory characteristics, we are able to swiftly and effectively mitigate threats to human life. The findings of our spatial modeling of fire risks are presented, along with a novel approach for predicting time series utilizing artificial neural networks.\n\n\n\nСсылка для цитированияBibTeX citation:@misc{materov2021,\n  author = {Materov, E. and Nicheporchuk, V.},\n  title = {Using {Tools} of {Intellectual} {Analysis} in {Area} {Safety}\n    {Management}},\n  pages = {86-92},\n  date = {2021},\n  url = {https://ceur-ws.org/Vol-3047/},\n  doi = {10.47813/sibdata-2-2021-12},\n  langid = {en}\n}\nНа публикацию можно сослаться как\nMaterov, E., and V. Nicheporchuk. 2021. “Using Tools of\nIntellectual Analysis in Area Safety Management.” SibDATA\n2021. The 2nd Siberian Scientific Workshop on Data Analysis Technologies\nwith Applications 2021. https://doi.org/10.47813/sibdata-2-2021-12."
  },
  {
    "objectID": "publications/papers/Weyman.html",
    "href": "publications/papers/Weyman.html",
    "title": "Tate Resolutions and Weyman Complexes",
    "section": "",
    "text": "We construct generalized Weyman complexes for coherent sheaves on projective space and describe explicitly how the diﬀerential depend on the diﬀerentials in the correpsonding Tate resolution. We apply this to deﬁne the Weyman complex of a coherent sheaf on a projective variety and explain how certain Weyman complexes can be regarded as Fourier-Mukai transforms.\n\n\n\nСсылка для цитированияBibTeX@article{materov2011,\n  author = {Materov, Evgeny and Cox, David},\n  title = {Tate {Resolutions} and {Weyman} {Complexes}},\n  journal = {Pacific Journal of Mathematics},\n  volume = {252},\n  pages = {51-68},\n  date = {2011},\n  url = {https://msp.org/pjm/2011/252-1/p04.xhtml},\n  doi = {10.2140/pjm.2011.252.51},\n  langid = {en}\n}\nНа публикацию можно сослаться как\nMaterov, Evgeny, and David Cox. 2011. “Tate Resolutions and Weyman\nComplexes.” Pacific Journal of Mathematics 252: 51–68.\nhttps://doi.org/10.2140/pjm.2011.252.51."
  },
  {
    "objectID": "publications/papers/Vestnik_2023a.html",
    "href": "publications/papers/Vestnik_2023a.html",
    "title": "Оптимизация границ районов выезда с использованием языка программирования Python и библиотеки OSMnx",
    "section": "",
    "text": "В статье показывается способ решения задачи оптимизации границ районов выезда и качественной оценки влияния изменения границ районов выезда с использованием языка программирования Python и специальных программных решений для анализа геопространственных данных. Описывается ход работы и использованные технические решения. Перечисляются возникшие сложности и «узкие места» как реализации, так и метода в целом. Приводятся результаты расчета на примере условного пожарно-спасательного гарнизона. Даются рекомендации по применению и дальнейшему совершенствованию показанного метода.\n\n\n\nСсылка для цитированияBibTeX@article{малютин2023,\n  author = {Малютин, О.С. and Бабёнышев, С.В. and Матеров, Е.Н.},\n  title = {Оптимизация границ районов выезда с использованием языка\n    программирования Python и библиотеки OSMnx},\n  journal = {Сибирский пожарно-спасательный вестник},\n  volume = {28},\n  number = {1},\n  pages = {38-55},\n  date = {2023},\n  url = {http://vestnik.sibpsa.ru/},\n  langid = {ru}\n}\nНа публикацию можно сослаться как\n1. Малютин О. С., Бабёнышев С. В., Матеров Е. Н. Оптимизация границ районов выезда с\nиспользованием языка программирования Python и библиотеки OSMnx //\nСибирский пожарно-спасательный вестник. 2023. (28). C. 38–55."
  },
  {
    "objectID": "publications/papers/Vestnik_2023b.html",
    "href": "publications/papers/Vestnik_2023b.html",
    "title": "Ретроспективный анализ лесных пожаров в Красноярском крае с использованием науки о данных и метод машинного обучения",
    "section": "",
    "text": "В статье анализируются данные о лесных пожарах в Красноярском крае за период 2011-2023 гг. с учетом их географического распределения. В работе рассмотрены: (1) разведочный анализ данных о пожарах, включая антропогенное воздействие на пожарную активность и изменений в пожарах с течением лет; (2) построение модели машинного обучения, которая предсказывает, является ли термоточка критической, т.е. находится ближе 5 км от населенного пункта или площадь пожара более 200 га. Новизна работы заключается в эффективном использовании языка программирования R, наделенного расширенными возможностями для анализа данных, моделирования методами машинного обучения и визуализации. Использование методов обработки данных, рассмотренных в статье, может повысить точность обнаружения и прогнозирования изменений пожарной активности, последующего мониторинга и крупномасштабного управления пожаротушением. Подходы, разобранные в статье, могут быть применены и к другим регионам Российской Федерации.\n\n\n\nСсылка для цитированияBibTeX@article{бабёнышев2023,\n  author = {Бабёнышев, С.В. and Матеров, Е.Н. and Миловидова, Т.А.},\n  title = {Ретроспективный анализ лесных пожаров в Красноярском крае с\n    использованием науки о данных и метод машинного обучения},\n  journal = {Сибирский пожарно-спасательный вестник},\n  volume = {31},\n  number = {4},\n  pages = {148-159},\n  date = {2023},\n  url = {http://vestnik.sibpsa.ru/},\n  langid = {ru}\n}\nНа публикацию можно сослаться как\n1. Бабёнышев С. В., Матеров Е. Н., Миловидова Т. А. Ретроспективный анализ лесных пожаров в\nКрасноярском крае с использованием науки о данных и метод машинного\nобучения // Сибирский пожарно-спасательный вестник. 2023. (31). C.\n148–159."
  },
  {
    "objectID": "publications/papers/Vestnik_2019b.html",
    "href": "publications/papers/Vestnik_2019b.html",
    "title": "Использование языка программирования R в вопросах пожарной безопасности: анализ главных компонент",
    "section": "",
    "text": "В статье рассмотрен метод главных компонент в применении к анализу данных по пожарам в Красноярском крае, а также рассмотрены возможности реализации данного метода на языке программирования R. Этапы реализации проиллюстрированы на конкретном примере данных пожаров на автотранспорте.\n\n\n\nСсылка для цитированияBibTeX@article{матеров2019,\n  author = {Матеров, Е.Н.},\n  title = {Использование языка программирования R в вопросах пожарной\n    безопасности: анализ главных компонент},\n  journal = {Сибирский пожарно-спасательный вестник},\n  volume = {13},\n  number = {2},\n  pages = {49-53},\n  date = {2019},\n  url = {http://vestnik.sibpsa.ru/},\n  langid = {ru}\n}\nНа публикацию можно сослаться как\n1. Матеров Е. Н. Использование языка\nпрограммирования R в вопросах пожарной безопасности: анализ главных\nкомпонент // Сибирский пожарно-спасательный вестник. 2019. (13). C.\n49–53."
  },
  {
    "objectID": "publications/papers/MTRMS.html",
    "href": "publications/papers/MTRMS.html",
    "title": "Mixed Toric Residues and Calabi-Yau Complete Intersections",
    "section": "",
    "text": "Using Cayley trick, we define the notions of mixed toric residues and mixed Hessians associated with r Laurent polynomials \\(f_1,\\ldots,f_r\\). We conjecture that the values of mixed toric residues on the mixed Hessians are determined by mixed volumes of the Newton polytopes of \\(f_1,\\ldots,f_r\\). Using mixed toric residues, we generalize our Toric Residue Mirror Conjecture to the case of Calabi-Yau complete intersections in Gorenstein toric Fano varieties obtained from nef-partitions of reflexive polytopes.\n\n\n\nСсылка для цитированияBibTeX@misc{materov2003,\n  author = {Materov, Evgeny and Batyrev, Victor},\n  title = {Mixed {Toric} {Residues} and {Calabi-Yau} {Complete}\n    {Intersections}},\n  volume = {38},\n  date = {2003},\n  url = {http://www.ams.org/books/fic/038/},\n  doi = {http://dx.doi.org/10.1090/fic/038},\n  isbn = {978-0-8218-3355-1},\n  langid = {en}\n}\nНа публикацию можно сослаться как\nMaterov, Evgeny, and Victor Batyrev. 2003. “Mixed Toric Residues\nand Calabi-Yau Complete Intersections.” Calabi-Yau Varieties\nand Mirror Symmetry. https://doi.org/http://dx.doi.org/10.1090/fic/038."
  },
  {
    "objectID": "publications/papers/Regularity.html",
    "href": "publications/papers/Regularity.html",
    "title": "Regularity and Segre-Veronese embeddings",
    "section": "",
    "text": "This paper studies the regularity of certain coherent sheaves that arise naturally from Segre-Veronese embeddings of a product of projective spaces. We give an explicit formula for the regularity of these sheaves and show that their regularity is subadditive. We then apply our results to study the Tate resolutions of these sheaves.\n\n\n\nСсылка для цитированияBibTeX@article{materov2009,\n  author = {Materov, Evgeny and Cox, David},\n  publisher = {AMS},\n  title = {Regularity and {Segre-Veronese} Embeddings},\n  journal = {Proceedings of the American Mathematical Society},\n  volume = {137},\n  pages = {1883-1890},\n  date = {2009},\n  url = {https://www.ams.org/journals/proc/2009-137-06/S0002-9939-09-09783-4/},\n  langid = {en}\n}\nНа публикацию можно сослаться как\nMaterov, Evgeny, and David Cox. 2009. “Regularity and\nSegre-Veronese Embeddings.” Proceedings of the American\nMathematical Society 137: 1883–90. https://www.ams.org/journals/proc/2009-137-06/S0002-9939-09-09783-4/."
  },
  {
    "objectID": "publications/papers/Vestnik_2021b.html",
    "href": "publications/papers/Vestnik_2021b.html",
    "title": "Применение геоинформационных инструментов для работы с большими данными при анализе пространственного распределения пожаров",
    "section": "",
    "text": "В статье рассмотрены возможности языков программирования Python и R в применении к геокодингу и анализу географических данных, связанных с пожарами и их последствиями. В работе рассмотрены: нанесение на статические и интерактивные географические карты исходных данных по пожарам, графика плотности пожаров, данных по времени прибытия подразделений, а также построение зон транспортной доступности и оптимальных маршрутов. Использованные аналитические инструменты могут быть полезны при определении порядка привлечения сил и средств подразделений пожарно-спасательных гарнизонов, в частности, при разработке планов привлечения и расписаний выездов сил и средств гарнизонов для тушения пожаров. Приведенная в работе процедура анализа может быть использована, с учетом специфики, практически для любого населенного пункта Российской Федерации.\n\n\n\nСсылка для цитированияBibTeX@article{матеров2021,\n  author = {Матеров, Е.Н. and Бабёнышев, С.В. and Малютин, О.С. and\n    Бойко, Г.М.},\n  title = {Применение геоинформационных инструментов для работы с\n    большими данными при анализе пространственного распределения\n    пожаров},\n  journal = {Сибирский пожарно-спасательный вестник},\n  volume = {21},\n  number = {2},\n  pages = {70-77},\n  date = {2021},\n  url = {http://vestnik.sibpsa.ru/},\n  langid = {ru}\n}\nНа публикацию можно сослаться как\n1. Матеров Е. Н. [и др.]. Применение\nгеоинформационных инструментов для работы с большими данными при анализе\nпространственного распределения пожаров // Сибирский\nпожарно-спасательный вестник. 2021. (21). C. 70–77."
  },
  {
    "objectID": "publications/books/SA.html",
    "href": "publications/books/SA.html",
    "title": "Системный анализ и исследование операций",
    "section": "",
    "text": "В пособии приведены необходимые теоретические сведения и примеры решения задач, необходимые для преподавания дисциплины «Системный анализ и исследование операций» по направлению подготовки 38.03.04 «Государственное и муниципальное управление», профиль «Управление в кризисных ситуациях». В пособии используются примеры, иллюстрирующие применение классических методов исследования операций в задачах распределения ресурсов, планирования маршрутов, эффективности вложений и других. Изложение материала направлено на понимание основ применяемых методов, что позволит адаптировать их к широкому кругу практических задач оптимизации.\n\nДопущено Министерством Российской Федерации по делам гражданской обороны, чрезвычайным ситуациям и ликвидации последствий стихийных бедствий в качестве учебного пособия для курсантов, студентов и слушателей образовательных организаций МЧС России\n\n\n\n\nСсылка для цитированияBibTeX@book{матеров2022,\n  author = {Матеров, Е.Н. and Бабёнышев, С.В.},\n  publisher = {Железногорск},\n  title = {Системный анализ и исследование операций},\n  date = {2022},\n  url = {https://znanium.com/catalog/document?id=353761},\n  langid = {ru}\n}\nНа публикацию можно сослаться как\nМатеров Е.Н., Бабёнышев С.В. Системный анализ и\nисследование операций. Железногорск, 2022."
  },
  {
    "objectID": "publications/books/MO.html",
    "href": "publications/books/MO.html",
    "title": "Методы оптимизации",
    "section": "",
    "text": "В пособии приведены необходимые теоретические сведения и примеры решения задач по дисциплине «Методы оптимизации». Изложение материала ведется с упором на решение практических задач. В учебном пособии используются примеры, иллюстрирующие применения, связанные с задачами МЧС России.\n\nДопущено Министерством Российской Федерации по делам гражданской обороны, чрезвычайным ситуациям и ликвидации последствий стихийных бедствий в качестве учебного пособия для курсантов, студентов и слушателей образовательных организаций МЧС России\n\n\n\n\nСсылка для цитированияBibTeX@book{матеров2019,\n  author = {Матеров, Е.Н. and Бабёнышев, С.В.},\n  publisher = {Железногорск},\n  title = {Методы оптимизации},\n  date = {2019},\n  url = {https://znanium.com/catalog/document?id=353761},\n  langid = {ru}\n}\nНа публикацию можно сослаться как\nМатеров Е.Н., Бабёнышев С.В. Методы\nоптимизации. Железногорск, 2019."
  },
  {
    "objectID": "publications/index.html",
    "href": "publications/index.html",
    "title": "Наука и данные",
    "section": "",
    "text": "2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2019\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2018\n\n\n\n\n\n\n\n\nНет подходящих элементов"
  },
  {
    "objectID": "publications/index.html#книги-и-учебные-пособия",
    "href": "publications/index.html#книги-и-учебные-пособия",
    "title": "Наука и данные",
    "section": "",
    "text": "2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2019\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2018\n\n\n\n\n\n\n\n\nНет подходящих элементов"
  },
  {
    "objectID": "publications/index.html#избранные-научные-статьи",
    "href": "publications/index.html#избранные-научные-статьи",
    "title": "Наука и данные",
    "section": "Избранные научные статьи",
    "text": "Избранные научные статьи\n\n\n   \n     \n     \n       Сортировать\n       по умолчанию\n         \n          Дата - сначала старые\n        \n         \n          Дата - сначала новые\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nДата\n\n\nЗаголовок\n\n\nАвтор\n\n\n\n\n\n\nдекабрь 2023\n\n\nРетроспективный анализ лесных пожаров в Красноярском крае с использованием науки о данных и метод машинного обучения\n\n\nС.В. Бабёнышев, Е.Н. Матеров, Т.А. Миловидова\n\n\n\n\nянварь 2023\n\n\nОптимизация границ районов выезда с использованием языка программирования Python и библиотеки OSMnx\n\n\nО.С. Малютин, С.В. Бабёнышев, Е.Н. Матеров\n\n\n\n\nдекабрь 2021\n\n\nАнализ пожарной и техносферной безопасности городской среды г. Красноярска с применением геопространственных инструментов\n\n\nЕ.Н. Матеров, С.В. Бабёнышев, О.С. Малютин, М.В. Елфимова\n\n\n\n\nиюнь 2021\n\n\nUsing Tools of Intellectual Analysis in Area Safety Management\n\n\nE. Materov, V. Nicheporchuk\n\n\n\n\nиюнь 2021\n\n\nПрименение геоинформационных инструментов для работы с большими данными при анализе пространственного распределения пожаров\n\n\nЕ.Н. Матеров, С.В. Бабёнышев, О.С. Малютин, Г.М. Бойко\n\n\n\n\nмарт 2021\n\n\nПрогнозирование временных рядов на основе методов машинного обучения в вопросах обеспечения природной и техносферной безопасности\n\n\nЕ.Н. Матеров, С.В. Бабёнышев, О.С. Малютин\n\n\n\n\nянварь 2020\n\n\nWeighted Lattice Point Sums in Lattice Polytopes, Unifying Dehn–Sommerville and Ehrhart–Macdonald\n\n\nEvgeny Materov, Paul Gunnels, Matthias Beck\n\n\n\n\nиюль 2019\n\n\nИспользование языка программирования R в вопросах пожарной безопасности: анализ главных компонент\n\n\nЕ.Н. Матеров\n\n\n\n\nапрель 2019\n\n\nИспользование языка программирования R в вопросах пожарной безопасности. Анализ статистики количества пожаров на основе теории временных рядов\n\n\nЕ.Н. Матеров\n\n\n\n\nдекабрь 2018\n\n\nИспользование языка программирования R в вопросах пожарной безопасности. Обработка и визуализация данных\n\n\nЕ.Н. Матеров\n\n\n\n\nоктябрь 2011\n\n\nTate Resolutions and Weyman Complexes\n\n\nEvgeny Materov, David Cox\n\n\n\n\nянварь 2009\n\n\nRegularity and Segre-Veronese embeddings\n\n\nEvgeny Materov, David Cox\n\n\n\n\nмай 2008\n\n\nTate resolutions for Segre embeddings\n\n\nEvgeny Materov, David Cox\n\n\n\n\nноябрь 2002\n\n\nMixed Toric Residues and Calabi-Yau Complete Intersections\n\n\nEvgeny Materov, Victor Batyrev\n\n\n\n\nноябрь 2002\n\n\nToric residues and mirror symmetry\n\n\nEvgeny Materov, Victor Batyrev\n\n\n\n\nапрель 2002\n\n\nThe Bott Formula for Toric Varieties\n\n\nEvgeny Materov\n\n\n\n\n\nНет подходящих элементов"
  },
  {
    "objectID": "projects/index.html",
    "href": "projects/index.html",
    "title": "Наука и данные",
    "section": "",
    "text": "Rесурсы\n\n\nполезные ссылки на источники по языку программирования R\n\n\n\n\n\n\n\n\n\n\n\n\n\nГрафики на досуге\n\n\nмини-блог по визуализации данных\n\n\n\n\n\n\n\n\n\n\n\n\n\nВведение в Quarto\n\n\nсерия митапов по основным навыкам работы в Quarto\n\n\n\n\n\n\n\nНет подходящих элементов"
  },
  {
    "objectID": "blog/posts/2021-11-22-reachability/index.html#создание-картографической-основы",
    "href": "blog/posts/2021-11-22-reachability/index.html#создание-картографической-основы",
    "title": "Анализ географически распределенных объектов городской инфраструктуры",
    "section": "Создание картографической основы",
    "text": "Создание картографической основы\nИдея создания карты такого рода рассмотрена в блоге, ее автор – Taras Kaduk.\nЗагрузим необходимые для работы библиотеки. Для получения данных с OpenStreetMap используется библиотека osmdata, для работы с географическими данными на основе стандарта Simple Features – библиотека sf, библиотека osrm является связующим звеном между R и сервисом OSRM для определения расстояния между объектами, времени движения и кратчайшего пути. Следует отметить, что альтернативный подход для доступа к данным, лежащим в основе OpenStreetMap использует библиотека osmdata, а для массовых извлечений больших наборов данных OSM в сжатом pbf-формате – библиотека osmextract.\n\n# общие библиотеки\nlibrary(tidyverse)\nlibrary(magrittr)\n\n# работа с географическими данными\nlibrary(osmdata)\nlibrary(osrm)\nlibrary(sf)\n\n# шкала масштаба на карте\nlibrary(ggspatial)\n\nЗафиксируем географический объект, в нашем случае – город Красноярск.\n\n# здесь можно указать любой другой город\nmy_place &lt;- \"Krasnojarsk Russia\"\n\n\n\n\n\n\n\nРисунок 1: Пример карты дорожной сети города Красноярска в сервисе city roads\n\n\n\nСделаем запрос из OSM для нахождения географических границ города.\n# загрузим все границы, связанные с объектом\n1all_boundaries &lt;- opq(my_place, timeout = 300) |&gt;\n2  add_osm_feature(key = \"boundary\",\n                  value = \"administrative\") |&gt;\n3  osmdata_sf() |&gt;\n4  unname_osmdata_sf() %&gt;%\n  .$osm_multipolygons\n\n1\n\nделает Overpass-запрос; увеличение параметра timeout позволяет делать большие запросы, поскольку время ожидания сервера может истечь до того, как будут доставлены все данные1;\n\n2\n\nдобавляет функции в запрос Overpass, которые задаются парами key-value; подробное описание значений представлено на wiki OSM, для получения полного списка значений можно использовать команду available_features(), в нашем случае это административные границы: областей, районов, округов и т.д.;\n\n3\n\nвозвращает sf-объект;\n\n4\n\nудаляет имена из osmdata геометрических объектов.\n\n\nВыясним, где могут содержаться потенциально возможные границы города.\nall_boundaries |&gt; \n  as_tibble() |&gt; \n  dplyr::select(osm_id, name, geom) |&gt; \n  dplyr::filter(grepl(\"Красноярск\", name))\n\n\n\n# A tibble: 2 × 3\n  osm_id  name                                                              geom\n  &lt;chr&gt;   &lt;chr&gt;                                               &lt;MULTIPOLYGON [°]&gt;\n1 190090  Красноярский край          (((111.3179 73.85324, 111.3222 73.85231, 1…\n2 1157393 городской округ Красноярск (((93.01595 56.06642, 93.01739 56.06589, 9…\n\n\n\nВыделим из полученного множества границ только нужную нам, соответствующую границе городского округа.\n\nboundary_KRSK &lt;- all_boundaries |&gt; \n                   dplyr::filter(osm_id == 1157393)\n\nДругой простой способ получения границы города – воспользоваться библиотекой nominatimlite для (обратного) геокодирования на основе Nominatim API.\nboundary_KRSK &lt;- nominatimlite::geo_lite_sf(my_place, points_only = FALSE)\nТеперь получим картографические данные, включающие в себя дорожную сеть улиц, железные дороги и водные объекты – реки и озера. Фиксируем значения ключа highway.\n\n\nКод: типы загружаемых дорог\n# типы загружаемых дорог и толщина линий на карте\nhighway_sizes &lt;- tibble::tribble(\n  ~highway, ~highway_group,\n  \"motorway\",      \"large\",\n  \"trunk\",         \"large\",\n  \"motorway_link\", \"large\",\n  \"primary\",       \"large\",\n  \"primary_link\",  \"large\",\n  \"secondary\",     \"medium\",\n  \"secondary_link\",\"medium\",\n  \"tertiary\",      \"medium\",\n  \"tertiary_link\", \"medium\",\n  \"trunk_link\",    \"medium\",\n  \"residential\",   \"small\",\n  \"living_street\", \"small\",\n  \"unclassified\",  \"small\",\n  \"service\",       \"small\",\n  \"road\",          \"small\",\n)\n\n\nЗагрузим дорожную сеть города.2\n# streets (улицы)\nstreets_osm &lt;- opq(my_place, timeout = 300) |&gt;\n  add_osm_feature(key = \"highway\", \n                  value = highway_sizes$highway) |&gt;\n  osmdata_sf() |&gt; \n  unname_osmdata_sf()\nВыделим только типы линий osm_lines и оставим только улицы, находящиеся внутри границы boundary_KRSK.\nstreets &lt;- streets_osm$osm_lines %&gt;%\n  mutate(length = as.numeric(st_length(.))) |&gt;\n  left_join(highway_sizes, by = \"highway\") |&gt; \n  st_intersection(boundary_KRSK)\n\nstreets |&gt;\n  dplyr::select(osm_id, name, highway, \n                maxspeed, oneway, surface) |&gt;\n  head(5)\n\nSimple feature collection with 5 features and 6 fields\nGeometry type: MULTILINESTRING\nDimension:     XY\nBounding box:  xmin: 92.9288 ymin: 56.0738 xmax: 92.94057 ymax: 56.08547\nGeodetic CRS:  WGS 84\n    osm_id             name highway maxspeed oneway surface\n1 17639885   Северное шоссе primary       60    yes asphalt\n2 25375023 Енисейский тракт primary       60    yes asphalt\n3 25375024      улица 9 Мая primary       60    yes asphalt\n4 25375027 Енисейский тракт primary       60    yes asphalt\n5 25375030 Енисейский тракт primary       60    yes asphalt\n                            geom\n1 MULTILINESTRING ((92.93389 ...\n2 MULTILINESTRING ((92.93911 ...\n3 MULTILINESTRING ((92.93978 ...\n4 MULTILINESTRING ((92.93999 ...\n5 MULTILINESTRING ((92.93936 ...\n\n\nЗагрузим данные соответствующие железным дорогам.\n\n\nКод: железные дороги\n\n# railways (железные дороги)\nrailways_osm &lt;- opq(my_place, timeout = 300) |&gt;\n  add_osm_feature(key = \"railway\", \n                  value = \"rail\") |&gt;\n  osmdata_sf() |&gt; \n  unname_osmdata_sf()\n\nrailways &lt;- railways_osm$osm_lines |&gt; \n  dplyr::select()\n\nПолучим данные по водным объектам.\n\n\nКод: водные объекты\n\n# water (водные объекты)\nwater_osm &lt;- opq(my_place, timeout = 300) |&gt;\n  add_osm_feature(key = \"natural\", \n                  value = \"water\") |&gt;\n  osmdata_sf() |&gt; \n  unname_osmdata_sf()\n\nriver_osm &lt;- opq(my_place, timeout = 300) |&gt;\n  add_osm_feature(key = \"waterway\", \n                  value = c(\"river\", \n                            \"riverbank\")) |&gt;\n  osmdata_sf() |&gt; \n  unname_osmdata_sf()\n\nwater &lt;- \n  c(water_osm, river_osm) %&gt;%\n  .$osm_multipolygons |&gt;\n  dplyr::select(osm_id, name)\n\nСоздадим базовую карту, нанеся на нее соответствующие объекты.\n\n\nКод: базовая карта\n\nbase_map &lt;- ggplot() +\n  # дорожная сеть\n  geom_sf(data = streets |&gt;\n          dplyr::filter(highway_group == \"large\"),\n          linewidth = 0.4,\n          color = \"grey30\") +\n  geom_sf(data = streets |&gt;\n          dplyr::filter(highway_group == \"medium\"),\n          linewidth = 0.2,\n          color = \"grey35\") +\n  geom_sf(data = streets |&gt;\n          dplyr::filter(highway_group == \"small\"),\n          linewidth = 0.1,\n          color = \"grey40\") +\n  # железные дороги\n  geom_sf(data = railways,\n          color = \"grey30\",\n          linewidth = 0.3,\n          linetype = \"dotdash\",\n          alpha = 0.6) +\n  # водные объекты\n  geom_sf(data = water,\n          fill = \"steelblue\",\n          lwd = 0,\n          alpha = 0.3) +\n  hrbrthemes::theme_ipsum() +\n  theme(plot.margin = ggplot2::margin(0.01, 0.01, 0.01, 0.01, \"cm\"))\n\nКарта-подложка готова, теперь можно использовать ее элементы для отображения всего города или его части. Варьируя границы, мы можем получить карту достаточно подробного масштаба.\nbase_map +\n  # границы города\n  geom_sf(data = boundary_KRSK, \n          color = \"red\",\n          alpha = 0.1) +\n  # ограничения\n  coord_sf(xlim = c(92.64, 93.19), \n           ylim = c(55.90, 56.14),\n           expand = FALSE)\n\n\n\n\n\n\nРисунок 2: OpenStreetMap-карта дорожной сети города Красноярска"
  },
  {
    "objectID": "blog/posts/2021-11-22-reachability/index.html#дополнительные-данные-из-openstreetmap",
    "href": "blog/posts/2021-11-22-reachability/index.html#дополнительные-данные-из-openstreetmap",
    "title": "Анализ географически распределенных объектов городской инфраструктуры",
    "section": "Дополнительные данные из OpenStreetMap",
    "text": "Дополнительные данные из OpenStreetMap\nНапомним, что базовая карта состоит из трех основных составляющих: streets, railways и water. Мы можем использовать информацию из OpenStreetMap для дальнейшего анализа. В частности, переменная speed объекта streets отвечает за максимальную разрешенную скорость для различных транспортных средств.\n\n\nКод: максимальные разрешенные скорости движения\n\n# максимальные разрешенные скорости движения из OpenStreetMap\nstreets_speed &lt;- streets |&gt; \n  # рассмотрим только данные без пропусков\n  dplyr::filter(!is.na(maxspeed)) |&gt; \n  # заменим коды значениями из OSM\n  mutate(maxspeed_new = \n           case_when(\n             maxspeed == \"RU:living_street\" ~ \"20\",\n             maxspeed == \"RU:rural\" ~ \"90\",\n             maxspeed == \"RU:urban\" ~ \"60\",\n             .default = maxspeed\n             )\n           ) \n\n# преобразуем переменные\nstreets_speed$maxspeed_new &lt;- \n  as.numeric(streets_speed$maxspeed_new)\n\n# создадим факторную переменную для скорости\nstreets_speed$max_speed_factor &lt;-\n  factor(streets_speed$maxspeed_new,\n         levels = c(5, 8, 10, 20, 30, 40, 49, 50, 60, 70, 90),\n         labels = c(\"5 км/ч\", \"8 км/ч\", \n                    \"10 км/ч\", \"20 км/ч\", \n                    \"30 км/ч\", \"40 км/ч\", \n                    \"49 км/ч\", \"50 км/ч\", \n                    \"60 км/ч\", \"70 км/ч\", \n                    \"90 км/ч\"))\n\n\nstreets_speed |&gt; \n  st_drop_geometry() %&gt;% \n  count(., max_speed_factor, sort = TRUE)\n\n   max_speed_factor    n\n1           60 км/ч 2556\n2           20 км/ч  394\n3           40 км/ч  357\n4            5 км/ч   83\n5           30 км/ч   26\n6           90 км/ч   22\n7           10 км/ч    6\n8           49 км/ч    1\n9           50 км/ч    1\n10          70 км/ч    1\n11           8 км/ч    1\n\n\n\n\nКод: максимальные разрешенные скорости движения (карта)\n\n# карта: максимальная разрешенная скорость движения\nbase_map +\n  # дорожная сеть\n  geom_sf(data = streets_speed,\n          linewidth = 0.67,\n          aes(color = max_speed_factor)) +\n  viridis::scale_color_viridis(discrete = TRUE,\n                               option = \"turbo\") +\n  # географические границы части города\n  coord_sf(xlim = c(92.8002, 93.0407), \n           ylim = c(55.9823, 56.1003),\n           expand = FALSE) +\n  labs(color = \"максимальная \\nразрешенная \\nскорость\") +\n  theme_void() +\n  theme(text = element_text(size = 14))\n\n\n\n\n\n\n\nРисунок 3: OpenStreetMap-карта дорожной сети города Красноярска с данными по максимально разрешенным скоростям движения\n\n\n\nКак видно из рисунка, база OpenStreetMap содержит неполную информацию по каждому участку дорог. Аналогично можно рассмотреть и визуализировать другие характеристики: дороги с односторонним движением (переменная oneway), тип дорожного покрытия (переменная surface), количество полос движения (переменная lanes) и т.д."
  },
  {
    "objectID": "blog/posts/2021-11-22-reachability/index.html#нанесение-на-карту-города-различных-объектов-и-ограниченных-зон",
    "href": "blog/posts/2021-11-22-reachability/index.html#нанесение-на-карту-города-различных-объектов-и-ограниченных-зон",
    "title": "Анализ географически распределенных объектов городской инфраструктуры",
    "section": "Нанесение на карту города различных объектов и ограниченных зон",
    "text": "Нанесение на карту города различных объектов и ограниченных зон\nНанесем на карту города границы районов. Для этого нужно предварительно загрузить границы из OpenStreetMap, указав значение для ключа admin_level, в нашем случае значение равно 9 в соответствии с кодированием в таблице деления на административные единицы для OpenStreetMap.\n# получение данных по районам города из OSM\ndistricts_osm &lt;- opq(my_place) |&gt;\n  add_osm_feature(key = \"admin_level\", value = 9) |&gt;\n  osmdata_sf() |&gt;\n  unname_osmdata_sf()\nПолучим данные по районам, также выделив площадь каждого района.3\n# границы районов с площадями\ndistricts &lt;- districts_osm %&gt;% \n  .$osm_multipolygons |&gt;\n  dplyr::select(osm_id, name) %&gt;% \n  mutate(area = st_area(.),\n         region_area = as.numeric(area))\nНайдем центроиды районов.\n# центроиды районов\nregions &lt;- cbind(districts, \n                 st_coordinates(st_centroid(districts))) |&gt;\n  rename(c_lon = X, c_lat = Y)\n\n# районы города\nregions\n\nSimple feature collection with 7 features and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 92.62752 ymin: 55.91184 xmax: 93.16844 ymax: 56.13382\nGeodetic CRS:  WGS 84\n   osm_id                  name     area region_area    c_lon    c_lat\n1 5854088 Железнодорожный район 11472481    11472481 92.82686 56.01383\n2 5854089       Кировский район 23189104    23189104 92.96615 55.98596\n3 5854090       Ленинский район 52892774    52892774 93.02779 56.02276\n4 5854091     Октябрьский район 90609016    90609016 92.73413 56.01672\n5 5854092    Свердловский район 75824721    75824721 92.84575 55.96372\n6 5854093       Советский район 88194468    88194468 92.97927 56.07533\n7 5854094     Центральный район 34350926    34350926 92.88060 56.04314\n                            geom\n1 MULTIPOLYGON (((92.84876 56...\n2 MULTIPOLYGON (((92.96183 55...\n3 MULTIPOLYGON (((93.04703 56...\n4 MULTIPOLYGON (((92.66951 55...\n5 MULTIPOLYGON (((92.96183 55...\n6 MULTIPOLYGON (((93.09394 56...\n7 MULTIPOLYGON (((92.84994 56...\n\n\nПриведем карту районов города.4\n\n\nКод: карта районов города\n\n# удалим \"район\" из названия\nregions$name &lt;- str_remove(regions$name, \" район\")\n\nset.seed(2024)\n\nbase_map +\n  # районы города\n  geom_sf(data = regions, \n          aes(fill = region_area / 1000000), \n          color = \"black\", \n          alpha = 0.5) + \n  # цвет\n  viridis::scale_fill_viridis(option = \"plasma\", \n                              direction = 1) +\n  labs(fill = \"площадь района (в кв. км):\", \n       x = \"\", y = \"\") +\n  theme(legend.key.size = unit(0.4,\"cm\"),\n        legend.key.width = unit(1.8,\"cm\"),\n        legend.position = \"top\") +\n  # названия районов\n  ggrepel::geom_text_repel(data = regions, \n                           aes(c_lon, c_lat,\n                               label = name, \n                               color = I(\"black\")), \n                           color = \"white\",     \n                           bg.color = \"grey30\", \n                           bg.r = 0.15,          \n                           size = 5, alpha = 0.9) +\n  # ограничения\n  coord_sf(xlim = c(92.64, 93.19), \n           ylim = c(55.90, 56.14),\n           expand = FALSE) \n\n\n\n\n\n\n\nРисунок 4: OpenStreetMap-карта дорожной сети города Красноярска с районами\n\n\n\nАналогично можно загрузить и отобразить на карте информацию по зданиям и сооружениям.\n# buildings (здания)\nbuildings_osm &lt;- opq(my_place, timeout = 300) |&gt;\n  add_osm_feature(key = \"building\") |&gt;\n  osmdata_sf()\nbuildings_polygons &lt;- buildings_osm %&gt;% \n  .$osm_polygons\n\nbuildings_multipolygons &lt;- buildings_osm %&gt;% \n  .$osm_multipolygons\n\nbuildings &lt;- bind_rows(buildings_polygons, \n                       buildings_multipolygons)\nРассмотрим количество объектов, которые принадлежат улицам города.\n\ncount(buildings |&gt; \n        st_drop_geometry() |&gt; \n        as_tibble(), \n      addr.street, sort = TRUE) |&gt;\n  na.omit()\n\n# A tibble: 1,016 × 2\n   addr.street                                  n\n   &lt;chr&gt;                                    &lt;int&gt;\n 1 проспект им. газеты Красноярский Рабочий   457\n 2 Центральная улица                          401\n 3 Советская улица                            337\n 4 Лесная улица                               334\n 5 улица Калинина                             310\n 6 улица 60 лет Октября                       232\n 7 улица Карла Маркса                         231\n 8 Новая улица                                221\n 9 Базайская улица                            220\n10 улица Березина                             218\n# ℹ 1,006 more rows\n\n\n\n\nКод: улицы города\n\nbase_map +\n  geom_sf(data = buildings, linewidth = 0.15, \n          aes(fill = `addr:street`, \n              color = `addr:street`)) +\n  # географические границы части города\n  coord_sf(xlim = c(92.8492, 93.0487), \n           ylim = c(55.9863, 56.0603),\n           expand = FALSE) +\n  theme_void() +\n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\nРисунок 5: Карта дорожной сети, а также зданий и строений города Красноярска, цвет соответствует принадлежности объектов улицам города\n\n\n\nДругой пример – построим карту, учитывающую этажность зданий.\n\n\nКод: этажность зданий\n\n# этажность\nbase_map +\n  geom_sf(data = buildings |&gt;\n            dplyr::filter(as.numeric(`building:levels`) &gt;= 0) |&gt;\n            mutate(`building:levels` = factor(`building:levels`, \n                                              levels = c(0:26, 29, 30))), \n          linewidth = 0.1,\n          aes(fill = `building:levels`,\n              color = `building:levels`)) +\n  # географические границы города\n  coord_sf(xlim = c(92.88, 92.95), \n           ylim = c(56.02, 56.06),\n           expand = FALSE) +\n  # шкала аннотаций\n  annotation_scale(location = \"br\", \n                   width_hint = 0.5, \n                   style = \"ticks\") +\n  theme(legend.position = \"right\") +\n  viridis::scale_fill_viridis(option = \"turbo\", \n                              discrete = T) +\n  labs(fill = \"этажность\") +\n  guides(color = \"none\") +\n  hrbrthemes::theme_ipsum()\n\n\n\n\n\n\n\nРисунок 6: Карта города Красноярска, цвет соответствует этажности зданий"
  },
  {
    "objectID": "blog/posts/2021-11-22-reachability/index.html#точки-исследования",
    "href": "blog/posts/2021-11-22-reachability/index.html#точки-исследования",
    "title": "Анализ географически распределенных объектов городской инфраструктуры",
    "section": "Точки исследования",
    "text": "Точки исследования\nПомимо карты-подложки нам понадобятся объекты исследования, пусть это будут пожарно-спасательные подразделения, дислоцируемые на территории местного пожарно-спасательного гарнизона (сокращенно ПСЧ). Сформируем точки, которые им соответствуют, это можно сделать случайным образом, например, с помощью команды sf::st_sample(), либо приписать заданным значениям как в нашем случае – центроидам районов города.\n# пожарные части\n# точки выбраны как центроиды районов\nfire_stations &lt;-\nregions |&gt;\n  mutate(name = c(paste(\"ПСЧ\", 1:7, sep = \"-\"))) |&gt;\n  dplyr::select(name, c_lon, c_lat) |&gt;\n  st_drop_geometry() |&gt;\n  as_tibble()\n\nfire_stations\n\n# A tibble: 7 × 3\n  name  c_lon c_lat\n  &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 ПСЧ-1  92.8  56.0\n2 ПСЧ-2  93.0  56.0\n3 ПСЧ-3  93.0  56.0\n4 ПСЧ-4  92.7  56.0\n5 ПСЧ-5  92.8  56.0\n6 ПСЧ-6  93.0  56.1\n7 ПСЧ-7  92.9  56.0\n\n\nОтметим, что в картографии объекты должны рассматриваться в соответствующей географической проекции, которая учитывает искажения Земли. В R библиотека sf позволяет сделать перевод в географическую систему координат CRS (coordinate reference system).\n\n# CRS (coordinate reference system) проекция в EPSG:4326\nfire_stations_sf &lt;- fire_stations |&gt;\n  st_as_sf(coords = c(\"c_lon\", \"c_lat\"), \n           crs = 4326)\n\nfire_stations_sf\n\nSimple feature collection with 7 features and 1 field\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 92.73413 ymin: 55.96372 xmax: 93.02779 ymax: 56.07533\nGeodetic CRS:  WGS 84\n# A tibble: 7 × 2\n  name             geometry\n* &lt;chr&gt;         &lt;POINT [°]&gt;\n1 ПСЧ-1 (92.82686 56.01383)\n2 ПСЧ-2 (92.96615 55.98596)\n3 ПСЧ-3 (93.02779 56.02276)\n4 ПСЧ-4 (92.73413 56.01672)\n5 ПСЧ-5 (92.84575 55.96372)\n6 ПСЧ-6 (92.97927 56.07533)\n7 ПСЧ-7  (92.8806 56.04314)\n\n\nПредположим, что нам необходимо решить задачу распределения районов выезда пожарных частей в терминах евклидова расстояния, без учета движения вдоль дорог и времени движения пожарного автомобиля. Тогда задача решалась бы используя диаграммы Вороного. Напомним, что диаграмма Вороного конечного множества точек S на плоскости представляет такое разбиение плоскости на ячейки, при котором каждая область этого разбиения образует множество точек, более близких к одному из элементов множества S, чем к любому другому элементу множества. Ниже показан пример такого разбиения, альтернативный вариант можно осуществить с помощью библиотеки ggforce.\n\n\nКод: диаграммы Вороного\n\n# диаграммы Вороного\nbase_map +\n  geom_sf(data = fire_stations_sf |&gt;\n            st_combine() |&gt;\n            st_voronoi() |&gt; \n            st_collection_extract() |&gt; \n            st_intersection(boundary_KRSK), \n          color = \"darkblue\",\n          linewidth = 0.7,\n          alpha = 0.01) +\n  # точки с ПСЧ\n  geom_sf(data = fire_stations_sf,\n          color = \"magenta4\", \n          alpha = 1, \n          shape = 8, \n          size = 3, \n          stroke = 1.2) +\n  # маркеры\n  ggrepel::geom_label_repel(data = fire_stations, \n                            aes(c_lon, c_lat, label = name), \n                            fontface = \"bold\",\n                            size = 4, alpha = 0.9) +\n  # географические границы части города\n  coord_sf(xlim = c(92.72, 93.04), \n           ylim = c(55.96, 56.09),\n           expand = FALSE) +\n  # шкала аннотаций\n  annotation_scale(location = \"tl\", \n                   width_hint = 0.5, \n                   style = \"ticks\") +\n  labs(x = \"\", y = \"\")\n\n\n\n\n\n\n\nРисунок 7: Пример разбиения Вороного для пожарно-спасательных подразделений города Красноярска\n\n\n\nВыберем учебные заведений города Красноярска в качестве примера объектов исследования и проанализируем, все ли из этих зданий находятся в 10-минутной зоне доступности из ПСЧ.\n# школы, находящиеся внутри границы города\nschools &lt;- buildings |&gt; \n  dplyr::filter(building %in% c(\"school\")) |&gt; \n  st_intersection(boundary_KRSK)\nВместо самих зданий мы выберем их центроиды.\n# центроиды объектов\nschools_points_KRSK &lt;- st_coordinates(st_centroid(schools)) |&gt;\n  rename(sch_lon = X, sch_lat = Y) |&gt;\n  dplyr::select(sch_lon, sch_lat) |&gt;\n  st_drop_geometry() |&gt;\n  st_as_sf(coords = c(\"sch_lon\", \"sch_lat\"), crs = 4326)"
  },
  {
    "objectID": "blog/posts/2021-11-22-reachability/index.html#достижимость-объектов-на-основе-матрицы-расстояний",
    "href": "blog/posts/2021-11-22-reachability/index.html#достижимость-объектов-на-основе-матрицы-расстояний",
    "title": "Анализ географически распределенных объектов городской инфраструктуры",
    "section": "Достижимость объектов на основе матрицы расстояний",
    "text": "Достижимость объектов на основе матрицы расстояний\nПолучим матрицу расстояний между ПСЧ и учебными заведениями города с использованием библиотеки osrm, являющейся интерфейсом между R и сервисом маршрутизации OSRM на основе OSRM API.\n# матрица расстояний между объектами\ndistancetable = osrmTable(src = fire_stations_sf, \n                          dst = schools_points_KRSK)\nПреобразуем таблицу расстояний.\nschools_distances &lt;-\n  schools_points_KRSK |&gt;\n  mutate(mintime = distancetable$durations |&gt;\n           as_tibble() |&gt; \n           summarise(across(where(is.numeric), min)) |&gt;\n           t() %&gt;% \n           as.vector(.))\n\n\n\n\n\n\nОтметим, что альтернативным подходом для нахождения матрицы, которая отражает расстояния либо время движения между объектами является использование библиотеки r5r – интерфейсу к сервису \\(R^5\\), что расшифровывается как Rapid Realistic Routing on Real-world and Reimagined networks и библиотеки accessibility, которые взяты в основу книги [R.H.M. Pereira, D. Herszenhut].\n\n\n\nНанесем на карту результат, выделив цветом расчетное время прибытия и формой значка те учебные заведения, где время прибытия превысит расчетные 10 минут (треугольник).\n\n\nКод: достижимость объектов\n\nset.seed(2024)\nbase_map + \n  # нанесение школ\n  geom_sf(data = schools_distances, \n          aes(fill = mintime, \n              # форма значка\n              shape = I(ifelse(mintime &gt;= 10, 24, 22))),\n          alpha = 0.95, size = 3.7\n  ) +\n  # цвет\n  viridis::scale_fill_viridis(option = \"turbo\", \n                              breaks = c(1, 5, 10, 15),\n                              labels = c(\"1 мин\", \"5 мин\", \n                                         \"10 мин\", \"15 мин\"),\n           limits = c(0, max(schools_distances$mintime))) +\n  # точки с ПСЧ\n  geom_sf(data = fire_stations_sf,\n          color = \"magenta4\", \n          alpha = 1, \n          shape = 8, \n          size = 3, \n          stroke = 1.2)  +\n  # маркеры\n  ggrepel::geom_label_repel(data = fire_stations, \n                            aes(c_lon, c_lat, label = name), \n                            fontface = \"bold\",\n                            size = 4, alpha = 0.9) +\n  # географические границы части города\n  coord_sf(xlim = c(92.79, 93.04), \n           ylim = c(55.97, 56.08),\n           expand = FALSE) +\n  # шкала аннотаций\n  annotation_scale(location = \"tl\", \n                   width_hint = 0.5, \n                   style = \"ticks\")  +\n  # оформление темы\n  theme(legend.key.size = unit(0.5,\"cm\"),\n        legend.key.width = unit(2,\"cm\"),\n        legend.position = \"top\",\n        plot.margin = ggplot2::margin(0.01, 0.01, 0.01, 0.01, \"cm\")) +\n  labs(x = \"\", y = \"\",\n       fill = \"время прибытия:\")\n\n\n\n\n\n\n\nРисунок 8: Достижимость общеобразовательных учебных заведений из пожарно-спасательных подразделений г. Красноярска, цвет соответствует времени прибытия, значки соответствуют временному порогу &gt; 10 минут\n\n\n\nОчевидно, что не все учебные заведения города при данной условной расстановке ПСЧ являются достижимыми за отведенное время 10 минут.\n\nschools_distances |&gt;\n  mutate(\n    late_category = case_when(\n      mintime &gt;  10 ~ \"&gt; 10 мин\",\n      mintime &lt;= 10 ~ \"&lt;= 10 мин\"\n    )\n  ) |&gt;\n  janitor::tabyl(late_category) |&gt;\n  janitor::adorn_pct_formatting(digits = 0) |&gt;\n  purrr::set_names(\"категория\", \"количество\", \"процент\")\n\n категория количество процент\n &lt;= 10 мин        154     81%\n  &gt; 10 мин         36     19%\n\n\n\n\n\n\n\n\nНесмотря на то, что мы решили задачу по анализу и визуализации доступности объектов относительно выбраанных объектов, наше решение обладает рядом существенных недостатков. Во-первых, для большого количества объектов мы не сможем осуществить большой объем запросов (максимум – один запрос в секунду, никакого веб-скреппинга и т.д.). Кроме того, здесь мы не можем самостоятельно настраивать скорости движения автомобиля по различным типам дорог.\nОдним из оптимальных решений является упрощение дорожной сети с помощью библиотек sfnetworks, dodgr, либо OSMnx в Python до графа дорожной сети, что делает настройки более гибкими и позволяет использовтаь алгоритмы теории графов. Этот подход будет рассмотрен в другой статье."
  },
  {
    "objectID": "blog/posts/2021-11-22-reachability/index.html#построение-оптимальных-маршрутов",
    "href": "blog/posts/2021-11-22-reachability/index.html#построение-оптимальных-маршрутов",
    "title": "Анализ географически распределенных объектов городской инфраструктуры",
    "section": "Построение оптимальных маршрутов",
    "text": "Построение оптимальных маршрутов\nПокажем, как можно строить оптимальные маршруты с помощью библиотеке osrm. Выберем две произвольных точки, которые будут соответствовать учебному заведению и пожарной части.\nset.seed(2024)\nfire_stations_sample &lt;- fire_stations_sf |&gt;\n  sample_n(1)\n\nschools_sample &lt;- schools_points_KRSK |&gt;\n  mutate(id = row_number()) |&gt;\n  sample_n(1)\nПостроим оптимальный маршрут движения между от первой до второй выбранной точки пользуясь командой osrmRoute.\nroute &lt;- osrmRoute(src = fire_stations_sample, \n                   dst = schools_sample,\n                   overview = \"full\")\n\nroute\n\nSimple feature collection with 1 feature and 4 fields\nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 92.78692 ymin: 55.97694 xmax: 92.96585 ymax: 56.01863\nGeodetic CRS:  WGS 84\n  src dst duration distance                           geom\n1   1   1    22.28  16.3655 LINESTRING (92.96585 55.985...\n\n\nМы видим, что команда osrmRoute() нашла расчетное время движения duration и длинуdistance маршрута. На карте ниже можно увидеть построенный маршрут.\n\n\nКод: построение маршрута\n\n# построение маршрута\nset.seed(2024)\nbase_map + \n  # здания\n  geom_sf(data = buildings, linewidth = 0.05) +\n  # маршрут\n  geom_sf(data = route, \n          color = \"red\", \n          linewidth = 1) +\n  # ПСЧ -- исходная точка\n  geom_sf(data = fire_stations_sample,\n          color = \"magenta4\", \n          alpha = 1, \n          shape = 8, \n          size = 3, \n          stroke = 1.3) +\n  # школа -- конечная точка\n  geom_sf(data = schools_sample,\n          color = \"darkblue\", \n          alpha = 1, \n          shape = 8, \n          size = 3,\n          stroke = 1.3) +\n  # ярлык\n  geom_sf_label(data = fire_stations_sample, \n                aes(label = name),\n                nudge_y = -0.003, \n                fontface = \"bold\",\n                size = 4, alpha = 0.9) +\n  # географические границы города\n  coord_sf(xlim = c(92.77, 92.99), \n           ylim = c(55.97, 56.03),\n           expand = FALSE) +\n  theme_void() +\n  labs(x = \"\", y = \"\")\n\n\n\n\n\n\n\nРисунок 9: Пример построения оптимального маршрута\n\n\n\n\n\n\n\n\n\nЗаметим, что фукция osrmIsochrone() в osrm позволяет находить изохроны (области, ограниченные фиксированным временем движения), тем не менее, она обладает теми же недостатками, о которых говорилось выше; кроме того, область построения изохроны может быть неодносвязной, некорректно вычисляться и т.д., даже несмотря на варьирования параметра res отвечающего за разрешение."
  },
  {
    "objectID": "blog/posts/2021-11-22-reachability/index.html#footnotes",
    "href": "blog/posts/2021-11-22-reachability/index.html#footnotes",
    "title": "Анализ географически распределенных объектов городской инфраструктуры",
    "section": "Сноски",
    "text": "Сноски\n\n\nМожно также установить глобальную опцию options(timeout = max(300, getOption(\"timeout\"))).↩︎\nДанные по дорожной сети из OSM могут содержать некорректные объекты, например, объектам могут соответствовать неверные координаты, что может приводит к смещениям объектов. В этом случае все неточности можно исправить с помощью функций библиотеки sf.↩︎\nОтметим, что для некоторых населенных пунктов также следует рассмотреть .$osm_polygons при нахождении границ районов.↩︎\nДля некоторых городов (например, Новосибирска) районы могут быть разделены на несколько компонентов, что нужно учитывать при нахождении центроидов и нанесение их на карты.↩︎"
  },
  {
    "objectID": "blog/posts/2022-02-21-sfnetworks/index.html#базовая-карта",
    "href": "blog/posts/2022-02-21-sfnetworks/index.html#базовая-карта",
    "title": "Анализ графа дорожной сети",
    "section": "Базовая карта",
    "text": "Базовая карта\n\n\n\n\n\n\nВ своем исследовании мы будем опираться на результат предыдущей записи блога, в котором были получены картографические данные дорожной сети города (в нашем случае это г. Красноярск). Соответственно, данные и переменные относятся к предыдущей статье.\n\n\n\nДопустим, что с помощью библиотеки osmdata мы загрузили необходимые данные из OpenStreetMap, визуализируем их.\nbase_map +\n  # географические границы части города\n  coord_sf(xlim = c(92.75, 93.04), \n           ylim = c(55.98, 56.09),\n           expand = FALSE) +\n  # шкала аннотаций\n  annotation_scale(location = \"tl\", \n                   width_hint = 0.5, \n                   style = \"ticks\") +\n  theme_void()\n\n\n\n\n\n\nРисунок 1: Карта дорожной сети города на основе данных OpenStreetMap"
  },
  {
    "objectID": "blog/posts/2022-02-21-sfnetworks/index.html#граф-дорожной-сети",
    "href": "blog/posts/2022-02-21-sfnetworks/index.html#граф-дорожной-сети",
    "title": "Анализ графа дорожной сети",
    "section": "Граф дорожной сети",
    "text": "Граф дорожной сети\nПредположим, что основной объект, который мы загрузили из OpenStreetMap, отвечающий за дорожную сеть носит название streets. Выделим только объекты стандарта Simple feature (см. также [Т.Е. Самсонов]), которые имеют тип LINESTRING.\nstreets_lines &lt;- streets |&gt;\n  dplyr::select(osm_id, \n                oneway, \n                highway) %&gt;% \n  filter(\n    st_geometry_type(.)\n    %in% c(\"LINESTRING\")\n  )\nЗатем, аналогично [Т.Е. Самсонов] и [Dealing with one-way edges] продублируем линии, не соответствующие дорогам с односторонним движением для того, чтобы имитировать дороги с двусторонним движением.\nstreets_double_lanes &lt;- streets_lines |&gt;\n  filter(is.na(oneway) | oneway != \"yes\") |&gt;\n  st_reverse() |&gt;\n  bind_rows(streets_lines)\nЗагрузим библиотеку sfnetworks.\n\nlibrary(sfnetworks)\n\n# работа с графами в R\nlibrary(tidygraph)\n\nТеперь, чтобы сделать граф из дорожной сети, нужна буквально одна команда из библиотеки sfnetworks.\n\nnet &lt;- as_sfnetwork(streets_double_lanes) |&gt;\n  # географическая проекция\n  st_transform(4326)\n\nПолучившийся граф, который соответствует дорожной сети, представляет собой tidy-формат с сохранением геометрических свойств, где каждое наблюдение имеет свое местоположение в географическом пространстве.\n\n\nnet\n\n# A sfnetwork with 32911 nodes and 79928 edges\n#\n# CRS:  EPSG:4326 \n#\n# A directed multigraph with 12117 components with spatially explicit edges\n#\n# A tibble: 32,911 × 1\n                 geom\n          &lt;POINT [°]&gt;\n1 (93.00469 56.06684)\n2 (92.99103 56.06949)\n3 (93.01373 56.06508)\n4 (93.02202 56.06271)\n5 (93.02498 56.06045)\n6  (93.0251 56.06319)\n# ℹ 32,905 more rows\n#\n# A tibble: 79,928 × 6\n   from    to osm_id   oneway highway                                       geom\n  &lt;int&gt; &lt;int&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;                             &lt;LINESTRING [°]&gt;\n1     1     2 25375397 &lt;NA&gt;   primary (93.00469 56.06684, 93.00009 56.06774, 92…\n2     3     4 25375423 &lt;NA&gt;   primary (93.01373 56.06508, 93.01632 56.06459, 93…\n3     1     3 25375424 &lt;NA&gt;   primary     (93.00469 56.06684, 93.01373 56.06508)\n# ℹ 79,925 more rows\n\n\n\nНанесем поверх дорожной сети получившийся граф. Как видно, практически вся дорожная сеть покрывается графом.\n\n\nКод: граф дорожной сети\n\nbase_map + \n  # здания и строения\n  geom_sf(data = buildings, linewidth = 0.15) +\n  # ребра графа\n  geom_sf(data = st_as_sf(net, \"edges\"), \n          col = \"red\", alpha = 0.4) +\n  # вершины графа\n  geom_sf(data = st_as_sf(net, \"nodes\"), \n          col = \"maroon\", alpha = 0.4, \n          size = 0.8) +\n  # географические границы части города\n  coord_sf(xlim = c(92.87, 92.98), \n           ylim = c(56.03, 56.07),\n           expand = FALSE)\n\n\n\n\n\n\n\nРисунок 2: Граф дорожной сети города Красноярска, также показаны здания и строения"
  },
  {
    "objectID": "blog/posts/2022-02-21-sfnetworks/index.html#сглаживание-графа-дорожной-сети",
    "href": "blog/posts/2022-02-21-sfnetworks/index.html#сглаживание-графа-дорожной-сети",
    "title": "Анализ графа дорожной сети",
    "section": "Сглаживание графа дорожной сети",
    "text": "Сглаживание графа дорожной сети\nПостроенный граф может содержать узлы, имеющие только одно входящее и одно выходящее ребро. Для таких задач, как вычисление кратчайших путей, такие узлы избыточны, поскольку они не представляют собой точки, откуда могут быть выбраны разные направления для ориентированных графов, либо, в неориентированных графах, это могут быть любые узлы только с двумя инцидентными ребрами. Такого рода узлы мы назовем псевдоузлами. Для уменьшения сложности графа в последующих операциях их удаляют, проводя процедуру сглаживания. Функция to_spatial_smooth() итеративно сглаживает псевдоузлы и после каждого удаления объединяет геометрии строк двух затронутых ребер вместе в новую геометрию одной строки. Также, учтем тип дорог для инцидентных ребер.\nlibrary(tidygraph)\n\nsmoothed_net &lt;- convert(net, to_spatial_smooth, \n                        require_equal = \"highway\")\n\n\nКод: сглаженный граф дорожной сети\n\n# пространственное сглаживание\nbase_map + \n  # здания и сооружения\n  geom_sf(data = buildings, linewidth = 0.15) +\n  # ребра графа\n  geom_sf(data = st_as_sf(smoothed_net, \"edges\"), \n          col = \"red\", \n          linewidth = 0.7,\n          alpha = 0.4) +\n  # вершины графа\n  geom_sf(data = st_as_sf(smoothed_net, \"nodes\"), \n          col = \"maroon\", alpha = 0.4, \n          size = 0.8) +\n  # географические границы части города\n  coord_sf(xlim = c(92.87, 92.98), \n           ylim = c(56.03, 56.07),\n           expand = FALSE) + \n  theme_void()\n\n\n\n\n\n\n\nРисунок 3: Сглаженный граф дорожной сети города Красноярска"
  },
  {
    "objectID": "blog/posts/2022-02-21-sfnetworks/index.html#пространственная-фильтрация-графа-дорожной-сети",
    "href": "blog/posts/2022-02-21-sfnetworks/index.html#пространственная-фильтрация-графа-дорожной-сети",
    "title": "Анализ графа дорожной сети",
    "section": "Пространственная фильтрация графа дорожной сети",
    "text": "Пространственная фильтрация графа дорожной сети\nМы можем сделать пространственную фильтрацию полученного графа на основе пространственных отношений. Например, можно задать прямоугольник, по которому необходимо обрезать граф.\n# полигон для кропа\ncrop_polygon &lt;- \ntibble(lon = c(92.87, 92.98), \n       lat = c(56.03, 56.07)) |&gt;\n  st_as_sf(coords = c(\"lon\", \"lat\"), \n           crs = 4326) |&gt;\n  st_bbox() |&gt;\n  st_as_sfc()\n# кроп по полигону\nnet_polygon_filtered &lt;- st_filter(net, crop_polygon)\n\n\nКод: пример пространственной фильтрации графа дорожной сети\n\nmy_epsilon = 0.01\n\n# пространственная фильтрация по прямоугольнику\nbase_map + \n  # здания и сооружения\n  geom_sf(data = buildings, linewidth = 0.1) +\n  # граница прямоугольника\n  geom_sf(data = crop_polygon, \n          alpha = 0.2,\n          linewidth = 0.8,\n          color = \"black\") +\n  # ребра графа\n  geom_sf(data = st_as_sf(net_polygon_filtered, \"edges\"), \n          col = \"red\", alpha = 0.4) +\n  # вершины графа\n  geom_sf(data = st_as_sf(net_polygon_filtered, \"nodes\"), \n          col = \"maroon\", alpha = 0.4, \n          size = 0.7) +\n  # географические границы части города\n  coord_sf(xlim = c(92.87-my_epsilon, 92.98+my_epsilon), \n           ylim = c(56.03-my_epsilon/2, 56.07+my_epsilon/2),\n           expand = FALSE) +\n  theme_void()\n\n\n\n\n\n\n\nРисунок 4: Пример пространственной фильтрации графа дорожной сети города Красноярска\n\n\n\nНемного более интересный случай касается районирования. Скажем, пусть граф необходимо рассмотреть только выбранном регионе (районе города и т.д.).\n# здесь можно указать любой другой город\nmy_place &lt;- \"Krasnojarsk Russia\"\n\n# получение данных по районам города из OSM\ndistricts_osm &lt;- opq(my_place) |&gt;\n  add_osm_feature(key = \"admin_level\", value = 9) |&gt;\n  osmdata_sf() |&gt;\n  unname_osmdata_sf()\n# границы районов города\ndistricts &lt;- districts_osm %&gt;% \n  .$osm_multipolygons |&gt;\n  dplyr::select(osm_id, name)\n\n# необходимый район города\ncrop_region &lt;- districts |&gt;\n  dplyr::filter(name == \"Ленинский район\")\n# фильтрация по району города\nfiltered_region &lt;- st_filter(net, crop_region)\n\n\nКод: пример пространственной фильтрации графа по району города\n\n# фильтрация по району города\nbase_map + \n  # здания и сооружения\n  geom_sf(data = buildings,\n          linewidth = 0.06,\n          alpha = 0.7) +\n  # границы района\n  geom_sf(data = crop_region, \n          alpha = 0.2,\n          linewidth = 0.8,\n          color = \"black\") +\n  # ребра графа\n  geom_sf(data = st_as_sf(filtered_region, \"edges\"), \n          col = \"red\", \n          linewidth = 0.4,\n          alpha = 0.3) +\n  # вершины графа\n  geom_sf(data = st_as_sf(filtered_region, \"nodes\"), \n          col = \"maroon\", alpha = 0.35, \n          size = 0.3) +\n  # ограничения\n  coord_sf(xlim = c(92.93, 93.12), \n           ylim = c(55.97, 56.07),\n           expand = FALSE) +\n  theme_void()\n\n\n\n\n\n\n\nРисунок 5: Пример пространственной фильтрации графа дорожной сети города Красноярска по району"
  },
  {
    "objectID": "blog/posts/2022-02-21-sfnetworks/index.html#понятие-центральности",
    "href": "blog/posts/2022-02-21-sfnetworks/index.html#понятие-центральности",
    "title": "Анализ графа дорожной сети",
    "section": "Понятие центральности",
    "text": "Понятие центральности\nРассмотрим понятие центральности узла графа. Показатель центральности или близости к центру в теории графов и анализе сетей определяет наиболее влиятельные вершины графа. Существует множество различных определений центральности. Например, функция centrality_betweenness() вводит понятие центральности по промежуточности, которое определяется количеством геодезических (кратчайших путей), проходящих через вершину (ребро). Таким образом, мы можем выделить наиболее важные перекрестки (дороги) через которые проходит наибольший транспортный поток.\nНапример, для фиксированного узла \\(u\\) графа, пусть \\(\\sigma_{vw}(u)\\) обозначает число кратчайших путей из узла \\(v\\) в узел \\(w\\) проходящих через данный узел \\(u\\). Тогда, показатель центральности можно вычислить как \\[\nB(u) = \\sum_{v \\not = w, v\\not = u, w \\not = u}\n\\frac{\\sigma_{vw}(u)}{\\sigma_{vw}},\n\\] где \\(\\sigma_{vw}\\) – общее число всех кратчайших путей из узла \\(v\\) в узел \\(w\\).\nЧтобы понять, какую “подтаблицу” мы используем в tidy-версии нашего графа (состоящего из двух таблиц), нам понадобится глагол active – функция запроса для получения текущего активного контекста. Найдем центральность узлов и визуально представим результат.\n\nnet_bc &lt;- net |&gt;\n  activate(\"nodes\") |&gt;\n  # центральность по промежуточности\n  mutate(bc = centrality_betweenness()) |&gt;\n  # ранжируем индекс\n  # это необходимо для наложений на карте\n  # чтобы точки с большим индексом были наверху\n  arrange(bc)\n\nВыделим точку с максимальным значением центральности.\n\nnet_max_bc &lt;- st_coordinates(net_bc) |&gt;\n  as_tibble() |&gt;\n  rename(lon = X, lat = Y) %&gt;%\n  cbind(., net_bc) |&gt;\n  as_tibble() |&gt;\n  slice_max(bc, n = 1) |&gt;\n  st_as_sf(coords = c(\"lon\", \"lat\"), crs = 4326)\n\n\nnet_max_bc\n\nSimple feature collection with 1 feature and 1 field\nActive geometry column: geometry\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 92.83334 ymin: 56.02463 xmax: 92.83334 ymax: 56.02463\nGeodetic CRS:  WGS 84\n# A tibble: 1 × 3\n                 geom       bc            geometry\n*         &lt;POINT [°]&gt;    &lt;dbl&gt;         &lt;POINT [°]&gt;\n1 (92.83334 56.02463) 3300777. (92.83334 56.02463)\n\n\nДля отображения результата на карте мы также сделаем подготовительную работу чтобы увеличить часть карты. Это можно сделать в библиотеке ggmagnify, но в данном случае используется библиотека ggmapinset.\nlibrary(ggmapinset)\n\n# подготовительная часть для картографической сноски\nKRSK_inset &lt;- configure_inset(\n  centre = st_as_sfc(net_max_bc), \n  scale = 1.35,\n  translation = c(0, 5.5), \n  radius = 1.5, \n  units = \"km\"\n)\n\n\nКод: центральность вершин графа\n\n# центральность вершин графа\nbase_map + \n  # вершины\n  geom_sf(data = st_as_sf(net_bc, \"nodes\"), \n          aes(color = bc / 10^6, \n              size = bc / 10^6, \n              alpha = bc / 10^6)) + \n  theme_void() +\n  # *_inset: для отображения в сноске\n  # элементы дороги\n  geom_sf_inset(data = streets |&gt;\n                  dplyr::filter(highway_group == \"large\"),\n                linewidth = 0.4,\n                color = \"grey30\") +\n  geom_sf_inset(data = streets |&gt;\n                  dplyr::filter(highway_group == \"medium\"),\n                linewidth = 0.2,\n                color = \"grey35\") +\n  geom_sf_inset(data = streets |&gt;\n            dplyr::filter(highway_group == \"small\"),\n          linewidth = 0.1,\n          color = \"grey40\") +\n  # железные дороги\n  geom_sf_inset(data = railways,\n          color = \"grey30\",\n          linewidth = 0.3,\n          linetype = \"dotdash\",\n          alpha = 0.6) +\n  # вершины\n  geom_sf_inset(data = st_as_sf(net_bc, \"nodes\"), \n                aes(col = bc / 10^6, \n                    size = bc / 10^6, \n                    alpha = bc / 10^6)) +\n  viridis::scale_color_viridis(option = \"magma\", \n                               direction = -1) +\n  # цвет и толщина линии сноски\n  geom_inset_frame(linewidth = 0.8,\n                   color = \"black\") +\n  # границы части города\n  coord_sf_inset(xlim = c(92.76, 92.99),\n                 ylim = c(55.98, 56.09), \n                 inset = KRSK_inset) +\n  # легенда\n  # легенда\n  labs(size = \"bc\", \n       color = \"bc\") +\n  # tweak: убирает alpha из легенды\n  guides(alpha = \"none\")\n\n\n\n\n\n\n\nРисунок 6: Центральность по промежуточности вершин графа дорожной сети г. Красноярска. Показатель центральности равен \\(bc\\cdot 10^6\\) (чем темнее и больше изображена вершина, тем больше значение показателя)\n\n\n\n\n\n\n\n\n\nПерекрестки с высоким индексом, как правило, являются главными кандидатами на возможное наличие заторов. Например, в данном случае максимальное значение индекса у перекрестка проспекта Свободный и улицы Маерчака, также высокие значения имеют развязки улиц Брянская, 2-я Брянская, Калинина и Маерчака, кроме того, как можно было предположить, высокие значения у элементов дороги на мостах и подъездах к мостам.\n\n\n\nТеперь рассмотрим сетевую проходимость ребер графа дорожной сети. С помощью команды centrality_edge_betweenness() присвоим каждому ребру индекс центральности. Отметим, что здесь мы не должны рассматривать кратные ребра, иначе это может привести к некорректному результату (см. [Vertex and edge betweenness centrality]).\nnet_bc_edges &lt;- as_sfnetwork(streets_lines) |&gt;\n  # географическая проекция\n  st_transform(4326) |&gt;\n  activate(\"edges\") |&gt;\n  filter(!edge_is_multiple()) |&gt;\n  filter(!edge_is_loop()) |&gt;\n  mutate(bc_edges = centrality_edge_betweenness()) |&gt;\n  arrange(bc_edges)\n\n\nКод: центральность ребер графа\n\nbase_map + \n  # здания и строения\n  geom_sf(data = buildings, linewidth = 0.07) +\n  # ребра\n  geom_sf(data = st_as_sf(net_bc_edges, \"edges\"), \n          aes(color = bc_edges / 10^4, \n              alpha = bc_edges / 10^4, \n              linewidth = bc_edges / 10^4)) +\n  theme_void(base_size = 14) +\n  # границы части города\n  coord_sf(xlim = c(92.820, 92.965),\n           ylim = c(55.985, 56.040)) +\n  viridis::scale_color_viridis(option = \"inferno\", \n                               direction = -1) +\n  # легенда\n  labs(color = \"Центральность ребер графа / 10 000\") +\n  # tweak: убирает элементы из легенды\n  guides(alpha = \"none\", linewidth = \"none\") +\n  # легенда: цвет\n  guides(color = guide_colorbar(title.position = 'top', \n                                title.hjust = 0.5,\n                                barwidth = unit(14, 'lines'), \n                                barheight = unit(0.7, 'lines'))) +\n  theme(legend.position = \"top\")\n\n\n\n\n\n\n\nРисунок 7: Центральность по промежуточности ребер графа дорожной сети г. Красноярска. Показатель центральности тем больше, чем темнее цвет ребра\n\n\n\n\n\n\n\n\n\nМы видим, что в случае выше наиболее высокие значения центральности по промежуточности приходятся на центральные улицы города: Ленина, Партизана Железняка, Шахтеров, проспект Красноярский рабочий, а также мосты, соединяющие берега города. Как правило, это именно те улицы города, которые являются наиболее загруженными в часы пик."
  },
  {
    "objectID": "blog/posts/2022-02-21-sfnetworks/index.html#связность-графа",
    "href": "blog/posts/2022-02-21-sfnetworks/index.html#связность-графа",
    "title": "Анализ графа дорожной сети",
    "section": "Связность графа",
    "text": "Связность графа\nГраф дорожной сети может содержать большое количество компонентов, которые не связаны между собой. В связи с этим могут возникнуть трудности при исследовании вопросов достижимости, поскольку из некоторого узла можно попасть только в нескольких ближайших соседей. В таких случаях возможно сначала сократить сеть до ее самого большого (или самых больших) компонента(ов), прежде чем вычислять кратчайшие пути. Найдем самую большую связную компоненту нашего графа. Функция group_components() присваивает целое число, которое идентифицирует компоненту каждому узлу в котором она находится, причем 1 соответствует самой большой связной компонентое в сети, 2 – второй по величине компоненте и так далее.\n\n\n\n\n\n\nДля корректного построения графа дорожной сети рекомендуется сначала округлить координаты геометрических компонентов для устранения ошибок в пристыковке линий, например, как в [Rounding coordinates] или в [Т.Е. Самсонов]. В нашем случае мы не проводили данную операцию в связи с тем, что граф имеет достаточно большую размерность.\n\n\n\nНайдем общее количество компонент исходного графа.\n\n# количество связных компонент\nwith_graph(net, graph_component_count())\n\n[1] 12117\n\n\nВыделим первую (самую большую) связную компоненту графа и изобразим ее.\n\n# главная связная компонента\nnet_connected_comp &lt;- net |&gt;\n  activate(\"nodes\") |&gt;\n  filter(group_components() == 1)\n\n# только одна связная компонента\nwith_graph(net_connected_comp, graph_component_count())\n\n[1] 1\n\n\n\n\nКод: главная связная компонента графа дорожной сети\n\nbase_map + \n  # здания и строения\n  geom_sf(data = buildings, linewidth = 0.07) +\n  # ребра\n  geom_sf(data = st_as_sf(net, \"edges\"), \n          color = \"blue\",\n          linewidth = 0.2,\n          alpha = 0.6) +\n  # вершины\n  geom_sf(data = st_as_sf(net, \"nodes\"), \n          color = \"blue\",\n          size = 0.3,\n          alpha = 0.6) +\n  # ребра\n  geom_sf(data = st_as_sf(net_connected_comp, \"edges\"), \n          color = \"red\",\n          linewidth = 0.5,\n          alpha = 0.9) +\n  # вершины\n  geom_sf(data = st_as_sf(net_connected_comp, \"nodes\"), \n          color = \"red\",\n          size = 0.6,\n          alpha = 0.9) +\n  theme_void() +\n  # географические границы части города\n  coord_sf(xlim = c(92.87, 92.98), \n           ylim = c(56.03, 56.07),\n           expand = FALSE)\n\n\n\n\n\n\n\nРисунок 8: Главная связная компонента графа дорожной сети (выделена красным цветом)"
  },
  {
    "objectID": "blog/posts/2022-02-21-sfnetworks/index.html#нахождение-кластеров",
    "href": "blog/posts/2022-02-21-sfnetworks/index.html#нахождение-кластеров",
    "title": "Анализ графа дорожной сети",
    "section": "Нахождение кластеров",
    "text": "Нахождение кластеров\nСуществует множество различных алгоритмов для кластеризации узлов графа. Ниже используется метод Лувена для обнаружения кластеров (или по-другому сообществ). Нахождение кластеров может быть полезным при группировке смежных вершин графа, например, когда следует дать первоначальную оценку смежным районам города по близости перекрестков.\n# только неориентированные графы\nnet_custered &lt;- as_sfnetwork(streets_lines, directed = FALSE) |&gt; \n  # географическая проекция\n  st_transform(4326) |&gt;\n  activate(\"nodes\") |&gt; \n  mutate(comp = group_components()) |&gt;\n  dplyr::filter(comp == 1) |&gt;\n  mutate(louvain = as.factor(group_louvain()))\n\n\nКод: нахождение кластеров\n\nbase_map + \n  # здания и строения\n  geom_sf(data = buildings, linewidth = 0.05) +\n  # ребра\n  geom_sf(data = st_as_sf(net_custered, \"edges\"), \n          color = \"grey60\",\n          linewidth = 0.5,\n          alpha = 0.5) +\n  # вершины\n  geom_sf(data = st_as_sf(net_custered, \"nodes\"), \n          aes(fill = louvain),\n          size = 1.4,\n          pch = 21,\n          color = \"grey20\",\n          linewidth = 0.01,\n          alpha = 0.8) +\n  theme_void() +\n  viridis::scale_fill_viridis(discrete = TRUE,\n                               option = \"turbo\") +\n  # географические границы части города\n  coord_sf(xlim = c(92.80, 93.00), \n           ylim = c(56.00, 56.07),\n           expand = FALSE) +\n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\nРисунок 9: Кластеры для главной связной компоненты графа дорожной сети\n\n\n\nАльтернативные методы кластеризации в R можно использовать, например, с помощью библиотеки tidyclust или библиотеки spatialsample, которая служит для кросс-валидации географических данных в tidymodels и пространственной кластеризации с возможным учетом буферных зон. В следующем примере используем метод иерархической кластеризации для поиска кластеров.\nset.seed(123)\nlibrary(spatialsample)\n\n# кластеризация\nh_clust &lt;-\nspatial_clustering_cv(st_as_sf(filtered_region, \"nodes\"), \n  v = 5, \n  cluster_function = \"hclust\") |&gt; \n  autoplot(size = 0.8) \n\n\nКод: пространственная кластеризация\n\n# кластеризация\nh_clust &lt;-\nspatial_clustering_cv(st_as_sf(filtered_region, \"nodes\"), \n  v = 5, \n  cluster_function = \"hclust\") |&gt; \n  autoplot(size = 0.8) +\n  # дорожная сеть\n  geom_sf(data = streets |&gt;\n            dplyr::filter(highway_group == \"large\"),\n          linewidth = 0.4,\n          color = \"grey30\") +\n  geom_sf(data = streets |&gt;\n            dplyr::filter(highway_group == \"medium\"),\n          linewidth = 0.2,\n          color = \"grey35\") +\n  geom_sf(data = streets |&gt;\n            dplyr::filter(highway_group == \"small\"),\n          linewidth = 0.1,\n          color = \"grey40\") +\n  # железные дороги\n  geom_sf(data = railways,\n          color = \"grey30\",\n          linewidth = 0.3,\n          linetype = \"dotdash\",\n          alpha = 0.6) +\n  # водные объекты\n  geom_sf(data = water,\n          fill = \"steelblue\",\n          lwd = 0,\n          alpha = 0.3) +\n  # здания и сооружения\n  geom_sf(data = buildings,\n          linewidth = 0.06,\n          alpha = 0.7)\n\n# кластеризация\ngg_clust + \n  # ребра графа\n  geom_sf(data = st_as_sf(filtered_region, \"edges\"), \n          col = \"black\", \n          linewidth = 0.3,\n          alpha = 0.3) +\n  # границы района\n  geom_sf(data = crop_region, \n          alpha = 0.2,\n          linewidth = 0.8,\n          color = \"black\") +\n  # цвет\n  ggsci::scale_color_d3() +\n  theme_void() +\n  theme(legend.position = \"none\") +\n  # ограничения\n  coord_sf(xlim = c(92.93, 93.12), \n           ylim = c(55.97, 56.07),\n           expand = FALSE)\n\n\n\n\n\n\n\nРисунок 10: Пример пространственной кластеризации (5 кластеров) вершин графа дорожной сети с помощью метода hclust"
  },
  {
    "objectID": "blog/posts/2022-02-21-sfnetworks/index.html#ориентация-городской-уличной-сети",
    "href": "blog/posts/2022-02-21-sfnetworks/index.html#ориентация-городской-уличной-сети",
    "title": "Анализ графа дорожной сети",
    "section": "Ориентация городской уличной сети",
    "text": "Ориентация городской уличной сети\nБольшую роль в планировании городской транспортной инфраструктуры играет не только связность, но и ориентации уличной сети. Ориентация, конфигурация и энтропия уличной сети исследовалась в работе [G. Boeing] на основе данных OpenStreetMap и библиотеки OSMnx языка программирования Python.\nФункция edge_azimuth() вычисляет угол в радианах между последовательностями точек, а именно: между прямой линией от начальной точки ребра, указывающей на север, и направлением от начальной точки до конечной точки ребра.\n\n# вычисление азимутального направления\nazimuth_net &lt;- net |&gt;\n  activate(\"edges\") |&gt;\n  morph(to_spatial_transformed, 4326) |&gt;\n  mutate(azimuth = edge_azimuth()) |&gt;\n  unmorph()\n\n\nazimuth_net |&gt;\n  pull(azimuth) |&gt; \n  as_tibble()\n\n# A tibble: 79,928 × 1\n     value\n     [rad]\n 1 -1.24  \n 2  2.04  \n 3  1.91  \n 4  0.0250\n 5 -0.516 \n 6  2.43  \n 7 -1.93  \n 8  2.87  \n 9  1.58  \n10  1.40  \n# ℹ 79,918 more rows\n\n\nИспользуем полученные данные для отображения ориентации дорожной сети и сложности застройки.\n\n\nКод: ориентации дорожной сети\n\nbase_map + \n  # ребра графа\n  geom_sf(data = st_as_sf(azimuth_net, \"edges\"), \n                   aes(color = as.numeric(azimuth)), \n                   alpha = 0.7,\n          linewidth = 0.65) +\n  # градиент\n  scale_colour_gradient2(\n    low = \"#009593\",\n    mid = \"white\",\n    high = \"#D48444\",\n    midpoint = 0,\n    name = \"азимутальное направление (рад):\") +\n  # географические границы части города\n  coord_sf(xlim = c(92.87, 92.98), \n           ylim = c(56.03, 56.07),\n           expand = FALSE) +\n  theme_void() +\n  # легенда\n  theme(legend.position = \"bottom\",\n        legend.title = element_text(size = rel(1.2),\n                                    family = \"IBM Plex Sans\"),\n        legend.text = element_text(size = rel(1.2),\n                                   family = \"IBM Plex Sans\")) +\n  guides(color = guide_colorbar(title.position = 'top', \n                                title.hjust = 0.5,\n                                barwidth = unit(17, 'lines'), \n                                barheight = unit(0.8, 'lines')))\n\n\n\n\n\n\n\nРисунок 11: Азимутальное направление улиц, построенное по графу дорожной сети г. Красноярска\n\n\n\nАналогично работе [G. Boeing] построим полярную гистограмму, отобрающую ориентацию улиц города, для того, чтобы лучше визуализировать пространственный порядок застройки.\n\n\nКод: полярная гистограмма\n\nlibrary(units)\n\nazimuth_net |&gt;\n  pull(azimuth) |&gt; \n  as_tibble() |&gt; \n  mutate(value = round(value, 1)) |&gt; \n  group_by(value) |&gt; \n  summarise(count = n()) |&gt; \n  ggplot(aes(x = as.numeric(value), y = count)) + \n  geom_bar(fill = \"midnightblue\", \n           stat = \"identity\") +\n  theme_void() + \n  labs(x = \"\", y = \"\") +\n  coord_polar()\n\n\n\n\n\n\n\nРисунок 12: Полярная гистограмма, показывающая ориентацию улиц дорожной сети г. Красноярска\n\n\n\n\n\n\n\n\n\nПоскольку многие населенные пункты расположены на берегах рек, улицы таких городов, как в нашем случае, ориентированы вдоль направления реки и перпендикулярно им. Кроме того, такого рода гистограммы могут показывать сложность застройки."
  },
  {
    "objectID": "blog/posts/2022-02-21-sfnetworks/index.html#построение-зон-транспортной-доступности",
    "href": "blog/posts/2022-02-21-sfnetworks/index.html#построение-зон-транспортной-доступности",
    "title": "Анализ графа дорожной сети",
    "section": "Построение зон транспортной доступности",
    "text": "Построение зон транспортной доступности\nОдин из наиболее интересующих нас вопросов – построение зон транспортной доступности по времени, т.е. областей, включающих все точки от заданной, в которые можно попасть не более чем за отведенный промежуток времени, двигаясь с учетом скоростных ограничений. Границы такого рода зон называются изохронами.\nДанный анализ является актуальным для обеспечения пожарной безопасности населенного пункта, поскольку возникает необходимость оценки зон транспортной доступности и территорий обслуживания с центром, находящемся в пожарно-спасательном подразделении по временным характеристикам. Напомним, что время прибытия первого пожарного подразделения к месту вызова в городских населенных пунктах не должно превышать 10 минут, в сельских населенных пунктах 20 минут (см. [Технический регламент о требованиях пожарной безопасности]). Назовем соответствующие области областями нормативного обслуживания.\nРассмотрим типы ребер графа в зависимости от типов дорог.\n\ntypes &lt;- net_connected_comp |&gt;\n  activate(\"edges\") |&gt;\n  pull(highway) |&gt;\n  unique()\n\ntypes\n\n [1] \"primary\"        \"tertiary\"       \"trunk\"          \"residential\"   \n [5] \"trunk_link\"     \"unclassified\"   \"secondary\"      \"primary_link\"  \n [9] \"service\"        \"tertiary_link\"  \"secondary_link\" \"living_street\" \n\n\nДалее мы должны приписать каждому OpenStreetMap-типу дорог скорость движения по нему, описание которых изложено в классификации дорог в России. Результат для зон нормативного обслуживания будет напрямую зависеть от выбора скоростей. Отметим, что скорости движения выбираются на основе трекеров, позволящих отслеживать движение автомобиля, либо на основе обобщенных статистических данных и могут зависеть от времени суток, времени года и других факторов. Скорости движения можно находить и на основе моделирования различными методами, а также базируясь на скоростных ограничениях и загруженности дорожной сети.\n\n\n\nТаблица 1: Пример выбора скоростей движения по различным типам дорог\n\n\n\n\n\n\n\n\n\n\n\n\nТипы дорог\nКлассификация дорог в России\nМаксимальная скорость в зависимости от типа дороги\n\n\n\n\n1\nАвтомобильные дороги образующие непрерывную соединительную сеть\nmotorway, trunk, primary, secondary, tertiary, unclassified\n40 км/ч\n\n\n2\nВспомогательные автомобильные дороги\nmotorway_link, trunk_link, primary_link, secondary_link, tertiary_link\n30 км/ч\n\n\n3\nАвтомобильные дороги в жилых зонах и жилые улицы\nresidential, living_street\n20 км/ч\n\n\n4\nСлужебные дороги\nservice, track\n20 км/ч\n\n\n\n\n\n\nЗададим скорости движения по различным типам дорог. Коэффициент пересчета позволяет перевести скорости в м/с. Также, найдем соответствующее время движения (в секундах) по каждому участку дорог.\n\n\n\n\n\n\nОтметим, что подход такого рода позволяет не использовать сторонние сервисы для нахождения скоростей движения, самостоятельно точно настраивать скорости и удобно использовать результаты вычислений для дальнейшего моделирования.\n\n\n\nВыберем значения скоростей движения в зависимости от типов дорог. Чтобы избежать ситуации, когда мы не сможем попасть из одного узла в другой, находящийся в другой компоненте, ограничимся лишь наибольшей связной компонентой графа, найденной выше.\n\n\nКод: скорости движения\n\nnet_speed &lt;- \n  net_connected_comp |&gt;\n  activate(\"edges\") |&gt;\n  mutate(weight = edge_length()) |&gt;\n  group_by(highway) |&gt;\n  # скорости в км/ч\n  mutate(\n    speed_km_h = case_when(\n      highway %in% c(\"motorway\", \"trunk\", \"primary\", \n                     \"secondary\", \"tertiary\", \n                     \"unclassified\") ~ 40,\n      highway %in% c(\"motorway_link\", \"trunk_link\",\n                     \"primary_link\", \"secondary_link\",\n                     \"tertiary_link\") ~ 30,\n      highway %in% c(\"residential\", \"living_street\") ~ 20,\n      highway %in% c(\"service\", \"track\") ~ 20\n    )\n  ) |&gt;\n  # пересчет в м/с\n  mutate(speed = speed_km_h / 3.6) |&gt;\n  mutate(speed = units::set_units(speed, \"m/s\")) |&gt;\n  mutate(time = weight / speed) |&gt;\n  ungroup()\n\nnet_speed &lt;- activate(net_speed, \"nodes\")\n\nВ качестве отправной точки выберем центроид графа.\nnet_centroid &lt;- net_speed |&gt;\n  activate(\"nodes\") |&gt;\n  st_geometry() |&gt;\n  st_combine() |&gt;\n  st_centroid() |&gt; \n  st_transform(4326)\nНайдем матрицу расстояний графа, где в качестве весов рассматривается время движения.\ncost_matrix_centroid &lt;-\nst_network_cost(net_speed, \n                # ближайший объект к центроиду графа\n                from = st_nearest_feature(net_centroid,\n                                          net_speed),\n                weights = \"time\")\nТеперь построим подграф-изохрону, ограничивающую время движения равное 10 минутам.\nnet_isochrone &lt;-\nnet_speed |&gt;\n  activate(\"nodes\") |&gt;\n  mutate(cost = cost_matrix_centroid |&gt; \n           t() %&gt;% \n           as.vector(.),\n         # перевод секунд в минуты\n         cost = cost / 60) |&gt;\n  tidygraph::filter(cost &lt;= 10)\nНайдем выпуклую оболочку изохроны.\nisochrone_conv_hull &lt;- net_isochrone |&gt;\n  st_geometry() |&gt;\n  st_combine() |&gt;\n  st_convex_hull()\nИзобразим изохрону и ограничивающую область.\n\n\nКод: изохрона\n\nbase_map + \n  # здания и строения\n  geom_sf(data = buildings, linewidth = 0.05) +\n  # вершины графа\n  geom_sf(data = st_as_sf(net_isochrone, \"nodes\"), \n          aes(color = cost),\n          alpha = 0.9,\n          size = 1.7) +\n  # центроид графа\n  geom_sf(data = net_centroid, \n          color = \"red\", \n          alpha = 1, \n          shape = 8, \n          size = 4.5, \n          stroke = 1.2) +\n  # выпуклая оболочка изохроны\n  geom_sf(data = isochrone_conv_hull, alpha = 0.1, \n          color = \"midnightblue\",\n          linewidth = 0.6) +\n  # ребра графа\n  geom_sf(data = st_as_sf(net_isochrone, \"edges\"), \n          alpha = 0.5,\n          color = \"black\",\n          linewidth = 0.15) +\n  viridis::scale_color_viridis(direction = -1) +\n  # географические границы части города\n  coord_sf(xlim = c(92.831, 92.949), \n           ylim = c(55.996, 56.07),\n           expand = FALSE) +\n  theme_void() +\n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\nРисунок 13: Пример изохроны, ограничивающей 10-минутную область достижимости на главной связной компоненте графа дорожной сети. Цвет вершин графа показывает удаленность от исходной точки (чем темнее, тем дальше от начальной точки)\n\n\n\nИдеи, которые мы рассмотрели, можно применить и к изучению достижимости из нескольких начальных точек. Пусть центроиды районов города являются исходными пунктами (условными пожарными частями – ПСЧ).\n\nfire_stations_sf\n\nSimple feature collection with 7 features and 1 field\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 92.73413 ymin: 55.96372 xmax: 93.02779 ymax: 56.07533\nGeodetic CRS:  WGS 84\n# A tibble: 7 × 2\n  name             geometry\n* &lt;chr&gt;         &lt;POINT [°]&gt;\n1 ПСЧ-1 (92.82686 56.01383)\n2 ПСЧ-2 (92.96615 55.98596)\n3 ПСЧ-3 (93.02779 56.02276)\n4 ПСЧ-4 (92.73413 56.01672)\n5 ПСЧ-5 (92.84575 55.96372)\n6 ПСЧ-6 (92.97927 56.07533)\n7 ПСЧ-7  (92.8806 56.04314)\n\n\nНайдем узлы графа, ближайшие к выбранным точкам, поиск расстояний будем осуществлять из них.\nfire_stations_near_points &lt;-\n  net_speed |&gt;\n  activate(\"nodes\") |&gt;\n  st_as_sf() |&gt;\n  # ближайшие точки графа к выбранным\n  slice(st_nearest_feature(fire_stations_sf,\n                           net_speed)) |&gt;\n  mutate(lon = st_coordinates(geometry)[,1],\n         lat = st_coordinates(geometry)[,2],\n         name = c(paste(\"ПСЧ\", 1:7, sep = \"-\")))\nДалее мы рассмотрим не все здания, а только многоквартирные жилые дома, соответствующие значению apartments переменной building (см. [Объекты карты OpenSteetMap]).\napartments &lt;- buildings |&gt;\n  as_tibble() |&gt;\n  filter(building == \"apartments\") |&gt;\n  mutate(apartm_id = row_number()) |&gt;\n  st_sf()\nДля вычислений расстояний вдоль дорожной сети будем использовать центроиды зданий.\napartments_centroids &lt;- apartments |&gt;\n  st_geometry() %&gt;% \n  st_centroid(.) |&gt;\n  as_tibble() |&gt;\n  mutate(apartm_id = row_number()) |&gt;\n  st_sf()\nТеперь найдем матрицу стоимости (расстояний) от ближайших к пожарным частям узлов до ближайших узлов к центроидам зданий.\ncost_matrix_apartments &lt;-\n  st_network_cost(net_speed, \n                  # ближайшие узлы к пожарным частям\n                  from = st_nearest_feature(fire_stations_sf,\n                                            net_speed),\n                  # ближайшие узлы к центроиду графа\n                  to = st_nearest_feature(apartments_centroids,\n                                          net_speed),\n                  weights = \"time\")\nОтдельно получим вектор, который содержит расстояния от центроидов зданий до ближайшей пожарной части.\ncost_vector_apartments &lt;-\n  cost_matrix_apartments |&gt;\n  as_tibble() |&gt;\n  summarise(across(where(is.numeric), min)) |&gt;\n  t() %&gt;% \n  as.vector(.) |&gt;\n  as_tibble()\nДобавим значения времени сначала к центроидам зданий.\napartments_cost &lt;-\napartments_centroids |&gt;\n  as_tibble() |&gt;\n  mutate(cost = cost_vector_apartments$value,\n         # перевод секунд в минуты\n         cost = cost / 60) |&gt;\n  filter(cost &lt; Inf) |&gt;\n  st_sf()\nСоединим информацию по минимальному времени прибытия к центроидам зданий с исходной таблицей и оставим только здания в пределах городских границ.\napartments_buildings_cost &lt;- \n  left_join(st_drop_geometry(apartments_cost), \n            apartments) |&gt;\n  st_sf() |&gt;\n  st_intersection(boundary_KRSK)\nПеред тем, как рассмотреть изохроны, мы построим ряд графиков. Сначала найдем время, за которое достигается масимальное количество узлов графа. В нашем случае оно составляет около 7 минут.\nmax_row &lt;- which.max(density(as_tibble(net_fire_stations)$cost)$y)\nmax_density &lt;- density(as_tibble(net_fire_stations)$cost)$x[max_row]\nИзобразим график, который показывает плотность количества узлов графа (объектов), достижимых за определенное время.\n\n\nКод: график плотности\n\n# график плотности\napartments_cost |&gt;\n  as_tibble() |&gt;\n  ggplot(aes(x = cost)) + \n  geom_density() +\n  geom_vline(xintercept = max_density, \n             color = \"red\",\n             linetype = \"dashed\",\n             linewidth = 0.5) +\n  scale_x_continuous(labels = function(x) str_c(x, ' мин'),\n                     breaks = seq(0, 50, by = 5)) +\n  labs(x = \"\", y = \"\") +\n  hrbrthemes::theme_ipsum()\n\n\n\n\n\n\n\nРисунок 14: График плотности количества узлов графа дорожной сети, которые достижимы за определенное время. Максимум соответствует значению 7,1 минуты\n\n\n\nДругой, более важный для нас показатель, – это функция достижимости \\(F(t)\\), которая в точке \\(t_0\\) показывает долю (количество) узлов графа (например, в процентном соотношении), достижимых за время \\(t &lt; t_0\\). С помощью данной функции можно определить количество узлов графа, которые будут достигнуты за время \\(t\\) из диапазона \\(a &lt; t &lt; b\\) как разницу \\(F(b) - F(a)\\).\n\n\nКод: функция достижимости\n\n# функция достижимости\napartments_cost |&gt;\n  as_tibble() |&gt;\n  ggplot(aes(x = cost)) + \n  stat_ecdf(geom = \"step\") + \n  geom_vline(xintercept = 10, \n             color = \"red\",\n             linetype = \"dashed\",\n             linewidth = 0.5) +\n  scale_y_continuous(labels = scales::percent) +\n  scale_x_continuous(labels = function(x) str_c(x, ' мин'),\n                     breaks = seq(0, 50, by = 5)) +\n  labs(x = \"\", y = \"\") +\n  hrbrthemes::theme_ipsum()\n\n\n\n\n\n\n\nРисунок 15: График функции достижимости достижимости узлов графа дорожной сети. На графике показано, что за 10 минут будет достигнуто 75% узлов графа\n\n\n\nИзобразим цветом достижимость зданий из ПСЧ.\n\n\nКод: транспортная доступность многоквартирных жилых домов\n\nbase_map +\n  # здания и строения\n  geom_sf(data = buildings, \n          linewidth = 0.03) +\n  # многоквартирные жилые дома\n  geom_sf(data = apartments_buildings_cost, \n          linewidth = 0.5, \n          aes(fill = cost, color = cost)) +\n  # точки с ПСЧ\n  geom_sf(data = st_sf(fire_stations_near_points),\n          color = \"black\",\n          alpha = 0.8, \n          shape = 8, \n          size = 3.5, \n          stroke = 1.2) +\n  # маркеры\n  ggrepel::geom_label_repel(data = fire_stations_near_points, \n                            aes(lon, lat, label = name), \n                            fontface = \"bold\",\n                            box.padding = 0.7,\n                            size = 4, \n                            alpha = 0.8) +\n  # цвет зданий                          \n  viridis::scale_fill_viridis(option = \"viridis\",\n                          direction = -1) +\n  viridis::scale_color_viridis(option = \"viridis\",\n                           direction = -1) +\n  theme_void() +\n  theme(legend.position = \"none\") +\n  # географические границы части города\n  coord_sf(xlim = c(92.79, 92.94), \n           ylim = c(55.98, 56.058),\n           expand = FALSE)\n\n\n\n\n\n\n\nРисунок 16: Транспортная доступность многоквартирных жилых домов из условных пожарно-спасательных подразделений. Оттенок соответствует времени прибытия (чем темнее, тем больше время прибытия)"
  },
  {
    "objectID": "blog/posts/2022-02-21-sfnetworks/index.html#получение-openstreetmap-данных-и-предобработка",
    "href": "blog/posts/2022-02-21-sfnetworks/index.html#получение-openstreetmap-данных-и-предобработка",
    "title": "Анализ графа дорожной сети",
    "section": "Получение OpenStreetMap-данных и предобработка",
    "text": "Получение OpenStreetMap-данных и предобработка\nБиблиотеки для получения данных OpenStreetMap:\n\nosmdata служит для загрузки и использования данных из OpenStreetMap;\nosrm – R-интерфейс для сервиса Open Source Routing Machine;\nosmextract загружает, конвертирует и импортирует объемные данные OpenStreetMap из источников данных различных провайдеров, например, Geofabrik GmbH и bbbike;\nosmplotr – библиотека, использующая данные OpenStreetMap для создания карт с широкими возможностями настройки."
  },
  {
    "objectID": "blog/posts/2022-02-21-sfnetworks/index.html#сетевой-анализ-1",
    "href": "blog/posts/2022-02-21-sfnetworks/index.html#сетевой-анализ-1",
    "title": "Анализ графа дорожной сети",
    "section": "Сетевой анализ",
    "text": "Сетевой анализ\nБиблиотеки для работы с графами дорожных сетей и маршрутами:\n\nsfnetwork – библиотека для работы с сетями как пространственными графами на основе библиотеки sf для пространственного анализа и tidygraph для работы с графами;\nspNetwork – библиотека для пространственного сетевого анализа;\ncppRouting – библиотека для работы с алгоритмами маршрутизации (кратчайшие расстояния, изохроны) с большими графами дорог (в масштабе страны), решение задач распределения трафика с высокой производительностью за счет использования памяти и параллельного программирования;\ndodgr – библиотека для расчета расстояний и на взвешенных ориентированных графах, для агрегирования потоков в сетях, высокореалистичной маршрутизации через уличные сети (маршрутизация на основе времени с учетом уклона, углов поворота и т.д.);\nopentripplanner – библиотека R, которая предоставляет простой, но гибкий интерфейс для OpenTripPlanner (OTP). OTP – это сервис планирования мультимодальных поездок, написанный на Java.\nstplanr – библиотека для устойчивого транспортного планирования с помощью R."
  },
  {
    "objectID": "blog/posts/2022-02-21-sfnetworks/index.html#сеть-общественного-транспорта",
    "href": "blog/posts/2022-02-21-sfnetworks/index.html#сеть-общественного-транспорта",
    "title": "Анализ графа дорожной сети",
    "section": "Сеть общественного транспорта",
    "text": "Сеть общественного транспорта\nБиблиотеки для работы с сервисами маршрутизации:\n\nhereR – позволяет делать геокодирование и обратное геокодирование, искать направления маршрута, матрицы расстояний и времени проезда, а также изолинии, запрашивать информацию о потоке трафика и инцидентах в режиме реального времени, находить остановки общественного транспорта и т.д.;\ngraphhopper – быстрый и простой доступ к API GraphHopper Directions;\nr5r – библиотека для быстрого реалистичного построения маршрутов в мультимодальных транспортных сетях (пешком, велосипеде, общественном транспорте и автомобиле), которая обеспечивает простой и удобный интерфейс для \\(R^5\\) (Rapid Realistic Routing on Real-world and Reimagined networks);\ntidytransit служит для картирования транзитных остановок и маршрутов, расчета времени в пути и частоты транзита, а также для проверки транзитных данных;\ngtfsio, gtfstools, gtfsrouter, gtfs2gps – набор библиотек для обработки и маршрутизации данных работы общественного транспорта."
  },
  {
    "objectID": "blog/posts/2022-02-21-sfnetworks/index.html#книги-главы-книг-и-статьи-касающиеся-сетевого-анализа-в-r-и-смежных-вопросов",
    "href": "blog/posts/2022-02-21-sfnetworks/index.html#книги-главы-книг-и-статьи-касающиеся-сетевого-анализа-в-r-и-смежных-вопросов",
    "title": "Анализ графа дорожной сети",
    "section": "Книги, главы книг и статьи, касающиеся сетевого анализа в R и смежных вопросов",
    "text": "Книги, главы книг и статьи, касающиеся сетевого анализа в R и смежных вопросов\n\nГлава Transportation в книге Geocomputation with R рассматривает сети маршрутов и географический анализ транспортных систем.\nГлава Сетевой анализ курса Визуализация и анализ географических данных на языке R исследует задачи анализа географических сетей, которые охватывают как анализ структурно-топологических характеристик сетей (например, центральность), так и решение практических задач, связанных с маршрутизацией и построением зон доступности.\nКнига Introduction to urban accessibility направлена на то, чтобы дать читателям необходимые фундаментальные концепции, практические навыки анализа данных и инструменты обработки для проведения анализа доступности городов и оценки воздействия транспортных проектов.\nВ статье Spatial networks in R with sf and tidygraph рассматриваются подходы, связанные с получением данных, очисткой сети, созданием графа дорожной сети, мерами центральности, поиском кратчайших путей.\nКнига Spatial Analysis along Networks: Statistical and Computational Methods переводит большинство классических географических вопросов (например, диаграммы Вороного, K-функции, оценки плотности точек) с площадных характеристик на транспортные сети.\n\n\n\n\n\n\n\nSession Info\n\n\n\n\n\n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31)\n os       macOS Monterey 12.1\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  ru_RU.UTF-8\n ctype    ru_RU.UTF-8\n tz       Asia/Krasnoyarsk\n date     2024-03-01\n pandoc   2.18 @ /Users/materov/opt/miniconda3/envs/ox/bin/ (via rmarkdown)\n quarto   1.4.550\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n dplyr       * 1.1.4   2023-11-17 [1] CRAN (R 4.3.1)\n forcats     * 1.0.0   2023-01-29 [1] CRAN (R 4.3.0)\n future      * 1.33.1  2023-12-22 [1] CRAN (R 4.3.1)\n ggplot2     * 3.5.0   2024-02-23 [1] CRAN (R 4.3.1)\n ggspatial   * 1.1.9   2023-08-17 [1] CRAN (R 4.3.0)\n lubridate   * 1.9.3   2023-09-27 [1] CRAN (R 4.3.1)\n magrittr    * 2.0.3   2022-03-30 [1] CRAN (R 4.3.0)\n osmdata     * 0.2.5   2023-08-14 [1] CRAN (R 4.3.0)\n osrm        * 4.1.1   2023-03-30 [1] CRAN (R 4.3.0)\n purrr       * 1.0.2   2023-08-10 [1] CRAN (R 4.3.0)\n readr       * 2.1.5   2024-01-10 [1] CRAN (R 4.3.1)\n sessioninfo * 1.2.2   2021-12-06 [1] CRAN (R 4.3.0)\n sf          * 1.0-15  2023-12-18 [1] CRAN (R 4.3.1)\n sfnetworks  * 0.6.3   2023-03-22 [1] CRAN (R 4.3.0)\n stringr     * 1.5.1   2023-11-14 [1] CRAN (R 4.3.1)\n tibble      * 3.2.1   2023-03-20 [1] CRAN (R 4.3.0)\n tidygraph   * 1.3.1   2024-01-30 [1] CRAN (R 4.3.1)\n tidyr       * 1.3.1   2024-01-24 [1] CRAN (R 4.3.1)\n tidyverse   * 2.0.0   2023-02-22 [1] CRAN (R 4.3.0)\n\n [1] /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────\n\n\n\n\n\n\n\n\nРисунок 1: Карта дорожной сети города на основе данных OpenStreetMap\nРисунок 2: Граф дорожной сети города Красноярска, также показаны здания и строения\nРисунок 3: Сглаженный граф дорожной сети города Красноярска\nРисунок 4: Пример пространственной фильтрации графа дорожной сети города Красноярска\nРисунок 5: Пример пространственной фильтрации графа дорожной сети города Красноярска по району\nРисунок 6: Центральность по промежуточности вершин графа дорожной сети г. Красноярска. Показатель центральности равен \\(bc\\cdot 10^6\\) (чем темнее и больше изображена вершина, тем больше значение показателя)\nРисунок 7: Центральность по промежуточности ребер графа дорожной сети г. Красноярска. Показатель центральности тем больше, чем темнее цвет ребра\nРисунок 8: Главная связная компонента графа дорожной сети (выделена красным цветом)\nРисунок 9: Кластеры для главной связной компоненты графа дорожной сети\nРисунок 10: Пример пространственной кластеризации (5 кластеров) вершин графа дорожной сети с помощью метода hclust\nРисунок 11: Азимутальное направление улиц, построенное по графу дорожной сети г. Красноярска\nРисунок 13: Пример изохроны, ограничивающей 10-минутную область достижимости на главной связной компоненте графа дорожной сети. Цвет вершин графа показывает удаленность от исходной точки (чем темнее, тем дальше от начальной точки)\nРисунок 16: Транспортная доступность многоквартирных жилых домов из условных пожарно-спасательных подразделений. Оттенок соответствует времени прибытия (чем темнее, тем больше время прибытия)"
  },
  {
    "objectID": "blog/posts/2021-02-19-modeltime/index.html",
    "href": "blog/posts/2021-02-19-modeltime/index.html",
    "title": "Использование машинного обучения для анализа временных рядов",
    "section": "",
    "text": "Под временным рядом (динамическим рядом) обычно понимается последовательность наблюдений {\\(y_t\\)}, элементы которой принимают случайные значения через определенные (обычно регулярные) значения времени \\(t\\). Область применения временных рядов очень обширна, временные ряды используются в сейсмологии, метеорологии, экономике, при регистрации значений любых датчиков. Временным рядам посвящено большое количество литературы, в частности, работа с временными рядами в среде R описана в монографиях [R.H. Shumway & D.S. Stoffer], [R. Hyndman and G. Athanasopoulos] и [С.Э. Мастицкий].\nВ нашем случае в качестве временных рядов рассматривается, например, количество пожаров, регистрируемых в сутки/неделю/месяц, уровень воды в водоемах, дневная температура воздуха, и т.д. Мы покажем применение библиотеки modeltime для моделирования временных рядов с помощью методов машинного обучения. Основные преимущества данной библиотеки:\nБиблиотека modeltime (см. сайт библиотеки и вводное видео) интегрирована с библиотекой tidymodels, что позволяет рассматривать ее в рамках единой экосистемы алгоритмов машинного обучения, основанной на принципах tidy data (см. [H. Wickham]). Узнать больше о библиотеке tidymodels можно на сайте библиотеки и из книги [M. Kuhn and J. Silge]."
  },
  {
    "objectID": "blog/posts/2021-02-19-modeltime/index.html#установка-библиотеки",
    "href": "blog/posts/2021-02-19-modeltime/index.html#установка-библиотеки",
    "title": "Использование машинного обучения для анализа временных рядов",
    "section": "Установка библиотеки",
    "text": "Установка библиотеки\nСтабильную версию библиотеки можно установить из репозитория CRAN соответствующей командой:\ninstall.packages(\"modeltime\")\nДевелоперская версия доступна на GitHub:\nremotes::install_github(\"business-science/modeltime\")"
  },
  {
    "objectID": "blog/posts/2021-02-19-modeltime/index.html#шаг-1",
    "href": "blog/posts/2021-02-19-modeltime/index.html#шаг-1",
    "title": "Использование машинного обучения для анализа временных рядов",
    "section": "Шаг 1",
    "text": "Шаг 1\nРазбиение на обучающую и тестовую выборку можно делать либо указав временной параметр, либо процентные соотношения.\n\n# Разделение выборки на обучающую и тестовую\n\nset.seed(2024)\nsplits &lt;- temp_KRSK |&gt;\n  arrange(date) |&gt;\n  time_series_split(assess     = \"6 months\",\n                    cumulative = TRUE)\n\n# альтернативный вариант\n# в соотношении 90% / 10%\n# splits &lt;- temp_KRSK |&gt;\n#   arrange(date) |&gt;\n#   rsample::initial_time_split(prop = 0.9)\n\nsplits\n\n&lt;Analysis/Assess/Total&gt;\n&lt;1645/181/1826&gt;\n\n\n\n\nКод\nsplits |&gt;\n  tk_time_series_cv_plan() |&gt;\n  plot_time_series_cv_plan(date, t_avg, \n                           .interactive = FALSE) +\n  scale_x_date(date_breaks = \"12 months\",\n               date_labels = \"%Y\") +\n  scale_y_continuous(labels = function(x) str_c(x, \" °C\")) +\n  labs(title = \"Разделение временного ряда на обучающую и тестовую выборку\",\n       subtitle = \"в качестве тестовой выборки рассмотрены последние 6 месяцев\",\n       color = \"Выборка:\") +\n  theme_bw(base_size = 14) +\n  theme(plot.margin = ggplot2::margin(0.01, 0.01, 0.01, 0.01, \"cm\"), \n        legend.position = \"bottom\")\n\n\n\n\n\n\n\n\nРисунок 4: Разделение временного ряда на обучающую и тестовую выборку"
  },
  {
    "objectID": "blog/posts/2021-02-19-modeltime/index.html#шаг-2",
    "href": "blog/posts/2021-02-19-modeltime/index.html#шаг-2",
    "title": "Использование машинного обучения для анализа временных рядов",
    "section": "Шаг 2",
    "text": "Шаг 2\nСледующим этапом является создание и подгонка моделей. Ключевая особенность modeltime заключается в возможности работы с несколькими моделями одновременно. Это позволяет сравнивать модели, выбирая наилучшие результаты, включая как классические модели\n\nLinear Regression\nARIMA\nExponential Smoothing\nMARS (Multivariate Adaptive Regression Splines)\n\nтак и модели машинного обучения. Модели машинного обучения более сложны, чем автоматизированные модели, эта сложность обычно требует рабочего процесса – workflows (иногда называемого конвейером). Полный список моделей, который постоянно дополняется, можно получить на сайте Modeltime Ecosystem Roadmap: New Algorithms & Models. Отметим, что modeltime позволяет комбинировать алгоритмы, улучшая их, например, получая Boosted Models на основе CatBoost или LightGBM.\nОбщий процесс протекает следующим образом:\n\nСоздание типа модели, так называемого рецепта (recipe) предварительной обработки используя tidymodels.\nСоздание спецификаций модели.\nИспользование рабочего процесса для объединения спецификаций модели, предобработки и подходящей модели.\n\nПостроим несколько моделей для данного временного ряда.\n\n1. Линейная регрессия\n\n# Модель 1: lm\n# Линейная регрессия\nmodel_fit_lm &lt;- linear_reg() |&gt;\n  set_engine(\"lm\") |&gt;\n  fit(t_avg ~ as.numeric(date) + factor(month(date), ordered = FALSE),\n      data = training(splits))\n\nmodel_fit_lm\n\n\n\nparsnip model object\n\n\nCall:\nstats::lm(formula = t_avg ~ as.numeric(date) + factor(month(date), \n    ordered = FALSE), data = data)\n\nCoefficients:\n                           (Intercept)                        as.numeric(date)  \n                            -1.701e+01                              -1.782e-04  \n factor(month(date), ordered = FALSE)2   factor(month(date), ordered = FALSE)3  \n                             2.198e+00                               1.333e+01  \n factor(month(date), ordered = FALSE)4   factor(month(date), ordered = FALSE)5  \n                             2.280e+01                               2.711e+01  \n factor(month(date), ordered = FALSE)6   factor(month(date), ordered = FALSE)7  \n                             3.588e+01                               3.673e+01  \n factor(month(date), ordered = FALSE)8   factor(month(date), ordered = FALSE)9  \n                             3.395e+01                               2.794e+01  \nfactor(month(date), ordered = FALSE)10  factor(month(date), ordered = FALSE)11  \n                             2.211e+01                               1.342e+01  \nfactor(month(date), ordered = FALSE)12  \n                             3.245e+00  \n\n\n\n\n\n2. Классическая модель ARIMA с автоопределением параметров\n\n# Модель 2: auto_arima\n# ARIMA\nmodel_fit_arima &lt;- arima_reg() |&gt;\n  set_engine(engine = \"auto_arima\") |&gt;\n  fit(t_avg ~ date, data = training(splits))\n\nfrequency = 7 observations per 1 week\n\n\nmodel_fit_arima\n\n\nparsnip model object\n\nSeries: outcome \nARIMA(5,0,0)(2,0,0)[7] with zero mean \n\nCoefficients:\n         ar1      ar2    ar3      ar4     ar5     sar1    sar2\n      1.0313  -0.2946  0.132  -0.0170  0.1248  -0.0358  0.0081\ns.e.  0.0245   0.0354  0.036   0.0354  0.0253   0.0262  0.0252\n\nsigma^2 = 14.71:  log likelihood = -4543.63\nAIC=9103.25   AICc=9103.34   BIC=9146.5\n\n\n\n\n3. Модель ARIMA Boost\n\n# Модель 3: arima_boost\n# ARIMA с бустингом (уменьшение ошибок с помощью XGBoost)\nmodel_fit_arima_boosted &lt;- arima_boost(\n  min_n = 2,\n  learn_rate = 0.015) |&gt;\n  set_engine(engine = \"auto_arima_xgboost\") |&gt;\n  fit(t_avg ~ date + as.numeric(date) + \n        factor(month(date), ordered = F),\n      data = training(splits))\n\nfrequency = 7 observations per 1 week\n\n\n\n\n4. Модель ETS\n\n# Модель 4: ets\n# экспоненциальное сглаживание\n# ETS(A,N,N)\nmodel_fit_ets &lt;- exp_smoothing() |&gt;\n  set_engine(engine = \"ets\") |&gt;\n  fit(t_avg ~ date, data = training(splits))\n\nfrequency = 7 observations per 1 week\n\n\n\nmodel_fit_ets\n\nparsnip model object\n\nETS(A,N,N) \n\nCall:\n forecast::ets(y = outcome, model = model_ets, damped = damping_ets,  \n\n Call:\n     alpha = alpha, beta = beta, gamma = gamma) \n\n  Smoothing parameters:\n    alpha = 0.9999 \n\n  Initial states:\n    l = -29.4188 \n\n  sigma:  4.0323\n\n     AIC     AICc      BIC \n16773.45 16773.46 16789.66 \n\n\n\n\n5. Модель Prophet\n\n# Модель 5: prophet\n# Prophet by Facebook\nmodel_fit_prophet &lt;- prophet_reg() |&gt;\n  set_engine(\"prophet\") |&gt;\n  fit(t_avg ~ date, training(splits))\n\n\nmodel_fit_prophet\n\nparsnip model object\n\nPROPHET Model\n- growth: 'linear'\n- n.changepoints: 25\n- changepoint.range: 0.8\n- yearly.seasonality: 'auto'\n- weekly.seasonality: 'auto'\n- daily.seasonality: 'auto'\n- seasonality.mode: 'additive'\n- changepoint.prior.scale: 0.05\n- seasonality.prior.scale: 10\n- holidays.prior.scale: 10\n- logistic_cap: NULL\n- logistic_floor: NULL\n- extra_regressors: 0\n\n\n\n\n6. Модель MARS\n\n# Модель 6: MARS\n# Пример \"рецепта\" предобработки\nrecipe_spec &lt;- recipe(t_avg ~ date, data = training(splits)) |&gt;\n  step_date(date, features = \"month\", ordinal = FALSE) |&gt;\n  step_mutate(date_num = as.numeric(date)) |&gt;\n  step_normalize(date_num) |&gt;\n  step_rm(date)\n\n\n# вид \"рецепта\"\nrecipe_spec |&gt; prep() |&gt; juice()\n\n# A tibble: 1,645 × 3\n   t_avg date_month date_num\n   &lt;dbl&gt; &lt;fct&gt;         &lt;dbl&gt;\n 1 -29.4 Jan           -1.73\n 2 -34.4 Jan           -1.73\n 3 -37.8 Jan           -1.73\n 4 -36.7 Jan           -1.72\n 5 -36.7 Jan           -1.72\n 6 -36.1 Jan           -1.72\n 7 -35.6 Jan           -1.72\n 8 -32.8 Jan           -1.72\n 9 -29.4 Jan           -1.71\n10 -33.9 Jan           -1.71\n# ℹ 1,635 more rows\n\n\n\n# спецификации модели MARS (Computational engine: earth)\nmodel_spec_mars &lt;- mars(mode = \"regression\") |&gt;\n  set_engine(\"earth\")\n\n\n# собираем модель MARS\nworkflow_fit_mars &lt;- workflow() |&gt;\n  add_recipe(recipe_spec) |&gt;\n  add_model(model_spec_mars) |&gt;\n  fit(training(splits))\n\nworkflow_fit_mars\n\n\n\n══ Workflow [trained] ══════════════════════════════════════════════════════════\nPreprocessor: Recipe\nModel: mars()\n\n── Preprocessor ────────────────────────────────────────────────────────────────\n4 Recipe Steps\n\n• step_date()\n• step_mutate()\n• step_normalize()\n• step_rm()\n\n── Model ───────────────────────────────────────────────────────────────────────\nSelected 12 of 14 terms, and 10 of 12 predictors\nTermination condition: Reached nk 25\nImportance: date_monthJun, date_monthJul, date_monthAug, date_monthMay, ...\nNumber of terms at each degree of interaction: 1 11 (additive model)\nGCV 40.70011    RSS 65092.56    GRSq 0.8009174    RSq 0.80621\n\n\n\n\n\n7. Модель Prophet Boost\n\n# Модель 7: Prophet Boost\n# рецепт\nrecipe_spec &lt;- recipe(t_avg ~ date, training(splits)) |&gt;\n  step_timeseries_signature(date) |&gt;\n  step_rm(contains(\"am.pm\"), contains(\"hour\"), contains(\"minute\"),\n          contains(\"second\"), contains(\"xts\")) |&gt;\n  step_fourier(date, period = 365, K = 5) |&gt;\n  step_dummy(all_nominal())\n\n\n# спецификации\nmodel_spec_prophet_boost &lt;- prophet_boost() |&gt;\n  set_engine(\"prophet_xgboost\", \n             yearly.seasonality = TRUE)\n\n\n# сборка модели\nworkflow_fit_prophet_boost &lt;- workflow() |&gt;\n  add_model(model_spec_prophet_boost) |&gt;\n  add_recipe(recipe_spec) |&gt;\n  fit(training(splits))\n\n\n\n8. Модель glmnet\n\n# Модель 8: glmnet\n# recipe\nrecipe_spec &lt;- recipe(t_avg ~ date, training(splits)) |&gt;\n  step_timeseries_signature(date) |&gt;\n  step_rm(contains(\"am.pm\"), contains(\"hour\"), contains(\"minute\"),\n          contains(\"second\"), contains(\"xts\")) |&gt;\n  step_fourier(date, period = 365, K = 5) |&gt;\n  step_dummy(all_nominal())\n\n# просмотр \"рецепта\"\nrecipe_spec |&gt; prep() |&gt; juice()\n\n\n\n# A tibble: 1,645 × 47\n   date       t_avg date_index.num date_year date_year.iso date_half\n   &lt;date&gt;     &lt;dbl&gt;          &lt;dbl&gt;     &lt;int&gt;         &lt;int&gt;     &lt;int&gt;\n 1 2010-01-01 -29.4     1262304000      2010          2009         1\n 2 2010-01-02 -34.4     1262390400      2010          2009         1\n 3 2010-01-03 -37.8     1262476800      2010          2009         1\n 4 2010-01-04 -36.7     1262563200      2010          2010         1\n 5 2010-01-05 -36.7     1262649600      2010          2010         1\n 6 2010-01-06 -36.1     1262736000      2010          2010         1\n 7 2010-01-07 -35.6     1262822400      2010          2010         1\n 8 2010-01-08 -32.8     1262908800      2010          2010         1\n 9 2010-01-09 -29.4     1262995200      2010          2010         1\n10 2010-01-10 -33.9     1263081600      2010          2010         1\n# ℹ 1,635 more rows\n# ℹ 41 more variables: date_quarter &lt;int&gt;, date_month &lt;int&gt;, date_day &lt;int&gt;,\n#   date_wday &lt;int&gt;, date_mday &lt;int&gt;, date_qday &lt;int&gt;, date_yday &lt;int&gt;,\n#   date_mweek &lt;int&gt;, date_week &lt;int&gt;, date_week.iso &lt;int&gt;, date_week2 &lt;int&gt;,\n#   date_week3 &lt;int&gt;, date_week4 &lt;int&gt;, date_mday7 &lt;int&gt;, date_sin365_K1 &lt;dbl&gt;,\n#   date_cos365_K1 &lt;dbl&gt;, date_sin365_K2 &lt;dbl&gt;, date_cos365_K2 &lt;dbl&gt;,\n#   date_sin365_K3 &lt;dbl&gt;, date_cos365_K3 &lt;dbl&gt;, date_sin365_K4 &lt;dbl&gt;, …\n\n\n\n\n# спецификация модели\nmodel_spec_glmnet &lt;- linear_reg(penalty = 0.01, mixture = 0.5) |&gt;\n  set_engine(\"glmnet\")\n\n\n# сборка модели glmnet\nworkflow_fit_glmnet &lt;- workflow() |&gt;\n  add_model(model_spec_glmnet) |&gt;\n  add_recipe(recipe_spec %&gt;% step_rm(date)) |&gt;\n  fit(training(splits))\n\n\n\n9. Модель XGBoost\n\nrecipe_ml_xb &lt;- recipe(t_avg ~ date, training(splits)) |&gt;\n  step_timeseries_signature(date) |&gt;\n  step_rm(date) |&gt;\n  step_dummy(all_nominal_predictors(), one_hot = TRUE)\n\n\nmodel_xgb &lt;- boost_tree(\"regression\") |&gt;\n  set_engine(\"xgboost\")\n\n\n# сборка модели XGBoost\nworkflow_fit_xgb &lt;- workflow() |&gt;\n  add_model(model_xgb) |&gt;\n  add_recipe(recipe_ml_xb) |&gt;\n  fit(training(splits))"
  },
  {
    "objectID": "blog/posts/2021-02-19-modeltime/index.html#шаг-3",
    "href": "blog/posts/2021-02-19-modeltime/index.html#шаг-3",
    "title": "Использование машинного обучения для анализа временных рядов",
    "section": "Шаг 3",
    "text": "Шаг 3\nМодели прописываются и добавляются в единую таблицу моделей, в которой до включения можно настраивать параметры, а затем проходит их подгонка/масштабирование, проверка на соответствие и калибровка по отношению к тестовой выборке. Далее происходит оценка качества моделей на тестовой выборке используя различные показатели точности:\n\nMAE – средняя абсолютная ошибка;\nMAPE – средняя абсолютная процентная ошибка;\nMASE – средняя абсолютная нормированная ошибка;\nSMAPE – симметричная средняя абсолютная процентная ошибка;\nRMSE – среднеквадратическая ошибка;\nRSQ – показатель \\(R^2\\).\n\n\n# добавление подогнанных моделей в таблицы моделей\nmodels_tbl &lt;- modeltime_table(\n  model_fit_lm,\n  model_fit_arima,\n  model_fit_arima_boosted,\n  model_fit_ets,\n  model_fit_prophet,\n  # модели машинного обучения\n  workflow_fit_mars,\n  workflow_fit_prophet_boost,\n  workflow_fit_glmnet,\n  workflow_fit_xgb\n)\n\n\n# просмотр таблицы моделей\nmodels_tbl\n\n# Modeltime Table\n# A tibble: 9 × 3\n  .model_id .model     .model_desc                                  \n      &lt;int&gt; &lt;list&gt;     &lt;chr&gt;                                        \n1         1 &lt;fit[+]&gt;   LM                                           \n2         2 &lt;fit[+]&gt;   ARIMA(5,0,0)(2,0,0)[7] WITH ZERO MEAN        \n3         3 &lt;fit[+]&gt;   ARIMA(5,0,0) WITH ZERO MEAN W/ XGBOOST ERRORS\n4         4 &lt;fit[+]&gt;   ETS(A,N,N)                                   \n5         5 &lt;fit[+]&gt;   PROPHET                                      \n6         6 &lt;workflow&gt; EARTH                                        \n7         7 &lt;workflow&gt; PROPHET W/ XGBOOST ERRORS                    \n8         8 &lt;workflow&gt; GLMNET                                       \n9         9 &lt;workflow&gt; XGBOOST"
  },
  {
    "objectID": "blog/posts/2021-02-19-modeltime/index.html#шаг-4",
    "href": "blog/posts/2021-02-19-modeltime/index.html#шаг-4",
    "title": "Использование машинного обучения для анализа временных рядов",
    "section": "Шаг 4",
    "text": "Шаг 4\nКалибровка, по сути, – это способ определения доверительных интервалов и метрик точности, при этом калибровочные данные – это спрогнозированные значения и невязки, которые вычисляются на основе данных вне выборки.\n\n# калибровка\ncalibration_tbl &lt;- models_tbl |&gt;\n  modeltime_calibrate(new_data = testing(splits))\n\n# таблица калиброванных моделей\n# добавились переменные .type и .calibration_data\ncalibration_tbl\n\n\n\n# Modeltime Table\n# A tibble: 9 × 5\n  .model_id .model     .model_desc                       .type .calibration_data\n      &lt;int&gt; &lt;list&gt;     &lt;chr&gt;                             &lt;chr&gt; &lt;list&gt;           \n1         1 &lt;fit[+]&gt;   LM                                Test  &lt;tibble&gt;         \n2         2 &lt;fit[+]&gt;   ARIMA(5,0,0)(2,0,0)[7] WITH ZERO… Test  &lt;tibble&gt;         \n3         3 &lt;fit[+]&gt;   ARIMA(5,0,0) WITH ZERO MEAN W/ X… Test  &lt;tibble&gt;         \n4         4 &lt;fit[+]&gt;   ETS(A,N,N)                        Test  &lt;tibble&gt;         \n5         5 &lt;fit[+]&gt;   PROPHET                           Test  &lt;tibble&gt;         \n6         6 &lt;workflow&gt; EARTH                             Test  &lt;tibble&gt;         \n7         7 &lt;workflow&gt; PROPHET W/ XGBOOST ERRORS         Test  &lt;tibble&gt;         \n8         8 &lt;workflow&gt; GLMNET                            Test  &lt;tibble&gt;         \n9         9 &lt;workflow&gt; XGBOOST                           Test  &lt;tibble&gt;"
  },
  {
    "objectID": "blog/posts/2021-02-19-modeltime/index.html#шаг-5",
    "href": "blog/posts/2021-02-19-modeltime/index.html#шаг-5",
    "title": "Использование машинного обучения для анализа временных рядов",
    "section": "Шаг 5",
    "text": "Шаг 5\nСформированные модели проверяются на тестовых данных и визуализируются.\n\n\nКод\n# пример прогнозирования временного ряда на тестовую выборку\n\ncalibration_tbl |&gt;\n  modeltime_forecast(new_data    = testing(splits), \n                     actual_data = temp_KRSK) |&gt; \n  dplyr::filter(.index &gt;= \"2013-01-01\") |&gt; \n  plot_modeltime_forecast(.interactive = F) +\n  labs(color = \"\",\n       title = \"Прогнозирование временного ряда на тестовую выборку\") + \n  scale_x_date(date_labels = \"%b %Y\") +\n  scale_y_continuous(labels = function(x) str_c(x, \" °C\")) +\n  guides(color = guide_legend(ncol = 2)) +\n  theme_bw(base_size = 14) +\n  theme(plot.margin = ggplot2::margin(0.01, 0.01, 0.01, 0.01, \"cm\"), \n        legend.position = \"bottom\")\n\n\n\n\n\n\n\n\nРисунок 5: Пример прогнозирования временного ряда на тестовую выборку\n\n\n\n\n\nТакже составляется таблица ошибок, использующая рассмотренные выше показатели точности, пример такого рода таблицы показан ниже.\n\n# таблица ошибок\ncalibration_tbl |&gt;\n  modeltime_accuracy() |&gt;\n  table_modeltime_accuracy(.interactive = F) \n\n\n\n\n\n\n\n\nAccuracy Table\n\n\n.model_id\n.model_desc\n.type\nmae\nmape\nmase\nsmape\nrmse\nrsq\n\n\n\n\n1\nLM\nTest\n5.04\n112.76\n1.49\n68.86\n6.52\n0.72\n\n\n2\nARIMA(5,0,0)(2,0,0)[7] WITH ZERO MEAN\nTest\n7.54\n98.19\n2.23\n119.21\n9.46\n0.73\n\n\n3\nARIMA(5,0,0) WITH ZERO MEAN W/ XGBOOST ERRORS\nTest\n7.68\n100.83\n2.27\n119.60\n9.64\n0.70\n\n\n4\nETS(A,N,N)\nTest\n14.00\n309.22\n4.13\n122.56\n17.30\nNA\n\n\n5\nPROPHET\nTest\n5.14\n112.79\n1.52\n71.69\n6.49\n0.75\n\n\n6\nEARTH\nTest\n5.11\n108.29\n1.51\n69.94\n6.58\n0.72\n\n\n7\nPROPHET W/ XGBOOST ERRORS\nTest\n4.75\n99.21\n1.40\n62.31\n5.93\n0.76\n\n\n8\nGLMNET\nTest\n4.65\n94.70\n1.37\n63.48\n5.98\n0.77\n\n\n9\nXGBOOST\nTest\n4.67\n78.11\n1.38\n70.05\n6.43\n0.76"
  },
  {
    "objectID": "blog/posts/2021-02-19-modeltime/index.html#шаг-6",
    "href": "blog/posts/2021-02-19-modeltime/index.html#шаг-6",
    "title": "Использование машинного обучения для анализа временных рядов",
    "section": "Шаг 6",
    "text": "Шаг 6\nЗаключительный этап состоит в том, чтобы скорректировать модели, распространить их на полный набор данных и спрогнозировать будущие значения.\n\n\n\n\n\n\nКак видно из предыдущего шага, не все модели в нашем случае имеют относительно хорошие показатели ошибок (в частности, коэффициент детерминации должен быть близок к единице, остальные показатели должны быть чем меньше, тем лучше), модели с 1 по 4 и 6 можно удалить из-за низкой точности.\n\n\n\n\n'%not_in%' &lt;- function(x,y)!('%in%'(x,y))\n\nrefit_tbl &lt;- calibration_tbl |&gt;\n  filter(.model_id %not_in% c(1:4, 6)) |&gt;\n  modeltime_refit(data = temp_KRSK)\n\nВизуализируем прогноз на 1 год вперед, изобразив при этом и истинные значения.\n\n# истинные данные с 1 января по 31 декабря 2015 года\ntemp_2015 &lt;- temp_raw |&gt;\n  dplyr::filter(between(date, as.Date(\"2015-01-01\"), \n                              as.Date(\"2015-12-31\"))) |&gt;\n  rename(.index = date)\n\n\ntemp_2015\n\n# A tibble: 365 × 2\n   .index      t_avg\n   &lt;date&gt;      &lt;dbl&gt;\n 1 2015-01-01  -2.78\n 2 2015-01-02  -6.67\n 3 2015-01-03 -19.4 \n 4 2015-01-04 -18.3 \n 5 2015-01-05  -7.78\n 6 2015-01-06  -5.56\n 7 2015-01-07  -5   \n 8 2015-01-08  -4.44\n 9 2015-01-09  -1.11\n10 2015-01-10  -6.11\n# ℹ 355 more rows\n\n\n\n\nКод\nrefit_tbl |&gt;\n  modeltime_forecast(h = \"1 year\", \n                     actual_data = temp_KRSK) |&gt;\n  dplyr::filter(.index &gt;= \"2014-01-01\") |&gt;\n  plot_modeltime_forecast(.interactive = FALSE,\n                          .conf_interval_fill = \"grey50\") +\n  geom_line(data = temp_2015, aes(x = .index, y = t_avg), \n             color = \"grey30\", linewidth = 0.5) +\n  labs(title    = \"Скорректированный прогноз для различных моделей\",\n       subtitle = \"прогноз на 1 год вперед\",\n       color    = \"Модели:\") + \n  scale_x_date(#date_breaks = \"1 year\",\n               date_labels = \"%b %Y\") +\n  scale_y_continuous(labels = function(x) str_c(x, \" °C\")) + \n  ggsci::scale_color_jama() +\n  theme_bw(base_size = 14) +\n  guides(color = guide_legend(ncol = 2,\n                              override.aes = list(size = 7))) +\n  theme(plot.margin = ggplot2::margin(0.01, 0.01, 0.01, 0.01, \"cm\"),\n        legend.position = \"bottom\")\n\n\n\n\n\n\n\n\nРисунок 6: Прогноз временного ряда с использованием нескольких моделей\n\n\n\n\n\nМы видим, что модели PROPHET и GLMNET дают близкий результат, основываясь на тренде, а PROPHET W/ XGBOOST ERRORS и XGBOOST пытаются повторить аномалии, причем PROPHET W/ XGBOOST ERRORS имеет высокий разброс значений. У нас имеются истинные значения температур за прогнозируемый 2015 год, какая же из моделей оказалась наиболее близкой по значениям? Составим аналог дисперсии для сравнения моделей.\n\n# какая модель ближе всего к истинным значениям?\n# значение меньше -- лучше\nrefit_tbl |&gt;\n  modeltime_forecast(h = \"1 year\", \n                     actual_data = temp_KRSK) |&gt;\n  dplyr::filter(.index &gt;= \"2015-01-01\",\n                .index &lt;= \"2015-12-31\",\n                .key == \"prediction\") %&gt;% \n  left_join(., temp_2015) |&gt;\n  group_by(.model_desc) |&gt;\n  summarise(model_variance = sum(.value - t_avg)^2 / 10000)\n\n# A tibble: 4 × 2\n  .model_desc               model_variance\n  &lt;chr&gt;                              &lt;dbl&gt;\n1 GLMNET                              37.5\n2 PROPHET                             12.4\n3 PROPHET W/ XGBOOST ERRORS           43.0\n4 XGBOOST                             51.2\n\n\nМожно сделать вывод, что PROPHET оказалась ближе всего к реальным температурам."
  },
  {
    "objectID": "blog/posts/2022-11-13-quarto/index.html#название-quarto",
    "href": "blog/posts/2022-11-13-quarto/index.html#название-quarto",
    "title": "Научно-издательская система Quarto",
    "section": "1.1 Название Quarto",
    "text": "1.1 Название Quarto\nАвторы научно-технической издательской системы хотели использовать название, которое имело значение в истории издательского дела, и остановились на Quarto.\nQuarto (от латинского quārtō, сокращенно Qto, 4to или 4º) – это книга или брошюра, изготовленная из полных листов, напечатанных с восемью страницами текста, по четыре на одну сторону, а затем сложенных дважды, чтобы получить четыре листа (не нужно путать с настольной абстрактной игрой Quarto или издательством The Quarto Group, которое продает иллюстрированные книги). Затем листы обрезаются, чтобы получить восемь страниц книги. Размер каждой напечатанной страницы составляет одну четвертую полного листа.\n\n\n\n\n\n\nРисунок 1: Сравнение форматов книг\n\n\n\nСамыми ранними из сохранившихся книг, напечатанных Гутенбергом подвижным шрифтом, являются кварто (примерно 1452–53 гг.), которые были напечатаны до Библии Гутенберга. Самый ранний из известных – это фрагмент средневековой поэмы «Сибилленбух» (Sibyllenbuch)."
  },
  {
    "objectID": "blog/posts/2022-11-13-quarto/index.html#quarto-позволяет",
    "href": "blog/posts/2022-11-13-quarto/index.html#quarto-позволяет",
    "title": "Научно-издательская система Quarto",
    "section": "1.2 Quarto позволяет",
    "text": "1.2 Quarto позволяет\n\nПредставлять анализ данных в доступном и наглядном виде.\nИметь возможность вывода в различных форматах: HTML, pdf, ePub, Word, PowerPoint и т.д. для единого источника публикации.\nИспользовать разметку, включающую формулы, цитаты, перекрестные ссылки, расширенные макеты и многое другое.\nИметь возможность публикации веб-документов в сети Интернет через различные сервисы.\nВключать интерактивные приложения и виджеты в HTML-документы.\nСоздавать документы с включением кода для воспроизводимых вычислений."
  },
  {
    "objectID": "blog/posts/2022-11-13-quarto/index.html#с-помощью-quarto-можно-создавать",
    "href": "blog/posts/2022-11-13-quarto/index.html#с-помощью-quarto-можно-создавать",
    "title": "Научно-издательская система Quarto",
    "section": "1.3 С помощью Quarto можно создавать",
    "text": "1.3 С помощью Quarto можно создавать\n\nСтатьи как для веб-публикации, так и подготовленные для научных издательств.\nПрезентации.\nВеб-страницы, включая блоги и техническую документацию.\nИнтерактивные книги, которые можно переводить различные форматы, пригодные для печати и электронных носителей."
  },
  {
    "objectID": "blog/posts/2022-11-13-quarto/index.html#примеры-разработок-на-quarto",
    "href": "blog/posts/2022-11-13-quarto/index.html#примеры-разработок-на-quarto",
    "title": "Научно-издательская система Quarto",
    "section": "1.4 Примеры разработок на Quarto",
    "text": "1.4 Примеры разработок на Quarto\nБольшим источником идей для создания рабочих материалов, сайтов, презентаций, статей, документации и другого похожего содержимого может служить Галерея примеров Quarto.\n\n\n\n\n\n\nРисунок 2: Галерея примеров Quarto\n\n\n\nДва примера мини-блогов на Quarto показаны ниже.\n\nПервый пример – это набор ссылок на полезные ресурсы по языку программирования R, опубликованный как GitHub Pages.\n\n\n\n\n\n\n\nРисунок 3: Набор ссылок на полезные ресурсы по языку программирования R\n\n\n\n\nМини-блог по визуализации данных Графики на досуге также сделан на Quarto и опубликован через Netlify.\n\n\n\n\n\n\n\nРисунок 4: Мини-блог по визуализации данных"
  },
  {
    "objectID": "blog/posts/2022-11-13-quarto/index.html#установка-quarto",
    "href": "blog/posts/2022-11-13-quarto/index.html#установка-quarto",
    "title": "Научно-издательская система Quarto",
    "section": "2.1 Установка Quarto",
    "text": "2.1 Установка Quarto\nДля установки Quarto, необходимо зайти на начальную страницу проекта https://quarto.org/ и перейти по адресу Get Started.\n\n\n\n\n\n\nРисунок 5: Начальная страница Quarto\n\n\n\nУстановка происходит в два этапа.\n\nШаг 1. Установка интерфейса командной строки (CLI) для актуальной операционной системы (Windows, Linux или Mac OS). Рекомендуется устанавливать стабильную версию Current Release со страницы загрузки, а не Release Candidate.\nШаг 2. Установка плагина для рабочей интегрированной среды разработки (IDE). Это может быть, например, VS Code, RStudio, Jupyter или иной текстовый редактор. Можно также установить Quarto-плагин, например, для Sublime Text или Emacs."
  },
  {
    "objectID": "blog/posts/2022-11-13-quarto/index.html#ide-инструменты",
    "href": "blog/posts/2022-11-13-quarto/index.html#ide-инструменты",
    "title": "Научно-издательская система Quarto",
    "section": "2.2 IDE-инструменты",
    "text": "2.2 IDE-инструменты\n\n2.2.1 RStudio\nЕсли Quarto CLI уже установлен, то RStudio обнаружит это и автоматически включит функции Quarto. В качестве альтернативы существует версия Quarto встроенная в RStudio, которую можно активировать в настройках R Markdown.\nСоздание нового Quarto-документа в RStudio с расширением .qmd происходит как File -&gt; New File -&gt; Quarto document…, что открывает новый документ на основе шаблона.\n\n\n\n\n\n\nРисунок 6: Вид визуального редактора Quarto в RStudio\n\n\n\nОтметим, что переключение кнопки Source на Visual позволяет перейти в режим визуального редактирования, который близок к WYSIWYG-редактору и может быть особенно полезен для создания таблиц в документах. Подробно о работе в RStudio можно посмотреть на соотетствующей странице документации. Для остановки фонового задания необходимо перейти на панель Background Jobs и нажать значок Stop.\n\n\n2.2.2 Visual Studio Code\nАльтернативно, VS Code предлагает возможность редактировать документы как с .qmd, так и с .ipynb-ноутбуками. Помимо предварительного просмотра документов, также работает подсветка синтаксиса для встроенных языков, автоматические подсказки, автозавершение для языков программирования, клавиатурные сочетания, сниппеты, предварительный просмотр в реальном времени для LaTeX, а также диаграмм Mermaid и Graphviz.\n\n\n\n\n\n\nРисунок 7: Вид визуального редактора в VS Code\n\n\n\nПреимущество VS Code состоит в большом количестве полезных плагинов, которые позволяют, например, работать с Git-системой управления версиями. Удобный проводник, мини-карта и диагностика для опций YAML делает VS Code отличным инструментом для создания больших проектов, например, книг. Работа VS Code в Quarto описана на странице документации.\n\n\n2.2.3 Jupyter\nДля тех, кто программирует на Julia или Python более привычным инструментом является система Jupyter-ноутбуков. Для того, чтобы создать Quarto-пример в Jupyter, необходимо в преамбулу документа добавить YAML-вставку и затем отрендерить .ipynb-ноутбук так, как это будет показано ниже. Если вместо Python используется Julia, то в преамбуле необходимо в качестве ядра указать jupyter: julia-1.10.\n\n\n\n\n\n\nРисунок 8: Пример Jupyter-ноутбука в Quarto на языке Python\n\n\n\n\n\n\n\n\n\nРисунок 9: Пример результата рендеринга ноутбука"
  },
  {
    "objectID": "blog/posts/2022-11-13-quarto/index.html#работа-с-проектами",
    "href": "blog/posts/2022-11-13-quarto/index.html#работа-с-проектами",
    "title": "Научно-издательская система Quarto",
    "section": "2.3 Работа с проектами",
    "text": "2.3 Работа с проектами\n\n2.3.1 Создание нового проекта\nЕсть несколько вариантов для создания проекта.\n\nСоздание проекта из командной строки.\n\n# веб-сайт\nquarto create-project mysite --type website\n# блог\nquarto create-project myblog --type website:blog\n# книга\nquarto create-project mybook --type book\n\nВ VS Code или в RStudio\n\nНапример, в RStudio: File -&gt; New Project… -&gt; New Directory.\n\n\n\n\n\n\nРисунок 10: Пример создания Quarto-проекта в RStudio\n\n\n\n\n\n2.3.2 Как Quarto организует рендеринг документов\nСначала Knitr (в R) или Jupyter (в Pyhton или Julia) выполняет все фрагменты кода .qmd-файла и создает новый markdown (.md) документ, который включает в себя код и его выходные данные.\n\n\n\n\n\n\nРисунок 11: Организация рендеринга документов в Quarto (источник)\n\n\n\nСозданный markdown-файл затем обрабатывается Pandoc для преобразования в различные форматы файлов, включая HTML, PDF, Word и другие форматы.\n\n\n2.3.3 Возможности для рендеринга\n\nМожно использовать кнопку Render в RStudio IDE или Visual Studio Code для рендеринга файла и предварительного просмотра выходных данных.\n\n\n\n\n\n\n\nРисунок 12: Кнопка Render в IDE\n\n\n\n\nQuarto в командной строке.\n\n\n\nTerminal\n\nquarto render &lt;input&gt; --to &lt;format&gt;\n\nНапример:\n\n\nTerminal\n\nquarto render document.qmd --to docx\n\n\nQuarto как R-библиотека.\n\nquarto::quarto_render(input = ___, output_format = ___)\nНапример:\nquarto_render(\"document.qmd\", output_format = \"pdf\")"
  },
  {
    "objectID": "blog/posts/2022-11-13-quarto/index.html#структура-документов-в-quarto",
    "href": "blog/posts/2022-11-13-quarto/index.html#структура-документов-в-quarto",
    "title": "Научно-издательская система Quarto",
    "section": "2.4 Структура документов в Quarto",
    "text": "2.4 Структура документов в Quarto\n\n2.4.1 Общая структура документов в Quarto\nУсловно, документ в Quarto состоит из трех базовых частей.\n\nМетаданные.\nТекст и Markdown.\nИсполняемый код.\n\n\n\n\n\n\n\nРисунок 13: Структура Quarto-документа (источник)\n\n\n\n\n\n2.4.2 Основы синтаксиса\nQuarto основан на Pandoc и использует разновидность markdown в качестве базового синтаксиса документа. Pandoc markdown – это расширенная и слегка переработанная версия синтаксиса markdown. Синтаксис включает в себя форматирование текста, заголовки, ссылки и рисунки, списки и таблицы.\nИсполняемый код записывается в специальные блоки (ячейки), в начале которых указывается язык программирования (Pandoc поддерживает более 140 языков) для выделения.\n```{python}\nprint(\"Goodbye, World!\")\n```\nЕсли мы хотим сделать код неисполняемым – нужно поставить точку перед указанием языка программирования.\n```{.julia}\nusing Plots\nplot(sin, x-&gt;sin(2x), 0, 2π, leg=false, fill=(0,:lavender))\n```\nВнутри ячейки в комментариях в верхней части блока можно указывать параметры. Параметры ячейки влияют на выполнение и вывод блоков исполняемого кода. Например:\n# метка для указания ссылки на рисунок\n#| label: fig-polar\n\n# выключение визуализированного вывода кода\n#| echo: false\n\n# подпись к рисунку\n#| fig-cap: \"График функции\"\n\n\n\n\n\n\nРисунок 14: Пример оформления ячейки кода с параметрами\n\n\n\nПри необходимости можно выделить элементы кода либо скрыть код, сделав развертывающийся блок.\n\n\n\n\n\n\nРисунок 15: Пример выделения элементов кода в Quarto\n\n\n\n\n\n2.4.3 Расширенные макеты\nОдним из лучших нововведений Quarto стали новые возможности для макетирования, например Quarto позволяет делать на полях сноски, библиографию, названия для рисунков, рисунки и даже таблицы. Кроме того, обновлены возможности компоновки блоков (например, рисунков или таблиц) как подэлементов (например, как подрисунков), работающих с перекрестными ссылками, а также работа с табами.\n\n\n\n\n\n\nРисунок 16: Пример компоновки рисунков в Quarto\n\n\n\nВ случае, если содержимое выходит за пределы области основного текста, его можно продолжить, используя правую и левую версии столбцов основного текста, страницы и экрана для компоновки содержимого. Например, как ниже:\n```{r}\n#| column: screen-inset-right\n\n1 + 1\n```\n\n\n\n\n\n\nРисунок 17: Примеры параметров для определения содержимого, выходящего за фиксированную ширину справа\n\n\n\n\n\n2.4.4 Выносные блоки\nИнтересной новинкой Quarto являются выносные блоки, которые служат способом привлечения дополнительного внимания к определенным концепциям или указанием, что определенное содержимое является дополнительным или применимо только к некоторым сценариям. Выносные блоки работают в HTML, PDF, MS Word, ePub и Revealjs.\n\n\n\n\n\n\nРисунок 18: Примеры выносных блоков\n\n\n\nНиже показан пример кода для оформления блока.\n:::{.callout-tip}\n## Совет\n\nЭтот элемент будет использоваться для рекомендаций и советов.\n:::\n\n\n2.4.5 Диаграммы\nВставка диаграмм – еще одно ноу-хау в Quarto, имеющее встроенную поддержку Mermaid и Graphviz диаграмм. Это позволяет создавать блок-схемы, диаграммы последовательностей, диаграммы состояний, диаграммы Ганта и многое другое, используя синтаксис обычного текста, мотивированный markdown.\n```{mermaid}\nflowchart LR\n  A[Прямоугольник] --&gt; B(Скругленные края)\n  B --&gt; C{Решение}\n  C --&gt; D[Первый результат]\n  C --&gt; E[Второй результат]\n```\n\n\n\n\n\n\nРисунок 19: Пример диаграммы\n\n\n\n\n\n2.4.6 Метаданные YAML\nМетаданные могут быть включены в Quarto-документ с помощью YAML либо в преамбуле в начале файла, либо отдельным _quarto.yml-файлом. С помощью YAML мы задаем, например, название документу, дату, автора, устанавливаем те параметры, которые необходимы при рендеринге документа, чтобы не писать их в командной строке и т.д.\nОчень обзорно, как используется структура YAML в Quarto:\n\nустановите параметр как key: value (ключ: значение);\nстроки с : должны быть в кавычках;\nвключайте несколько значений в список с помощью -;\nвкладывайте пары ключ-значение с помощью отступа;\nмногострочные строки следуют за |.\n\nПриведем простой пример YAML-части документа.\n---\ntitle: \"Документ в Quarto\"\nauthor: \n  - И.О. Исполнитель\n  - А.М. Заместитель\nformat: \n  html:\n    toc: true\n    abstract: |\n      Это аннотация.\n    \n      Это второй параграф.\n---\nТакже, приведем пример _quarto.yml-файла, соответствующего книге.\n\n\nПример YAML для книги (развернуть)\n\n# тип проекта - книга\nproject:\n  type: book\n\n# язык документа\nlang: ru\n# вид подсветки кода\nhighlight-style: github\n\nbook:\n  # название (заголовок) книги\n  title: \"Анализ и моделирование данных\"\n  # подзаголовок\n  subtitle: \"с использованием языка программирования R\"\n  # аннотация\n  abstract: \"В книге рассмотрены современные подходы к практическим задачам.\"\n  # URL проекта\n  site-url: \"https://book.netlify.app/\"\n  # URL репозитория\n  repo-url: \"https://github.com/book\"\n  # иесто издания\n  publisher-place: \"Москва, Красноярский край\"\n  # URL\n  url: \"https://book.netlify.app/\"\n  # имя автора\n  author:\n  - name:\n      given: Евгений\n      family: Матеров\n      literal: Е.Н. Матеров\n    # ORCID-индекс идентификации научных авторов (https://orcid.org/)\n    orcid: 0000-0001-1111-0111\n    # e-mail авторов\n    email: moskva@gmail.com\n    # организация\n    affiliation:\n      - name: МГУ имени М.В. Ломоносова\n  # дата на титульном листе проекта\n  date: today\n  # фавикон\n  favicon: \"favicon.png\"\n  # картинка обложки\n  cover-image: generate.png\n  # код сервиса Google Analytics\n  google-analytics: \"G-XXXXXXXXXX\"\n  # панель навигации\n  navbar:\n    # цвет фона панели навигации\n    background: \"#2860a1\"\n    collapse-below: lg\n  # боковая панель\n  sidebar:\n    collapse-level: 0\n    style: \"floating\"\n    background: white\n    foreground: dark\n    logo: sidebar_logo.jpg\n  # нижний колонтитул страницы\n  page-footer:\n    border: true\n    background: light\n    left: \n      |\n      МГУ имени М.В. Ломоносова\n  # главы\n  chapters:\n    - index.qmd\n    # раздел\n    - part: \"Введение\"\n      chapters:\n        - Intro Chapter/intro.qmd\n    - part: \"Работа с табличными данными\"\n      chapters:\n        - Table data Chapter/tidy data.qmd\n        - Table data Chapter/base table.qmd\n        - Table data Chapter/deep table.qmd\n    - part: \"Визуализация данных\"\n      chapters:\n        - Visualization Chapter/visualization.qmd\n        - Visualization Chapter/color.qmd\n    - Conclusion Chapter/Conclusion.qmd        \n    - references.qmd\n  # приложения\n  appendices:\n    - Appendicies/R install.qmd\n    - Appendicies/Samples.qmd          \n\n# расположение сносок\n# https://quarto.org/docs/reference/formats/pdf.html#footnotes\nreference-location: margin\n\n# файл библиографии\nbibliography: references.bib\n\nformat:\n  html:\n    # тема\n    theme: pulse\n    # свертка кода в HTML\n    code-fold: false\n    # содержание\n    toc: true\n\n# опции для исполняемого кода\nexecute:\n  execute_notebooks: force\n  allow_errors: true\n  # разрешить кэширование\n  cache: true    \n\n# ключи перекрестных ссылок метаданных\ncrossref:\n  # название приложений\n  appendix-title: \"Приложение\"\n  appendix-delim: \":\"\n\ncrossref-apx-prefix: \"Приложение\"\n\n# цитирование, см. также\n# https://quarto.org/docs/authoring/create-citeable-articles.html\ncitation:\n  url: https://book-training.netlify.app/\n\n# переопределение перевода\nlanguage:\n  title-block-affiliation-single: \"Организация\"\n\n\n\n2.4.7 Формулы в Quarto\nМатематические формулы в Quarto используют разделители $ для встроенных математических элементов текста и разделители $$ для выносной математики на основе LaTeX-синтаксиса. Для математической обработки HTML с использованием MathJax (по умолчанию) можно использовать команды \\def, \\newcommand, \\renewcommand, \\newenvironment, \\renewenvironment и \\let для создания собственных макросов и сред. Также доступны, например, форматы KaTeX, GladTeX, MathML или просто plain-формат. В визуальном редакторе происходит автоматический предосмотр формул.\n\n\n\n\n\n\nРисунок 20: Пример оформления LaTeX-формулы в визуальном редакторе\n\n\n\nФорматы журнальных статей часто требуют детального контроля создаваемых выходных данных, а также возможности использования специфичных для журнала команд и директив. Это может быть достигнуто для форматов Quarto путем предоставления пользовательских шаблонов Pandoc (например, LaTeX). Часто эти шаблоны представляют собой смесь специфичного для журнала стиля LaTeX и стандартных директив, требуемых Pandoc.\nПредоставляя свой собственный пользовательский шаблон, используемый при рендеринге, мы получаем полный контроль над конечным результатом. Пользовательский шаблон задается подобным образом через YAML:\n---\nformat:\n  pdf:\n    template: mytemplate.tex\n---    \nВ пользу Quarto можно отметить то, что с уходом MS Equation и дороговизной MathType, создание несложных документов с математическими формулами в MS Word, не использующими полного погружения в LaTeX, можно осуществить как связку .qmd -&gt; .docx."
  },
  {
    "objectID": "blog/posts/2022-11-13-quarto/index.html#локализация",
    "href": "blog/posts/2022-11-13-quarto/index.html#локализация",
    "title": "Научно-издательская система Quarto",
    "section": "2.5 Локализация",
    "text": "2.5 Локализация\nВ Quarto достаточно указать в YAML-части документа нужный язык, и документ будет локализован должным образом, например, “Figure” будет заменено на “Рисунок” и т.д. Локализацию можно отнести к преимуществам Quarto, например, в blogdown уже нет такого простого подхода для перевода названия рисунков.\n---\ntitle: \"Документ\"\nlang: ru\n---\nТем не менее, бывают случаи когда нужно переопределить перевод того или иного термина. Это делается следующим образом. Скажем, пусть мы хотим, чтобы affiliation в YAML-фрагменте кода ниже соответствовало “ОРГАНИЗАЦИЯ” в образе документа, а не “ПРИНАДЛЕЖНОСТЬ”, как это сделано по умолчанию.\n---\nbook:\n  author:\n    affiliation:\n      - name: МГУ имени М.В.Ломоносова\n---      \nНа странице локализации указаны .yml-файлы с языками, например _language-ru.yml содержит перевод понятий на русский язык, в частности, строка title-block-affiliation-single: \"принадлежность\" содержит нужный перевод. Переопределить перевод можно добавив в конце YAML-файла строки:\n---\nlanguage:\n  title-block-affiliation-single: \"организация\"\n---      \nОдин из способов получения .pdf-документа на локализованном (не английском) языке, это цепочка .qmd -&gt; .docx -&gt; .pdf. При этом, для создания MS Word-документов можно использовать шаблоны. Другой способ локализации .pdf-вывода автору подсказал Сергей Валерьевич Бабёнышев. Для этого необходимо скачать файл с TeX-заготовкой и поместить в папку с проектом. Пример .qmd документа показан ниже.\n\n\nПример документа с элементами LaTeX-формул для рендеринга в PDF (развернуть)\n\n---\nlang: ru\ntitle: \"Задания\"\nformat:\n    pdf:\n        toc: true\n        number-sections: true\n        color-links: true\n        keep-tex: false\n        template: template.tex\n\nexecute:\n    echo: false\n# jupyter: python3\nmainfont: \"Times New Roman\"\n---\n\n# Найти матрицу обратную к заданной\n\n$$\n\\text{\na) $\\begin{pmatrix}\n  3 & -1 &  3 \\\\\n -2 & -2 &  3 \\\\\n  4 &  0 &  1 \\\\\n\\end{pmatrix}$;\n\\ \\ \\ \\ \\ \nб) $\\begin{pmatrix}\n -1 & -1 &  2 \\\\\n  2 & -2 &  2 \\\\\n  4 &  4 &  3 \\\\\n\\end{pmatrix}$.\n$$\n\n# Кривые второго порядка\n\nа) Написать каноническое уравнение эллипса, если его большая полуось равна 5, а фокусы расположены в точках  $(\\pm4, 0)$.\n\n# Найти наклонные асимптоты графика функции\n\n$$\n\\text{\nа) $\\displaystyle y=\\frac{\\sqrt{x}}{3+2\\sqrt{x}}$.\\ \\ \\ \\ \\ \nб) $\\displaystyle y=\\frac{2\\sqrt{x}}{1+2x}$.}\n$$\n\n# Вычислить двойной интеграл\n\na) $\\displaystyle\\iint\\limits_{G}{{{({{x}^{2}}+{{y}^{2}})}^{6}}dx}dy$,\nгде $G$ – сектор круга радиуса 1 с центром в начале координат, лежащий во II квадранте.\n\n Откройте терминал, перейдите в папку проекта и наберите команду\n\n\nTerminal\n\nquarto render your_file_name.qmd --to pdf\n\nЕще один способ локализации описан в статье Как рендерить R Markdown в PDF на кириллице:\n---\ntitle: \"Cyrillic markdown\"\nformat: pdf\npdf-engine: lualatex\nmainfont: Segoe UI\nsansfont: Segoe UI\nmonofont: Cascadia Mono PL Light\neditor: visual\n---\n```\n#| r include = F\nlibrary(showtext)\nshowtext_auto()\n```"
  },
  {
    "objectID": "blog/posts/2022-11-13-quarto/index.html#этапы-публикации-в-netlify",
    "href": "blog/posts/2022-11-13-quarto/index.html#этапы-публикации-в-netlify",
    "title": "Научно-издательская система Quarto",
    "section": "3.1 Этапы публикации в Netlify",
    "text": "3.1 Этапы публикации в Netlify\nУдобство работы с Netlify состоит в автоматизации рабочего процесса путем интеграции с Git-сервисами. На главной странице Netlify необходимо сделать Log in, затем выбрать Add new site, где нужно выбрать Import an existing project.\n\n\n\n\n\n\nРисунок 22: Страница импорта проекта Netlify\n\n\n\nЗатем необходимо указать репозиторий GitHub который был создан ранее.\n\n\n\n\n\n\nРисунок 23: Страница импорта проекта в Netlify из GitHub-репозитория\n\n\n\nПосле того, как был выбран репозиторий, нужно указать рабочую папку проекта (в нашем случае это _site).\n\n\n\n\n\n\nРисунок 24: Пример добавления папки проекта\n\n\n\nОкончательно, нужно нажать на кнопку Deploy site и в настройках переименовать название сайта.\nТеперь каждый раз, когда делается push командой Git (например, в терминале или в RStudio), через некоторый короткий промежуток времени обновляется и веб-страница.\nЕсли необходимо быстро опубликовать материал (например, презентацию), который не будет обновляться с течением времени или нет необходимости работать с Git, то достаточно воспользоваться сервисом Netlify Drop: перетащите папку _site в соответствующую область экрана, при этом переименуйте основной .html-файл в index.html.\n\n\n\n\n\n\nРисунок 25: Сервис Netlify Drop"
  },
  {
    "objectID": "blog/posts/2022-11-13-quarto/index.html#этапы-публикации-в-github-pages",
    "href": "blog/posts/2022-11-13-quarto/index.html#этапы-публикации-в-github-pages",
    "title": "Научно-издательская система Quarto",
    "section": "3.2 Этапы публикации в GitHub Pages",
    "text": "3.2 Этапы публикации в GitHub Pages\nПодробно публикация на GitHub Pages описана на странице GitHub Docs. Для публикации Quarto-репозитория как страницы на GitHub достаточно зайти в раздел Settings и выбрать слева Pages для настройки.\n\n\n\n\n\n\nРисунок 26: Настройка GitHub Pages"
  },
  {
    "objectID": "blog/posts/2022-11-13-quarto/index.html#этапы-публикации-в-quarto-pub",
    "href": "blog/posts/2022-11-13-quarto/index.html#этапы-публикации-в-quarto-pub",
    "title": "Научно-издательская система Quarto",
    "section": "3.3 Этапы публикации в Quarto Pub",
    "text": "3.3 Этапы публикации в Quarto Pub\nQuarto Pub – это новый сервис для публикации статических HTML-документов, который был внедрен одновременно с Quarto. Процесс публикации в Quarto Pub описан на странице документации. Сделаем краткий обзор Quarto Pub.\nПосле того, как был создан проект, необходимо открыть терминал с директорией проекта и набрать в терминале команду как написано ниже.\n\n\nTerminal\n\nquarto publish quarto-pub\n\nТеперь в терминале необходимо ответить на вопросы, которые будут заданы в процессе публикации и сайт будет опубликован на https://your-account.quarto.pub/site-name/.\nСовет: в качестве site-name Quarto Pub будет предлагать сокращенное название блога или иного документа, которое может быть на русском языке, не используйте кириллицу для сокращенного названия сайта, замените на иное название.\n\n\n\n\n\n\nРисунок 27: Этапы публикации в Quarto Pub в терминале\n\n\n\nОпубликованными сайтами можно управлять на https://quartopub.com. Нажмите на мини-образ сайта, чтобы перейти на страницу администратора, которая позволяет вам изменить краткое название сайта, сделать сайт по умолчанию для вашей учетной записи или полностью удалить сайт.\n\n\n\n\n\n\nРисунок 28: Страница администрирования в Quarto Pub\n\n\n\nСервис Quarto Pub публикует материалы очень быстро, поддерживает GitHub Actions, однако у него меньше функциональных возможностей чем у Netlify или GitHub Pages."
  },
  {
    "objectID": "blog/posts/2022-11-13-quarto/index.html#виды-расширений",
    "href": "blog/posts/2022-11-13-quarto/index.html#виды-расширений",
    "title": "Научно-издательская система Quarto",
    "section": "5.1 Виды расширений",
    "text": "5.1 Виды расширений\n\nShortcodes – это специальные директивы markdown, которые генерируют различные типы контента.\nFilters – это гибкий инструмент для внедрения новых глобальных моделей поведения и/или новых моделей рендеринга markdown.\nCustom Formats позволяют создавать новые форматы вывода, объединяя параметры документа, шаблоны, таблицы стилей и другое содержимое.\n\nКаждый тип расширения имеет свои собственные требования к разработке: в некоторых случаях расширение может быть создано только с использованием метаданных YAML, однако во многих случаях необходимо выполнять некоторые пользовательские сценарии с использованием Lua.\nПо категориям, расширения можно отнести к следующим типам.\n\nShortcodes and Filters\nJournal Articles\nCustom Formats\nRevealjs Extensions\n\nЧто умеют расширения? Например, создавать новые форматы вывода, объединяя параметры документа, шаблоны, таблицы стилей и другое содержимое; создавать элементы кода для вставки твитов или видео в документ или значков Fontawesome, служить шаблонами-заготовками для научных статей и т.д."
  },
  {
    "objectID": "blog/posts/2022-11-13-quarto/index.html#расширение-shinylive-для-quarto",
    "href": "blog/posts/2022-11-13-quarto/index.html#расширение-shinylive-для-quarto",
    "title": "Научно-издательская система Quarto",
    "section": "5.2 Расширение Shinylive для Quarto",
    "text": "5.2 Расширение Shinylive для Quarto\nБольшой интерес вызывает развитие нового проекта Shiny for Python, который позволяет добавлять интерактивность в документы с помощью Python-кода. Расширение Shinylive позволяет встраивать приложения Shiny для Python в документы Quarto, которые полностью запускаются в браузере с использованием Pyodide (Python, скомпилированный в WebAssembly). В настоящий момент Shinylive (как и Shiny for Python) является экспериментальным проектом, для работы Shinylive требуется:\n\nQuarto Release Candidate версии 1.2.x;\nPython версии 3.8 или выше;\nтекущая версия Python-библиотеки shinylive, которая может быть установлена как:\n\n\n\nTerminal\n\npip install shinylive --upgrade\n\n\n\n\n\n\n\nРисунок 30: Пример Shiny for Python в Quarto\n\n\n\nЗа дальнейшим развитием проекта можно следить на странице Shinylive, автором которой является @Winston Chang, см. также статью. Также, вызывает интерес расширение Quarto для WebR."
  },
  {
    "objectID": "blog/posts/2022-11-13-quarto/index.html#docker-и-dev-container-features",
    "href": "blog/posts/2022-11-13-quarto/index.html#docker-и-dev-container-features",
    "title": "Научно-издательская система Quarto",
    "section": "6.1 Docker и Dev Container Features",
    "text": "6.1 Docker и Dev Container Features\nPeter Solymos написал две статьи касающиеся работы Docker с Quarto:\n\nHow to Set Up Quarto with Docker, Part 1: Static Content.\nHow to Set Up Quarto with Docker, Part 2: Dynamic Content.\n\nJames Goldie опубликовал статью Dev containers with R and Quarto.\nDev Container Features – это автономные блоки установочного кода, конфигурации контейнера и/или настроек и расширений, предназначенные для включения новых возможностей разработки в вашем dev-контейнере. Они могут быть созданы для работы с широким спектром изображений базовых контейнеров и предоставляют быстрый способ связать метаданные контейнеров с некоторыми шагами установки. Вы можете добавить их в свои контейнеры с помощью простой ссылки. Например, Dev Container Features (for R) теперь включают в себя установку Quarto CLI."
  },
  {
    "objectID": "blog/posts/2022-11-13-quarto/index.html#github-actions-и-continuous-integration-ci",
    "href": "blog/posts/2022-11-13-quarto/index.html#github-actions-и-continuous-integration-ci",
    "title": "Научно-издательская система Quarto",
    "section": "6.2 GitHub Actions и Continuous Integration (CI)",
    "text": "6.2 GitHub Actions и Continuous Integration (CI)\nРабота с системой контроля версий (CI) описана на странице документации Quarto и относится к практике автоматической публикации содержимого из кода, при этом уделяется особое внимание к проверке отображаемых выходных данных в системе управления версиями, где происходит выполнение кода и рендеринг – локально или на сервере, в зависимости от различных сценариев и записи зависимостей в R, Python или Julia.\n\nСтатья Quarto Website with GitHub Actions рассматривает использование действий GitHub для рендеринга и публикации веб-сайта Quarto.\n@Beatriz Milz написала статью Monitoring quarto-dev repositories: Creating a workflow with GitHub Actions for R users о том, как можно создать рабочий процесс для мониторинга репозиториев на GitHub.\nGithub Actions for Quarto – В этом репозитории хранятся действия GitHub, полезные для создания и публикации документов Quarto."
  },
  {
    "objectID": "blog/posts/2022-11-13-quarto/index.html#подробное-руководство-по-использованию-quarto",
    "href": "blog/posts/2022-11-13-quarto/index.html#подробное-руководство-по-использованию-quarto",
    "title": "Научно-издательская система Quarto",
    "section": "7.1 Подробное руководство по использованию Quarto",
    "text": "7.1 Подробное руководство по использованию Quarto\nДля Quarto существует хорошее введение на странице документации и достаточно подробное руководство, описывающее практически все аспекты работы с Quarto.\n\n\n\n\n\n\nРисунок 31: Страница руководства по использованию Quarto"
  },
  {
    "objectID": "blog/posts/2022-11-13-quarto/index.html#советы-дня-по-quarto",
    "href": "blog/posts/2022-11-13-quarto/index.html#советы-дня-по-quarto",
    "title": "Научно-издательская система Quarto",
    "section": "7.2 Советы дня по Quarto",
    "text": "7.2 Советы дня по Quarto\nК началу конференции rstudio::conf(2022) @Mine Çetinkaya-Rundel запустила проект Советы дня по Quarto, включающий короткие заметки с советами по использованию Quarto. Здесь можно найти множество полезных идей начиная от аннотирования слайдов до включения темной темы.\n\n\n\n\n\n\nРисунок 32: Страница “Советы дня по Quarto”"
  },
  {
    "objectID": "blog/posts/2022-11-13-quarto/index.html#практический-семинар-от-r-markdown-до-quarto",
    "href": "blog/posts/2022-11-13-quarto/index.html#практический-семинар-от-r-markdown-до-quarto",
    "title": "Научно-издательская система Quarto",
    "section": "7.3 Практический семинар “От R Markdown до Quarto”",
    "text": "7.3 Практический семинар “От R Markdown до Quarto”\nТакже, в качестве сателлита к rstudio::conf(2022), проходил практический семинар From R Markdown to Quarto, материалы которого доступны на GitHub странице. В частности, на странице Materials можно найти несколько подробных презентаций по введению в Quarto.\n\n\n\n\n\n\nРисунок 33: Страница практического семинара “От R Markdown к Quarto”"
  },
  {
    "objectID": "blog/posts/2022-11-13-quarto/index.html#практический-семинар-приступая-к-работе-с-quarto",
    "href": "blog/posts/2022-11-13-quarto/index.html#практический-семинар-приступая-к-работе-с-quarto",
    "title": "Научно-издательская система Quarto",
    "section": "7.4 Практический семинар “Приступая к работе с Quarto”",
    "text": "7.4 Практический семинар “Приступая к работе с Quarto”\n@Tom Mock провел более чем двухчасовую YouTube-презентацию Welcome to Quarto Workshop!, слайды которой Getting Started with Quarto также имеются в открытом доступе.\n\n\n\n\n\n\nРисунок 34: Страница практического семинара “Приступая к работе с Quarto”"
  },
  {
    "objectID": "blog/posts/2022-11-13-quarto/index.html#создание-блога-в-quarto",
    "href": "blog/posts/2022-11-13-quarto/index.html#создание-блога-в-quarto",
    "title": "Научно-издательская система Quarto",
    "section": "7.5 Создание блога в Quarto",
    "text": "7.5 Создание блога в Quarto\n@Isabella Velásquez провела YouTube-презентацию Building a Blog with Quarto, материалы которой можно найти на странице как RStudio Enterprise Community Meetup. Основу составила хорошо оформленная документация по созданию блога.\n\n\n\n\n\n\nРисунок 35: Страница практического семинара “Построение блога с Quarto”\n\n\n\nКроме того, можно порекомендовать статью Creating your personal website using Quarto автора @Samantha Csik по созданию собственных веб-страниц и блогов в Quarto.\nОтметим, что при создании новых записей в блогах может возникнуть вопрос о совместимости библиотек из старых сообщений с обновленными. Кроме того, нет смысла в рендеринге старых сообщений, которые уже опубликованы. Решение этих проблем в Quarto заключается в замораживании вывода вычислительных сообщений в блоге. Подробно про опцию freeze можно почитать на странице документации."
  },
  {
    "objectID": "blog/posts/2022-11-13-quarto/index.html#страница-awesome-quarto",
    "href": "blog/posts/2022-11-13-quarto/index.html#страница-awesome-quarto",
    "title": "Научно-издательская система Quarto",
    "section": "7.6 Страница Awesome Quarto",
    "text": "7.6 Страница Awesome Quarto\n@Mickaël Canouil ведет страницу Awesome Quarto на GitHub, где собраны список документов, инструментов, примеров и статей по Quarto.\n\n\n\n\n\n\nРисунок 36: Страница Awesome Quarto\n\n\n\nНа данном сайте можно найти много шаблонов документов и расширений Quarto."
  },
  {
    "objectID": "blog/posts/2022-11-13-quarto/index.html#дополнительные-материалы",
    "href": "blog/posts/2022-11-13-quarto/index.html#дополнительные-материалы",
    "title": "Научно-издательская система Quarto",
    "section": "7.7 Дополнительные материалы",
    "text": "7.7 Дополнительные материалы\nСейчас существует очень большое количество различных интересного содержательного материала, касающегося Quarto. Ниже указан лишь небольшой список, где каждый найдет что-то интересное для себя.\nВидео-материалы:\n\nQuarto - J.J. Allaire (интервью)\nReproducible Publications with Julia and Quarto | J.J. Allaire | JuliaCon 2022\nMine Çetinkaya-Rundel & Julia Stewart Lowndes | Hello Quarto: Share, Collaborate, Teach, Reimagine\nQuarto | Posit PBS\nReproducible Medical Research with Quarto (Thomas Mock)\nTom Mock | Quarto for the Curious | RStudio (2022)\nHamel Husain | Literate Programming With Jupyter Notebooks and Quarto | RStudio (2022)\nBlogging with Quarto: a 10 minute getting started tutorial\nR-Ladies Freiburg (English) - Getting to know Quarto\nQuarto | Dr Lyndon Walker\nHow to style your Quarto blog without knowing a lot of HTML/CSS\nOpenscapes Community Call 06: Hello Quarto! Co-hosted with RLadies Santa Barbara\n\nПрезентации:\n\nQuarto as reveal.js Slides\nQuarto for the curious\nDemocratizing Data Science Teams / With Quarto\n\nВеб-материалы:\n\n6 Productivity Hacks for Quarto\nQuarto experiments"
  },
  {
    "objectID": "blog/posts/2022-11-13-quarto/index.html#footnotes",
    "href": "blog/posts/2022-11-13-quarto/index.html#footnotes",
    "title": "Научно-издательская система Quarto",
    "section": "Сноски",
    "text": "Сноски\n\n\nВ настоящий момент в Quarto реализован вариант интерактивных дэшбордов.↩︎"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Евгений Матеров",
    "section": "",
    "text": "Меня зовут Евгений Матеров. Я автор данного блога по анализу, визуализации данных и машинному обучению.\nКандидат физико-математических наук, в настоящий момент являюсь заведующим кафедрой физики, математики и информационных технологий.\nОбласть моих научных интересов включает некоторые аспекты алгебраической геометрии (торические многообразия, зеркальная симметрия), теорию многомерных вычетов, элементы коммутативной и гомологической алгебры, комбинаторику многогранников, Data Science, машинное обучение."
  },
  {
    "objectID": "about.html#опыт-работы",
    "href": "about.html#опыт-работы",
    "title": "Евгений Матеров",
    "section": "Опыт работы",
    "text": "Опыт работы\n\n\n\n\n\n\nДата\nЗанимаемая должность\n\n\n\n\n\n2009 - настоящее время\nФГБОУ ВО Сибирская пожарно-спасательная академия ГПС МЧС России, Россия, Красноярский край, г. Железногогрск\nЗаведующий кафедрой физики, математики и информационных технологий\n\n\n\n2008 - 2009\nFreie Universität Berlin, Deutschland\nBerlin Mathematical School Professor\n\n\n\n2005 - 2008\nUniversity of Massachusstes, Amherst, USA\nPostdoctoral fellow\n\n\n\n2002 - 2003\nMax-Planck-Institut für Mathematik, Bonn, Deutschland\nResearch member\n\n\n\n2000 - 2002\nEberhard Karls Universität Tübingen, Deutschland\nBAT IIa Postdoctoral Position"
  },
  {
    "objectID": "about.html#контакты",
    "href": "about.html#контакты",
    "title": "Евгений Матеров",
    "section": "Контакты",
    "text": "Контакты\nРабочий адрес: 662972, Красноярский край, г. Железногорск, ул. Северная, 1."
  }
]